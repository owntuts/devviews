---
sidebar_position: 3
id: authentication-authorization
sidebar_label: Authentication Authorization
title: Authentication Authorization
---
<!-- https://brandfolder.com/workbench/extract-text-from-image -->
<!-- ![RBAC](/img/interviews/design-system/RBAC.png) -->

### Authentication vs Authorization

<details open>
  <summary><h5>Authentication vs Authorization</h5></summary>

Authentication and authorization are two different but related processes that are used to verify who a user is and what they can do in a system or an application.

- **Authentication** is the process of ***verifying the identity*** of a user or a service. It answers the question: ***Who are you?***
- **Authorization** is the process of ***granting or denying access to resources or actions*** based on the identity and permissions of a user or a service. It answers the question: ***What can you do?***

For example, when you log in to your email account, you have to provide your ***username and password. This is authentication***, as you are proving that you are the owner of the account. Once you are authenticated, you can ***access your inbox, send and receive emails, delete or archive messages, etc. This is authorization***, as you are allowed to perform certain actions on certain resources based on your role and privileges.

There are different ways of implementing authentication and authorization in different systems and applications, depending on the requirements and preferences of the developers and users. Some of the common mechanisms are:

- **Passwords**: Usernames and passwords are the most common authentication factors. If a user enters the correct data, the system assumes the identity is valid and grants access.
- **One-time pins**: Grant access for only one session or transaction. Authentication apps generate security codes via an outside party that grants access.
- **Biometrics**: A user presents a fingerprint or eye scan to gain access to the system.
- **OAuth 2.0**: A standard protocol for ***delegating access to resources on behalf of a user*** or a service. It uses tokens that represent scopes and roles to grant permissions to clients.
- **JWT**: A compact and self-contained way of representing claims between parties. It uses JSON objects that are digitally signed or encrypted to encode information about the issuer, the subject, the audience, and the expiration of the token.
- **API Gateway**: A ***single entry point for all clients*** that provides a unified interface for accessing multiple services. It can also perform authentication and authorization functions by validating tokens, enforcing policies, and routing requests¹².
- **OpenID Connect**: A ***layer on top of OAuth 2.0*** that provides identity information about the user or the service. It ***uses an ID token*** that contains claims about the authenticated party.
- **Attribute-Based Access Control (ABAC)**: A model that defines authorization policies based on attributes of the subject, the object, the environment, and the action. It allows for more dynamic and context-aware authorization decisions.

</details>

<details>
  <summary><h5>Session Based Authentication vs Token Based Authentication</h5></summary>

| Aspect | Session based authentication | Token based authentication |
| --- | --- | --- |
| Definition | A process where the server creates a session for the user after the user logs in. The session is stored in a session store on the server side, and the server sends a session ID to the user as a cookie. The user sends the session ID with every request, and the server uses it to retrieve the session data and verify the user's identity and permissions¹². | A process where the server generates a token for the user after the user logs in. The token is a JSON object that contains information about the user's identity and permissions, as well as some metadata such as expiration time and signature. The token is sent to the user as a response, and the user stores it on the client side. The user sends the token with every request, and the server uses it to verify the user's identity and permissions without needing to access a session store. |
| Advantages | Easier to implement, as it relies on the built-in session mechanism of many web frameworks. | More secure, as it does not expose any sensitive information such as passwords or session IDs over the network. |
| Disadvantages | Requires more server resources, as it needs to store and manage sessions for each user¹². Introduces some challenges for scalability and load balancing, as it needs to ensure that sessions are consistent across multiple servers or instances¹². | Requires more client-side logic, as it needs to store and manage tokens for each user. Introduces some challenges for revocation and expiration, as it needs to ensure that tokens are invalidated or refreshed when needed. |
| Examples | Passwords, One-time pins, Biometrics. | OAuth 2.0, JWT, OpenID Connect. |

</details>

<details>
  <summary><h5>How session based authentication works</h5></summary>

Here are some of the main steps of how session based authentication works:

![session-auth](/img/interviews/design-system/session-auth.png)

- The user ***sends a login request*** to the server with their credentials, such as username and password.
- The server ***validates the credentials*** and checks if they match with the ones stored in the database.
- If the credentials are valid, the ***server creates a new session for the user and stores*** some information about them, such as their role, preferences, etc. This information can be stored in memory, file system, or database.
- The server also ***generates a unique identifier for the session, called a session ID***. This ID is usually a long and random string that is hard to guess or forge.
- The server ***sends the session ID to the user as a cookie***. A cookie is a small piece of data that is stored in the user's browser and sent back to the server with every request.
- The ***user sends subsequent requests to the server with the cookie attached***. The cookie contains the session ID that identifies the user's session.
- The server receives the cookie and extracts the session ID from it. It then uses this ID to ***look up the session information from the storage*** and verify if the user is authenticated and authorized to access the requested resource or action.
- If the session ID is valid and matches with an existing session, the server grants access to the user and sends back the requested data or response. If not, it denies access and sends back an error or redirect message.

Session based authentication has some advantages and disadvantages, depending on the requirements and preferences of the developers and users. Some of them are:

- Session based authentication is ***easy to implement***, as it relies on the built-in session mechanism of many web frameworks.
- Session based authentication ***requires more server resources***, as it needs to store and manage sessions for each user.
- Session based authentication ***introduces some challenges for scalability and load balancing***, as it needs to ensure that sessions are consistent across multiple servers or instances.
- Session based authentication may be ***vulnerable to some attacks, such as cross-site request forgery (CSRF) or session hijacking***.

</details>

<details>
  <summary><h5>How token based authentication works</h5></summary>

Here are some of the main steps of how token based authentication works:

![token-auth](/img/interviews/design-system/token-auth.png)

- The user ***sends a login request*** to the server with their credentials, such as username and password.
- The server ***validates the credentials*** and checks if they match with the ones stored in the database.
- If the credentials are valid, the server ***creates a new token (JWT - JSON Web Token) for the user using a secret key and some algorithms***. The token contains some claims about the user, such as their role, preferences, etc. The token also has an expiration time and a signature that ensures its integrity and authenticity.
- The server ***sends the token to the user*** as a response. The token is usually encoded in Base64 format, which makes it compact and easy to transfer.
- The ***user stores the token on the client side***, either in local storage, session storage, or a cookie. The user also sets an authorization header with the token value for every request to the server.
- The server receives the token from the authorization header and ***decodes it using the same secret key and algorithms***. It then verifies if the token is valid and not expired or tampered with.
- If the token is valid, the server grants access to the user and sends back the requested data or response. If not, it denies access and sends back an error or redirect message.

Token based authentication has some advantages and disadvantages, depending on the requirements and preferences of the developers and users. Some of them are:

- Token based authentication ***is more secure***, as it does not expose any sensitive information such as passwords or session IDs over the network.
- Token based authentication allows for more stateless and RESTful design, as it does ***not depend on any server-side storage or state***.
- Token based authentication ***enables more flexibility and interoperability***, as it can be used across different platforms and devices.
- Token based authentication ***requires more client-side logic***, as it needs to store and manage tokens for each user.
- Token based authentication introduces some ***challenges for revocation and expiration***, as it needs to ensure that tokens are invalidated or refreshed when needed.

</details>

<details>
  <summary><h5>JWT token structure</h5></summary>

JWT stands for **JSON Web Token**, which is a standard format for securely transmitting information between parties as a JSON object. A JWT token consists of three parts separated by dots (.): ***the header, the payload, and the signature***. Let me explain each part in more detail:

- The **header** contains metadata about the type of token and the cryptographic algorithm used to secure its contents. For example, the header may look like this:

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

This means that the token is a JWT and that it is signed using the `HMAC SHA256` algorithm. The header is then `Base64-URL` encoded to form the first part of the JWT.

- The **payload** contains the claims, which are statements about an entity (typically, the user) and additional data. There are three types of claims: ***registered, public, and private***. Registered claims are predefined and optional, such as `iss` (issuer), `exp` (expiration time), `sub` (subject), and `aud` (audience). Public claims are defined by the users of JWTs, but should be registered in the IANA JSON Web Token Registry or be defined as a URI to avoid collisions. Private claims are custom and specific to the parties involved. For example, the payload may look like this:

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

This means that the subject of the token is `1234567890`, the name is `John Doe`, and the user is an admin. The payload is also Base64-URL encoded to form the second part of the JWT.

- The **signature** is used to verify that the ***sender of the JWT*** is who it says it is and that the message has not been tampered with. To create the signature, the Base64-encoded header and payload are taken, along with a secret key, and signed with the algorithm specified in the header. For example, if you are using the HMAC SHA256 algorithm, you would do something like this:

```javascript
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

The signature is then Base64-URL encoded to form the third and final part of the JWT.

A complete JWT token may look something like this:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
```

You can decode and verify a JWT token using online tools such as [jwt.io](^1^) or [jsonwebtoken.com](^2^).

</details>

<details>
  <summary><h5>OAuth 2</h5></summary>

OAuth 2 is an authorization framework that ***allows third-party applications to access user accounts on behalf of the user***. The OAuth 2 server is responsible for issuing authorization tokens to third-party applications. The authorization token is used to request an access token from the OAuth 2 server. The access token is then used to access the user's account on the resource server.

![oath2](/img/interviews/design-system/oath2.png)

The steps involved in the OAuth 2 authorization flow are as follows:

1. The third-party application ***requests an authorization token from the OAuth 2 server***. Example, sending url `/oauth/authorize?response_type=code&client_id=CLIENT_ID&redirect_uri=CALLBACK_URL&scope=write` (i.e, register your app to facebook first to get auth url).
2. The OAuth 2 server redirects the user to the resource server, where the ***user can grant or deny access*** to the third-party application. If the user grants access, the resource server redirects the user back to the third-party application with an authorization code. Example, `/callback#token=ACCESS_TOKEN`
3. The third-party application ***uses the authorization code to request an access token*** from the OAuth 2 server. Example, `https://cloud.digitalocean.com/v1/oauth/token?client_id=CLIENT_ID&client_secret=CLIENT_SECRET&grant_type=authorization_code&code=AUTHORIZATION_CODE&redirect_uri=CALLBACK_URL`
4. The OAuth 2 server ***issues the access token to the third-party application***. Example, If come with Access Token is a Refresh token. Then, you can get new Access token if it's expired:
`/oauth/token?grant_type=refresh_token&client_id=CLIENT_ID&client_secret=CLIENT_SECRET&refresh_token=REFRESH_TOKEN`
5. The third-party application uses the access token to access the user's account on the resource server. Example, `curl -X POST -H "Authorization: Bearer ACCESS_TOKEN""https://api.digitalocean.com/v2/$OBJECT"`
6. Resource server sends protecteed resources to the app.

The **authorization token** and **access token** ***are both JSON Web Tokens (JWTs)***. JWTs are a type of token that can be used to securely transmit information between two parties. ***The authorization token contains information about the user and the third-party application***. The ***access token contains information about the user and the resource server***.

The OAuth 2 authorization flow is a secure way for third-party applications to access user accounts. The authorization token and access token are both encrypted, so they cannot be easily intercepted or modified. The OAuth 2 authorization flow is also flexible, so it can be used with a variety of different applications and resource servers.

</details>

<details>
  <summary><h5>OAuth 2 vs OPen ID Connect</h5></summary>

***OAuth 2 is a delegated authorization framework***, while ***OpenID Connect is a federated authentication framework***.

- In **OAuth 2**, the user (resource owner) ***delegates authorization to a client*** (app) to access their resources. The client requests an authorization token from the authorization server, which is then used to request an access token from the resource server. The access token is then used to access the user's resources on the resource server. For example, you might ***allow a weather app to access your email account so that it can send you weather alerts***. 

- In **OpenID Connect**, the user (resource owner) ***authenticates with an identity provider (IdP)***. The IdP issues an ID token, which contains information about the user, to the client. ***The client can then use the ID token to authenticate the user with other applications***. For example, you might use OpenID Connect to authenticate with a bank's website. ***The bank's website would request your ID token from your identity provider, such as Google or Facebook***. The ID token would contain information about you, such as your name, email address, and date of birth. The bank's website would use this information to authenticate you.

***A hotel key card is like an OAuth 2 access token***. It allows you to access a specific resource, such as your hotel room. ***A passport is like an OpenID Connect ID token***. It contains information about you, such as your name, email address, and date of birth. It can be used to authenticate you with other applications, such as airlines or banks.

***OpenID Connect flow is just like Oauth2 flow but it send ID token (and may be some additional info) along with Access Token of Oauth2***. The ***ID token contains information about the user, such as their name, email address, and profile picture***. This information can be used by other applications to authenticate the user.

![openID](/img/interviews/design-system/openID.png)

Here is a table that summarizes the differences between OAuth 2 and OpenID Connect:

| Feature | OAuth 2 | OpenID Connect |
|---|---|---|
| Purpose | Delegated authorization (***User accepts the app accesses his resources to do something for him***) | Federated authentication (***user accepts the app use his info/resource to do something for the app***) |
| Token | Access token | ID token |
| Information contained in token | Permissions to access resources | Information about the user |
| Use cases | API access, social login | Single sign-on |

</details>

<details>
  <summary><h5>OpenID Connect vs openID</h5></summary>

OpenID Connect (OIDC) and OpenID are both identity protocols that use the OAuth 2.0 authorization framework. However, there are some key differences between the two protocols.

**OpenID** is a broader identity framework that defines how users can be authenticated and authorized to access resources. It does not specify how the authentication and authorization are performed, but it does define the information that must be exchanged between the user, the identity provider (IdP), and the resource server.

**OpenID Connect** is a specific implementation of OpenID that uses JSON Web Tokens (JWTs) to exchange information. OIDC also adds a number of features that are not part of OpenID, such as support for user profiles and single sign-on.

Here is a table that summarizes the differences between OpenID and OpenID Connect:

| Feature | OpenID | OpenID Connect |
|---|---|---|
| Purpose | Identity framework | Specific implementation of OpenID |
| Information exchanged | User identity information | User identity information, plus JWTs |
| Use cases | Single sign-on, API access | Single sign-on, API access, user profiles |

**Here are some of the benefits of using OpenID Connect:**

* **Simple:** OpenID Connect is a simple and easy-to-implement protocol.
* **Secure:** OpenID Connect uses JWTs, which are a secure way to exchange information.
* **Standardized:** OpenID Connect is a standardized protocol, so it can be used with a variety of different applications and identity providers.
* **Extendable:** OpenID Connect is extensible, so it can be customized to meet the specific needs of an application.

**Here are some of the drawbacks of using OpenID Connect:**

* **Not as widely adopted as OAuth 2:** OpenID Connect is not as widely adopted as OAuth 2, so there may be fewer identity providers that support it.
* **Can be complex to implement:** OpenID Connect can be complex to implement, especially if the application needs to support custom features.

Overall, OpenID Connect is a secure and standardized protocol that can be used for a variety of identity-related tasks. It is a good choice for applications that need to support single sign-on, API access, or user profiles.
</details>

### Microservices authentication and authorization

<details open>
  <summary><h5>Microservices authentication and authorization problems</h5></summary>

* **Handling authentication and authorization in each microservice can affect the flexibility of the microservice language/framework selection.** This is because each microservice would need to be able to support the authentication and authorization framework that is being used. This can make it difficult to choose a microservice language or framework, as you would need to make sure that it supports the authentication and authorization framework that you want to use.
* **Microservices should follow the principle of single responsibility.** This means that each microservice should only handle a single business logic. This can make it easier to implement authentication and authorization, as you can simply implement it in the microservice that handles the user management logic.
* **HTTP is a stateless protocol.** This means that the server does not store any state information about the client. This can make it difficult to implement authentication and authorization, as the server needs to be able to track the user's login status.
* **Using a session on the server side to save the user state can affect the horizontal expansion of the server.** This is because the server needs to store the session information for all of the active users. This can put a strain on the server's resources, especially if there are a large number of active users.

Here are some solutions to the problems of microservices authentication and authorization:

* **Use a centralized authentication and authorization server. (SSO - Single Sign-On)** This is a single server that handles all of the authentication and authorization for the microservices. This can make it easier to implement authentication and authorization, as you only need to implement it in one place. It can also make it more scalable, as the server can be scaled independently of the microservices.
* **Use a distributed authentication and authorization system.** This is a system that distributes the responsibility for authentication and authorization across multiple servers. This can make it more scalable and secure than a centralized authentication and authorization server.
* **Use OAuth 2 or OpenID Connect.** These are open standards that can be used to implement authentication and authorization in microservices. They are both secure and scalable, and they can be used with a variety of different microservices frameworks.
* **Gateway Auth** is a type of authentication that is implemented at the gateway layer of a microservices architecture. **BFF Authentication/Authorization** and **Client Token with API Gateway auth** are both examples of gateway auth.

The best solution for microservices authentication and authorization will depend on the specific needs of the application. However, the solutions listed above are all viable options.

</details>

<details>
  <summary><h5>Single sign-on (SSO) In Multiple Systems</h5></summary>

Single sign-on (SSO) is a security feature that allows users to ***log in once and then access multiple applications*** without having to log in again. This can make it easier for users to use microservices, as they do not need to remember multiple passwords.

#### SSO Implementation Problem

![none-SSO](/img/interviews/design-system/none-SSO.png)

You want users who are already logged-in at domain X to be already logged-in at domain Y. You want to share session information across different domains. However, for security reasons, browsers enforce a policy known as the ***same origin policy***. This policy dictates that cookies (and other locally stored data) can only be accessed by its creator (i.e. the domain that originally requested the data to be stored).


#### SSO Implementation Solution

- SSO can be implemented using a variety of different technologies. One common approach is to ***use an identity provider (IdP)*** (OpenID Connect). The IdP is responsible for authenticating users and issuing tokens that can be used to access the microservices. The microservices then use the tokens to verify the user's identity.

- Another approach to SSO is to use ***a centralized authentication and authorization server***. The server is responsible for authenticating users and issuing tokens. The microservices then use the tokens to verify the user's identity.

![SSO](/img/interviews/design-system/SSO.png)

Here is how SSO works in a typical flow:

1. The user visits a microservice that supports SSO.
2. The microservice redirects the user to the IdP/Auth Server.
3. The user logs in to the IdP/Auth Server.
4. The IdP/Auth Server authenticates the user and issues a token.
5. The microservice redirects the user back to the original microservice.
6. The microservice uses the token to verify the user's identity.
7. If the user is authenticated, the microservice grants access to the requested resources.

![SSO](/img/interviews/design-system/SSO2.png)

SSO can be a very effective way to implement authentication and authorization in microservices. It can make it easier for users to use the microservices, and it can also improve security.

Here are some of the benefits of using SSO:

* **Ease of use:** Users only need to log in once, which can make it easier for them to use the microservices.
* **Improved security:** SSO can improve security by reducing the number of passwords that users need to remember.
* **Scalability:** SSO can be scaled to accommodate a large number of users.

However, there are also some drawbacks to using SSO:

* **Complexity:** SSO can be complex to implement, especially if the microservices are using different authentication and authorization frameworks.
* **Single point of failure:** If the SSO server fails, all of the microservices that are using SSO will be unavailable.
* **Cost:** SSO can be expensive to implement and maintain.

Overall, SSO can be a very effective way to implement authentication and authorization in microservices. However, it is important to weigh the benefits and drawbacks before deciding whether or not to use it.
</details>

<details>
  <summary><h5>Distributed Session Management</h5></summary>

Distributed session management is the ***process of tracking a user's session across multiple microservices***. ***Instead of storing session in each service, seperate seesion to an independent layer***.

- There are a number of different ways to implement distributed session management. One common approach is to ***use a centralized session store***. This is a server that stores the session state for all of the microservices. When a user makes a request to a microservice, the microservice queries the centralized session store to get the user's session state.

  ![distributed-session](/img/interviews/design-system/distributed-session.png)

- Another approach to distributed session management is to ***use a distributed session token***. This is a token that is generated by the authentication server and is used to track the user's session across multiple microservices. When a user makes a request to a microservice, the microservice validates the session token and then gets the user's session state from the authentication server.

| Centralized session store | Distributed session token |
| ------------------------- | ------------------------- |
| Stores the session data on the server side, usually in a database or in memory | Stores the session data on the client side, usually in a cookie or a local storage |
| Requires a single entry point for all requests to the microservices, such as an API gateway, that performs authentication and authorization | Allows each microservice to perform authentication and authorization independently by validating the token |
| Simplifies the security logic for the microservices, but introduces a single point of failure and a potential performance bottleneck | Decouples the security logic from the business logic of the microservices, but requires additional network calls and token management |
| Uses a session identifier to link the requests to the session data | Uses a security token, such as JWT, to encode the session data |

Here is how distributed session management works in a typical flow:

1. The user logs in to the application.
2. The authentication server generates a session token and sends it to the user.
3. The user makes a request to a microservice.
4. The microservice validates the session token and gets the user's session state from the authentication server.
5. The microservice uses the session state to process the user's request.

The best approach to distributed session management will depend on the specific needs of the application. However, both centralized session stores and distributed session tokens can be effective ways to track user sessions across multiple microservices.

</details>

<details>
  <summary><h5>BFF Authentication/Authorization</h5></summary>

**BFF Authentication/Authorization** architecture is a way to handle authentication and authorization in a microservices architecture. It uses a **Backend for Frontend (BFF)** (**Edge services** that implementing security and access control for ***different types of client***s, such as web, mobile, or desktop applications) to act as an intermediary between the frontend application and the microservices. The BFF is ***responsible for validating the user's credentials, determining their permissions, and then forwarding the requests to the appropriate microservices***.

![BFF-Auth1](/img/interviews/design-system/BFF-Auth1.png)

There are two main ways to implement BFF authorization architecture:

* **Token-based authentication:** The frontend application generates a token that is then sent to the BFF. The ***BFF validates the token*** and then forwards the request to the appropriate microservice.
* **Service-to-service authentication:** The BFF ***authenticates with each microservice individually***. This is more secure than token-based authentication, but it can also be more complex to implement.

The BFF Token-based authentication architecture works as follows:

![BFF-Auth2](/img/interviews/design-system/BFF-Auth2.png)

- The client sends a request to the BFF service with some credentials, such as username and password.
- The BFF service validates the credentials using an identity provider that supports OAuth 2.0 and OpenID Connect protocols, such as Auth0.
- The identity provider returns an access token and an ID token to the BFF service. The access token contains scopes and roles that grant permissions to access resources. The ID token contains claims about the identity of the user or the service.
- The BFF service stores the tokens in a session store or a cookie and sends them back to the client.
- The client sends subsequent requests to the BFF service with the tokens attached.
- The BFF service verifies the tokens using an Auth0 SDK or an API Gateway middleware.
- The BFF service forwards the requests to the backend APIs or external services using the tokens.
- The backend APIs or external services validate the tokens and return the data to the BFF service.
- The BFF service formats and aggregates the data based on the client's representation.
- The BFF service sends the formatted data back to the client.

Here are some of the benefits of using BFF authorization architecture in microservices:

* **Simplicity:** The frontend application does not need to worry about authentication and authorization. This can simplify the code and make it easier to maintain.
* **Security:** BFF authorization architecture can help to improve security by centralizing the authentication and authorization logic. This makes it easier to manage and audit security.
* **Scalability:** BFF authorization architecture can be scaled easily as the number of microservices increases.

Here are some of the challenges of using BFF authorization architecture in microservices:

* **Complexity:** BFF authorization architecture can be complex to implement. This is especially true if the microservices use different authentication and authorization schemes.
* **Performance:** BFF authorization architecture can add some latency to the request-response cycle. This is because the BFF needs to validate the user's credentials and determine their permissions before forwarding the request to the microservice.

Overall, BFF authorization architecture can be a very effective way to handle authentication and authorization in a microservices architecture. It can help to simplify the code in the frontend application, improve security, and scale easily. However, it is important to be aware of the challenges of implementing BFF authorization architecture before deciding to use it.

----

</details>

<details>
  <summary><h5>Client Token with API Gateway Auth</h5></summary>

Client Token with API Gateway auth works by using a client token to authenticate requests to an API Gateway. The client token is a short-lived token that is generated by the API Gateway and sent to the client. The client then uses the client token to authenticate requests to the API Gateway.

Here is how Client Token with API Gateway auth works in a typical flow:

1. The client makes a request to the API Gateway.
2. The API Gateway validates the client token.
3. If the client token is valid, the API Gateway allows the request to proceed.
4. The API Gateway calls the backend service.
5. The backend service returns a response to the API Gateway.
6. The API Gateway returns the response to the client.

![GatewayAuth](/img/interviews/design-system/GatewayAuth.png)

API gateway ***translates the original user token (JWT token) into an opaque token*** that only itself can resolve
- **An opaque token (also called a stateful token)** is a type of token that does not contain any information in it, usually a random string, and requires an intermediate service to check and retrieve the information.
- **A transparent token (also called a stateless token) or JWT** is a type of token that contains the information in itself, usually encoded as a JSON object, and does not require an intermediate service to verify or decode it.

Here are some of the benefits of using Client Token with API Gateway auth:

* **Security:** Client Token with API Gateway auth is a secure way to authenticate requests to an API Gateway. The client token is a short-lived token that expires after a certain amount of time, which helps to protect the security of the token.
* **Scalability:** Client Token with API Gateway auth is a scalable way to authenticate requests to an API Gateway. The client token can be used to authenticate requests from a large number of users.
* **Ease of use:** Client Token with API Gateway auth is easy to use. The client token can be generated and used by the client without the need for any special software.

Here are some of the drawbacks of using Client Token with API Gateway auth:

* **Complexity:** Client Token with API Gateway auth can be complex to implement. The client token needs to be generated and used by the client, and the API Gateway needs to be configured to use the client token.
* **Cost:** Client Token with API Gateway auth can be more expensive than other methods of authentication. The client token needs to be stored and managed, and the API Gateway needs to be configured to use the client token.

Overall, Client Token with API Gateway auth is a secure and efficient way to authenticate requests to an API Gateway. It is a good choice for applications that need to be secure and that need to be able to scale to a large number of users.

</details>

### Authorization Policies Models

<details open>
  <summary><h5>Authorization Policies Models</h5></summary>

* **An access control list (ACL)** This model uses a list of users or groups and a yes/no flag to indicate whether they can access a specific resource or not. For example, an ACL might ***allow the user "johndoe" to read and write*** the file "myfile.txt". Another ACL might allow the group "managers" to execute the program "myprogram.exe".

  ![ACL](/img/interviews/design-system/ACL.png)

  For example, an ACL for a file may look like this.
  ```
  Alice: read, write
  Bob: read
  Charlie: no access
  ```
* **Role-based access control (RBAC):** RBAC is a model that assigns permissions to users based on their roles. For example, a user with the ***role of "admin"*** may have permission to access all resources, while a user with the role of "user" may only have permission to access certain resources.

  ![RBAC](/img/interviews/design-system/RBAC.png)

  For example, an RBAC for a web application may look like this:

  ```
  role admin:
    permission create_user
    permission update_user
    permission delete_user

  role user:
    permission view_profile
    permission edit_profile

  user Alice:
    role admin

  user Bob:
    role user

  ```
* **Attribute-based access control (ABAC):** ABAC is a model that assigns permissions to users based on their attributes. For example, a user who is a ***member of a certain group*** may have permission to access certain resources.

  For example, an ABAC for a document management system may look like this:

  ```
  policy allow_access:
    if user.department == document.owner AND time.hour >= 9 AND time.hour <= 17 then permit read else deny

  user Alice:
    attribute department = "Sales"

  document A:
    attribute owner = "Sales"

  document B:
    attribute owner = "Marketing"

  ```
* **Policy-based access control (PBAC):** This model ***assigns permissions directly to users or groups***, without using roles. Each permission defines a specific resource or action that can be accessed or performed. For example, a user may have the permission to read a file, but not to write or delete it.

  For example

  ```xml
  <Rule RuleId="exampleRule" Effect="Permit">
    <Target>
      <Subject>
        <SubjectMatch MatchId="subjectMatchId">
          <AttributeValue>Alice</AttributeValue>
        </SubjectMatch>
      </Subject>
      <Resource>
        <ResourceMatch MatchId="resourceMatchId">
          <AttributeValue>/myresource</AttributeValue>
        </ResourceMatch>
      </Resource>
    </Target>
    <Condition>
      <Apply FunctionId="urn:oasis:names:tc:xacml:1.0:function:string-equal">
        <Apply FunctionId="urn:oasis:names:tc:xacml:1.0:function:current-time">
        </Apply>
        <AttributeValue>9am-5pm</AttributeValue>
      </Apply>
    </Condition>
  </Rule>
  ```

  In this example, the rule grants Alice permission to access the resource /myresource if the current time is between 9am and 5pm. The rule uses the XACML function string-equal to compare the current time to the string 9am-5pm. If the comparison is true, then the rule grants permission to access the resource.
  
* **Context-based access control (CBAC):** CBAC is a model that assigns permissions to users based on the context of the request. For example, a user may have permission to access a resource ***only from a certain location or only at a certain time***.

  Here is an example of CBAC:
  ```
  Context:
    - Location: office
    - Time: 9am-5pm

  Permissions:
    - Alice: read, write
    - Bob: read
    - Charlie: no access

  ```

These are just a few of the most common authorization policies models. The best model for your application will depend on your specific needs.

Here is a table that summarizes the main features and differences of ACL, RBAC, ABAC, PBAC, and CBAC:

| Model | Definition | Advantages | Disadvantages |
| ----- | ---------- | ---------- | ------------- |
| ACL | Access Control List. Uses a list of users or groups and a yes/no flag to indicate whether they can access a specific resource or not. | Simple and easy to implement. | Not scalable or flexible. Hard to manage and audit. |
| RBAC | Role-Based Access Control. Assigns roles to users based on their responsibilities and privileges. Each role has a set of permissions that grant access to certain resources or actions. | More scalable and flexible than ACL. Reduces administrative overhead and improves security. | Not fine-grained or dynamic enough for complex scenarios. Requires role engineering and maintenance. |
| ABAC | Attribute-Based Access Control. Uses attributes of the user, the resource, the environment, and the action to define policies that grant or deny access. Each policy is a logical expression that evaluates to true or false based on the attribute values. | More fine-grained and dynamic than RBAC. Supports complex and changing scenarios. Improves auditability and compliance. | More complex and costly to implement and manage than RBAC. Requires policy engineering and maintenance. |
| PBAC | Policy-Based Access Control. Similar to ABAC, but does not use any XML standards to inform the policies. Allows more flexibility and customization in defining the policies and the attributes. | More flexible and customizable than ABAC. Supports diverse and evolving scenarios. | More difficult and time-consuming to implement and manage than ABAC. Requires policy engineering and maintenance. |
| CBAC | Context-Based Access Control. A Microsoft-specific form of access control that uses context information to determine access. It uses predefined context attributes such as device health, network location, or user risk score. | More adaptive and responsive than ABAC or PBAC. Supports Microsoft-specific scenarios. | Less flexible and customizable than ABAC or PBAC. Requires Microsoft-specific technologies and frameworks.

</details>