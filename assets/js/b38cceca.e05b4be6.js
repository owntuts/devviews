"use strict";(self.webpackChunkinterviewdev=self.webpackChunkinterviewdev||[]).push([[8171,5982,5723,7003,5861,5143],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},s=Object.keys(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},v=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=c(n),v=a,m=p["".concat(l,".").concat(v)]||p[v]||u[v]||s;return n?i.createElement(m,r(r({ref:t},d),{},{components:n})):i.createElement(m,r({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,r=new Array(s);r[0]=v;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[p]="string"==typeof e?e:a,r[1]=o;for(var c=2;c<s;c++)r[c]=n[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}v.displayName="MDXCreateElement"},4312:function(e,t,n){n.d(t,{ZP:function(){return o}});var i=n(3117),a=(n(7294),n(3905));const s={toc:[]},r="wrapper";function o(e){let{components:t,...n}=e;return(0,a.kt)(r,(0,i.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("div",{className:"interview"},n.level&&(0,a.kt)("span",{className:"level"},n.level),n.children))}o.isMDXComponent=!0},2885:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return r},default:function(){return u},frontMatter:function(){return s},metadata:function(){return o},toc:function(){return c}});var i=n(3117),a=(n(7294),n(3905));const s={sidebar_position:1e3,sidebar_label:"AsyncStorage",title:"AsyncStorage",slug:"/asynstorage",tags:["Basic React Native Interviews"]},r=void 0,o={unversionedId:"react-native/basic/asynstorage",id:"react-native/basic/asynstorage",title:"AsyncStorage",description:"\\*\u0ca0_\u0ca0\\* :",source:"@site/docs/react-native/basic/asynstorage.md",sourceDirName:"react-native/basic",slug:"/asynstorage",permalink:"/devviews/interviews/asynstorage",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/react-native/basic/asynstorage.md",tags:[{label:"Basic React Native Interviews",permalink:"/devviews/interviews/tags/basic-react-native-interviews"}],version:"current",sidebarPosition:1e3,frontMatter:{sidebar_position:1e3,sidebar_label:"AsyncStorage",title:"AsyncStorage",slug:"/asynstorage",tags:["Basic React Native Interviews"]},sidebar:"reactnativeInterviewSidebar",next:{title:"Boxing vs Unboxing",permalink:"/devviews/interviews/reactnative-flatlist-vs-listview"}},l={},c=[],d={toc:c},p="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("admonition",{title:"Question:",type:"quest"},(0,a.kt)("p",{parentName:"admonition"},"*",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"\u0ca0_\u0ca0")),"*"," :\nAsync Storage in React Native? dos and donts?")),(0,a.kt)("details",null,(0,a.kt)("summary",null,(0,a.kt)("h5",null,"ANSWER:")),(0,a.kt)("p",null,"  ","*",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"\u25d4\u032f\u25d4")),"*"," :\nAsync Storage is a local storage solution that is available in React Native. It allows you to save key-value pairs in local storage on the user's device, persisting even if the app is closed or the device is restarted. Here are some dos and don'ts when using Async Storage in React Native:"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Dos"),":"),(0,a.kt)("p",null,"Use it for small, simple data: Async Storage is optimized for small amounts of simple data, such as user preferences or authorization tokens."),(0,a.kt)("p",null,"Use it to cache data that is expensive to retrieve: If you have data that is expensive to retrieve from a server or database, you can store it in Async Storage to avoid unnecessary requests and improve app performance."),(0,a.kt)("p",null,"Use it in combination with other storage solutions: Async Storage is just one option for local storage in React Native. You can also use other storage solutions, such as SQLite or Realm, depending on your data needs."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Don'ts"),":"),(0,a.kt)("p",null,"Don't use it for large or complex data: Async Storage is not optimized for large or complex data, such as images or videos. Consider storing these types of data in a cloud storage service or on the device's file system."),(0,a.kt)("p",null,"Don't store sensitive data: Async Storage is not secure and should not be used to store sensitive data, such as passwords or credit card information. Use other security measures, such as the Keychain API or encryption, to secure sensitive information."),(0,a.kt)("p",null,"Don't use it as the sole storage solution: Async Storage should only be used for local storage on the user's device. It should not be used as the sole storage solution for your app, as the data can be cleared by the user or when the device runs out of storage space.")))}u.isMDXComponent=!0},1867:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return r},default:function(){return u},frontMatter:function(){return s},metadata:function(){return o},toc:function(){return c}});var i=n(3117),a=(n(7294),n(3905));const s={sidebar_position:1e3,sidebar_label:"Boxing vs Unboxing",title:"Differences Between Boxing vs Unboxing In C# (C-Sharp)",slug:"/reactnative-flatlist-vs-listview",tags:["Basic React Native Interviews"]},r=void 0,o={unversionedId:"react-native/basic/flatlist-vs-listview",id:"react-native/basic/flatlist-vs-listview",title:"Differences Between Boxing vs Unboxing In C# (C-Sharp)",description:"\\*\u0ca0_\u0ca0\\* :",source:"@site/docs/react-native/basic/flatlist-vs-listview.md",sourceDirName:"react-native/basic",slug:"/reactnative-flatlist-vs-listview",permalink:"/devviews/interviews/reactnative-flatlist-vs-listview",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/react-native/basic/flatlist-vs-listview.md",tags:[{label:"Basic React Native Interviews",permalink:"/devviews/interviews/tags/basic-react-native-interviews"}],version:"current",sidebarPosition:1e3,frontMatter:{sidebar_position:1e3,sidebar_label:"Boxing vs Unboxing",title:"Differences Between Boxing vs Unboxing In C# (C-Sharp)",slug:"/reactnative-flatlist-vs-listview",tags:["Basic React Native Interviews"]},sidebar:"reactnativeInterviewSidebar",previous:{title:"AsyncStorage",permalink:"/devviews/interviews/asynstorage"},next:{title:"Boxing vs Unboxing",permalink:"/devviews/interviews/reactnative-flatlist-vs-sessionlist"}},l={},c=[],d={toc:c},p="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("admonition",{title:"Question:",type:"quest"},(0,a.kt)("p",{parentName:"admonition"},"*",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"\u0ca0_\u0ca0")),"*"," :\nFlatlist vs ListView in react native?")),(0,a.kt)("details",null,(0,a.kt)("summary",null,(0,a.kt)("h5",null,"ANSWER:")),(0,a.kt)("p",null,"  ","*",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"\u25d4\u032f\u25d4")),"*"," :\n",(0,a.kt)("inlineCode",{parentName:"p"},"FlatList")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"ListView")," are both components in React Native that allow you to render a scrollable list of items. While they serve the same purpose, they have some key differences in terms of performance and features.\nHere are some differences between ",(0,a.kt)("inlineCode",{parentName:"p"},"FlatList")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"ListView"),":"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Performance"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"FlatList")," provides better performance than ",(0,a.kt)("inlineCode",{parentName:"p"},"ListView"),". ",(0,a.kt)("inlineCode",{parentName:"p"},"ListView")," keeps all items in the memory, while ",(0,a.kt)("inlineCode",{parentName:"p"},"FlatList")," only renders the visible items, thus reducing the memory usage and improving the performance of the app. ",(0,a.kt)("inlineCode",{parentName:"p"},"FlatList")," also uses a virtualized list which optimizes the rendering process by rendering only a subset of the items in the list based on the position of the user on the screen."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Data management"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"FlatList")," has better data management and item rendering capabilities than ",(0,a.kt)("inlineCode",{parentName:"p"},"ListView"),". ",(0,a.kt)("inlineCode",{parentName:"p"},"FlatList")," allows you to easily manage data by using the ",(0,a.kt)("inlineCode",{parentName:"p"},"data")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"renderItem")," props, while in ",(0,a.kt)("inlineCode",{parentName:"p"},"ListView")," you need to handle the data and item rendering manually."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Item layout"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"FlatList")," provides more flexibility and customization options for item layout. You can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"horizontal")," prop to render the items horizontally, and you can also use the ",(0,a.kt)("inlineCode",{parentName:"p"},"numColumns")," prop to render the items in multiple columns."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Scroll position"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"FlatList")," provides better control over the scroll position than ",(0,a.kt)("inlineCode",{parentName:"p"},"ListView"),". You can programmatically scroll to a specific position in the list using the ",(0,a.kt)("inlineCode",{parentName:"p"},"scrollToIndex")," method or the ",(0,a.kt)("inlineCode",{parentName:"p"},"scrollToOffset")," method."),(0,a.kt)("p",null,"In summary, while both ",(0,a.kt)("inlineCode",{parentName:"p"},"FlatList")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"ListView")," provide the same basic functionality of rendering a scrollable list, ",(0,a.kt)("inlineCode",{parentName:"p"},"FlatList")," provides better performance and more advanced features for data management, item rendering, and scroll position control."),(0,a.kt)("p",null,":::note Note:"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"ListView")," is deprecated now"),(0,a.kt)("p",null,":::")))}u.isMDXComponent=!0},7745:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return r},default:function(){return u},frontMatter:function(){return s},metadata:function(){return o},toc:function(){return c}});var i=n(3117),a=(n(7294),n(3905));const s={sidebar_position:1e3,sidebar_label:"Boxing vs Unboxing",title:"Differences Between Boxing vs Unboxing In C# (C-Sharp)",slug:"/reactnative-flatlist-vs-sessionlist",tags:["Basic React Native Interviews"]},r=void 0,o={unversionedId:"react-native/basic/flatlist-vs-sessionlist",id:"react-native/basic/flatlist-vs-sessionlist",title:"Differences Between Boxing vs Unboxing In C# (C-Sharp)",description:"\\*\u0ca0_\u0ca0\\* :",source:"@site/docs/react-native/basic/flatlist-vs-sessionlist.md",sourceDirName:"react-native/basic",slug:"/reactnative-flatlist-vs-sessionlist",permalink:"/devviews/interviews/reactnative-flatlist-vs-sessionlist",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/react-native/basic/flatlist-vs-sessionlist.md",tags:[{label:"Basic React Native Interviews",permalink:"/devviews/interviews/tags/basic-react-native-interviews"}],version:"current",sidebarPosition:1e3,frontMatter:{sidebar_position:1e3,sidebar_label:"Boxing vs Unboxing",title:"Differences Between Boxing vs Unboxing In C# (C-Sharp)",slug:"/reactnative-flatlist-vs-sessionlist",tags:["Basic React Native Interviews"]},sidebar:"reactnativeInterviewSidebar",previous:{title:"Boxing vs Unboxing",permalink:"/devviews/interviews/reactnative-flatlist-vs-listview"},next:{title:"Boxing vs Unboxing",permalink:"/devviews/interviews/sessionlist-with-large-dataset"}},l={},c=[],d={toc:c},p="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("admonition",{title:"Question:",type:"quest"},(0,a.kt)("p",{parentName:"admonition"},"*",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"\u0ca0_\u0ca0")),"*"," :\nFlatList vs SessionList in react native?")),(0,a.kt)("details",null,(0,a.kt)("summary",null,(0,a.kt)("h5",null,"ANSWER:")),(0,a.kt)("p",null,"  ","*",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"\u25d4\u032f\u25d4")),"*"," :\nIn React Native, there are two main types of components that are commonly used to support list rendering:"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"FlatList"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"FlatList")," is a high-performance component that is suitable for rendering large lists of data. It provides a lot of flexibility and customization options, such as support for scroll events, item separators, and more. In addition, it uses a virtualized list to optimize performance by rendering only the visible items on the screen."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"SectionList"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"SectionList")," is similar to ",(0,a.kt)("inlineCode",{parentName:"p"},"FlatList"),", but provides support for rendering data in nested sections. It allows you to group your data into sections and render each section as a separate list, with the ability to specify a header and/or footer for each section."),(0,a.kt)("p",null,"Both ",(0,a.kt)("inlineCode",{parentName:"p"},"FlatList")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"SectionList")," can be used to render dynamic lists of data with high performance. However, ",(0,a.kt)("inlineCode",{parentName:"p"},"FlatList")," is more suitable for rendering large, flat lists without nested sections, while ",(0,a.kt)("inlineCode",{parentName:"p"},"SectionList")," is best for rendering nested data with sections, such as products by category or messages by date.")))}u.isMDXComponent=!0},7620:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return r},default:function(){return u},frontMatter:function(){return s},metadata:function(){return o},toc:function(){return c}});var i=n(3117),a=(n(7294),n(3905));const s={sidebar_position:1e3,sidebar_label:"Boxing vs Unboxing",title:"Differences Between Boxing vs Unboxing In C# (C-Sharp)",slug:"/sessionlist-with-large-dataset",tags:["Basic React Native Interviews"]},r=void 0,o={unversionedId:"react-native/basic/sessionlist-with-large-dataset",id:"react-native/basic/sessionlist-with-large-dataset",title:"Differences Between Boxing vs Unboxing In C# (C-Sharp)",description:"\\*\u0ca0_\u0ca0\\* :",source:"@site/docs/react-native/basic/sessionlist-with-large-dataset.md",sourceDirName:"react-native/basic",slug:"/sessionlist-with-large-dataset",permalink:"/devviews/interviews/sessionlist-with-large-dataset",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/react-native/basic/sessionlist-with-large-dataset.md",tags:[{label:"Basic React Native Interviews",permalink:"/devviews/interviews/tags/basic-react-native-interviews"}],version:"current",sidebarPosition:1e3,frontMatter:{sidebar_position:1e3,sidebar_label:"Boxing vs Unboxing",title:"Differences Between Boxing vs Unboxing In C# (C-Sharp)",slug:"/sessionlist-with-large-dataset",tags:["Basic React Native Interviews"]},sidebar:"reactnativeInterviewSidebar",previous:{title:"Boxing vs Unboxing",permalink:"/devviews/interviews/reactnative-flatlist-vs-sessionlist"},next:{title:"Store Secure Data",permalink:"/devviews/interviews/store-secure-data"}},l={},c=[],d={toc:c},p="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("admonition",{title:"Question:",type:"quest"},(0,a.kt)("p",{parentName:"admonition"},"*",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"\u0ca0_\u0ca0")),"*"," :\nI have a large data, I want to group the data into sections and render each section as a separate list but would like to use a virtualized list to optimize performance. How to do that?")),(0,a.kt)("details",null,(0,a.kt)("summary",null,(0,a.kt)("h5",null,"ANSWER:")),(0,a.kt)("p",null,"  ","*",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"\u25d4\u032f\u25d4")),"*"," :\nYou can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"SectionList")," component in React Native to group your data into sections and render each section as a separate list. To optimize performance, you can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"getItemLayout")," prop of ",(0,a.kt)("inlineCode",{parentName:"p"},"SectionList")," to provide estimated dimensions for each item, and the ",(0,a.kt)("inlineCode",{parentName:"p"},"windowSize")," prop to configure the number of items to render outside of the visible area."),(0,a.kt)("p",null,"Here's an example of how to use ",(0,a.kt)("inlineCode",{parentName:"p"},"SectionList")," with virtualization:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import React from 'react';\nimport { View, Text, SectionList } from 'react-native';\n\nconst data = [\n  { title: 'Section 1', data: ['Item 1-1', 'Item 1-2', 'Item 1-3'] },\n  { title: 'Section 2', data: ['Item 2-1', 'Item 2-2', 'Item 2-3'] },\n  { title: 'Section 3', data: ['Item 3-1', 'Item 3-2', 'Item 3-3'] },\n  // more sections and items...\n];\n\nconst Item = ({ title }) => {\n  return (\n    <View style={{ padding: 16 }}>\n      <Text>{title}</Text>\n    </View>\n  );\n};\n\nconst SectionHeader = ({ title }) => {\n  return (\n    <View style={{ backgroundColor: '#f4f4f4', padding: 8 }}>\n      <Text>{title}</Text>\n    </View>\n  );\n};\n\nconst App = () => {\n  const getItemLayout = (data, index) => ({\n    length: 50, // estimated item height\n    offset: 50 * index,\n    index,\n  });\n\n  return (\n    <SectionList\n      sections={data}\n      keyExtractor={(item, index) => item + index}\n      renderItem={({ item }) => <Item title={item} />}\n      renderSectionHeader={({ section: { title } }) => <SectionHeader title={title} />}\n      getItemLayout={getItemLayout}\n      initialNumToRender={20} // number of items to render initially\n      windowSize={30} // number of items to keep outside of the visible area\n    />\n  );\n};\n\nexport default App;\n"))))}u.isMDXComponent=!0},3035:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return r},default:function(){return u},frontMatter:function(){return s},metadata:function(){return o},toc:function(){return c}});var i=n(3117),a=(n(7294),n(3905));const s={sidebar_position:1e3,sidebar_label:"Store Secure Data",title:"Store Secure Data",slug:"/store-secure-data",tags:["Basic React Native Interviews"]},r=void 0,o={unversionedId:"react-native/basic/store-secure-data",id:"react-native/basic/store-secure-data",title:"Store Secure Data",description:"\\*\u0ca0_\u0ca0\\* :",source:"@site/docs/react-native/basic/store-secure-data.md",sourceDirName:"react-native/basic",slug:"/store-secure-data",permalink:"/devviews/interviews/store-secure-data",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/react-native/basic/store-secure-data.md",tags:[{label:"Basic React Native Interviews",permalink:"/devviews/interviews/tags/basic-react-native-interviews"}],version:"current",sidebarPosition:1e3,frontMatter:{sidebar_position:1e3,sidebar_label:"Store Secure Data",title:"Store Secure Data",slug:"/store-secure-data",tags:["Basic React Native Interviews"]},sidebar:"reactnativeInterviewSidebar",previous:{title:"Boxing vs Unboxing",permalink:"/devviews/interviews/sessionlist-with-large-dataset"},next:{title:"React Native Interviews",permalink:"/devviews/interviews/react-native/"}},l={},c=[],d={toc:c},p="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("admonition",{title:"Question:",type:"quest"},(0,a.kt)("p",{parentName:"admonition"},"*",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"\u0ca0_\u0ca0")),"*"," :\nWhat you should you to store sensitive data like Token storage, Secrets in React Native?")),(0,a.kt)("details",null,(0,a.kt)("summary",null,(0,a.kt)("h5",null,"ANSWER:")),(0,a.kt)("p",null,"  ","*",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"\u25d4\u032f\u25d4")),"*"," :\nWhen it comes to storing sensitive data like tokens, passwords or secrets in a React Native app, it is important to prioritize security and choose a secure storage solution. Here are some options:"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Keychain API"),": The Keychain API is a secure password management system provided by Apple for iOS devices. It allows you to securely store and retrieve sensitive information, such as passwords, access tokens, and encryption keys."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Secure Store"),": Secure Store is a built-in module in Expo that provides a simple interface to encrypt and securely store sensitive data in key-value pairs on the device."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Realm Database"),": Realm Database is a mobile database solution that provides built-in encryption and data-at-rest protection. It allows for secure storage of sensitive data with fine-grained access control and data isolation."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"SQLite Database"),": SQLite is another database solution that is commonly used for storing data in local storage. It includes built-in encryption and allows for secure storage of sensitive data."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Encryption Libraries"),": There are various encryption libraries available for React Native, such as crypto-js and react-native-crypto. These libraries can be used to encrypt and decrypt sensitive data before storing it in local storage."),(0,a.kt)("p",null,"It is important to choose a storage solution that meets your specific security needs and the requirements of your app. You should also implement additional security measures such as using secure communication protocols (HTTPS), hashing and salting passwords, and limiting access to sensitive data to authorized users.")))}u.isMDXComponent=!0},541:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return u},default:function(){return b},frontMatter:function(){return p},metadata:function(){return v},toc:function(){return g}});var i=n(3117),a=(n(7294),n(3905)),s=n(4312),r=n(1867),o=n(7745),l=n(7620),c=n(2885),d=n(3035);const p={sidebar_position:3,id:"reactnative-interview-questions-answers",sidebar_label:"React Native Interviews",title:"React Native Interview Questions and Answers",tags:["React Native Interviews"]},u=void 0,v={unversionedId:"react-native/reactnative-interview-questions-answers",id:"react-native/reactnative-interview-questions-answers",title:"React Native Interview Questions and Answers",description:"Here, we discuss about React Native Interview Questions & Answers!",source:"@site/docs/react-native/react-native.md",sourceDirName:"react-native",slug:"/react-native/",permalink:"/devviews/interviews/react-native/",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/react-native/react-native.md",tags:[{label:"React Native Interviews",permalink:"/devviews/interviews/tags/react-native-interviews"}],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,id:"reactnative-interview-questions-answers",sidebar_label:"React Native Interviews",title:"React Native Interview Questions and Answers",tags:["React Native Interviews"]},sidebar:"reactnativeInterviewSidebar",previous:{title:"Store Secure Data",permalink:"/devviews/interviews/store-secure-data"},next:{title:"intro",permalink:"/devviews/interviews/react-native/intro"}},m={},g=[{value:"Coding",id:"coding",level:2}],f={toc:g},w="wrapper";function b(e){let{components:t,...n}=e;return(0,a.kt)(w,(0,i.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Here, we discuss about React Native Interview Questions & Answers!"),(0,a.kt)("h2",{id:""}),(0,a.kt)(s.ZP,{level:"Junior",mdxType:"Interview"},(0,a.kt)("h2",{id:"coding"},"Coding"),(0,a.kt)(r.default,{mdxType:"FlatListVsListView"}),(0,a.kt)(o.default,{mdxType:"FlatListVsSessionList"}),(0,a.kt)(l.default,{mdxType:"SesionWithLargeDataset"}),(0,a.kt)(c.default,{mdxType:"AsynStorage"}),(0,a.kt)(d.default,{mdxType:"StoreSecureData"})))}b.isMDXComponent=!0}}]);