"use strict";(self.webpackChunkinterviewdev=self.webpackChunkinterviewdev||[]).push([[3679],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),h=r,m=d["".concat(s,".").concat(h)]||d[h]||u[h]||o;return n?a.createElement(m,i(i({ref:t},p),{},{components:n})):a.createElement(m,i({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},70031:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return i},default:function(){return u},frontMatter:function(){return o},metadata:function(){return l},toc:function(){return c}});var a=n(83117),r=(n(67294),n(3905));const o={sidebar_position:1e3,sidebar_label:"Thread Safety In Java",title:"Thread Safety In Java",tags:["Java Knowledge"]},i=void 0,l={unversionedId:"java/hero/thread-safety",id:"java/hero/thread-safety",title:"Thread Safety In Java",description:"Thread Safety In Java",source:"@site/docs/java/hero/thread-safety.md",sourceDirName:"java/hero",slug:"/java/hero/thread-safety",permalink:"/devviews/interviews/java/hero/thread-safety",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/java/hero/thread-safety.md",tags:[{label:"Java Knowledge",permalink:"/devviews/interviews/tags/java-knowledge"}],version:"current",sidebarPosition:1e3,frontMatter:{sidebar_position:1e3,sidebar_label:"Thread Safety In Java",title:"Thread Safety In Java",tags:["Java Knowledge"]},sidebar:"javaInterviewSidebar",previous:{title:"Scopes In Java",permalink:"/devviews/interviews/java/hero/scope"},next:{title:"Java Type Conversion",permalink:"/devviews/interviews/java/hero/type-conversion"}},s={},c=[],p={toc:c},d="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Thread Safety In Java")),(0,r.kt)("p",null,"Thread safety is a programming methodology that ensures different threads can access the same resources without exposing erroneous behavior or producing unpredictable results."),(0,r.kt)("p",null,"Here are some techniques to ensure thread safety in Java:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Synchronization"),": Synchronization ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"allows only one thread to access"))," the synchronized block or method at a time, thus preventing race conditions.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Volatile keyword"),": Volatile keyword is used to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"prevent the caching of shared variables"))," by different threads.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Atomic operations"),": Atomic operations are thread-safe and ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"guarantee consistency of shared data")),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Locks"),": Lock objects are used to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"protect shared resources from being accessed simultaneously"))," by multiple threads.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Immutable objects"),": Immutable objects ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"cannot be changed once created")),", so they are inherently thread-safe.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Thread-safe collections"),": Concurrent collections provided by Java's ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Concurrent"))," Collections Framework are thread-safe and can be used for shared resources."))),(0,r.kt)("p",null,"It is important to note that ensuring thread safety in Java code is not a one-size-fits-all solution, and the choice of technique will depend on the specific requirements of the application.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Synchronization (Common resources can only be acessed synchronously)")),(0,r.kt)("p",null,"Synchronization ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"ensures that only one thread can execute a block of code or a method at a time")),", and that any changes made by that thread are visible to other threads. This way, you can avoid race conditions and memory inconsistency errors that can lead to incorrect or unpredictable results."),(0,r.kt)("p",null,"For example, suppose you have a class that represents a bank account with a balance field and a deposit method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class BankAccount {\n    private int balance;\n\n    public BankAccount(int initialBalance) {\n        this.balance = initialBalance;\n    }\n\n    public int getBalance() {\n        return balance;\n    }\n\n    public void deposit(int amount) {\n        balance += amount;\n    }\n}\n")),(0,r.kt)("p",null,"If there're two threads try to deposit at the same time:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Thread 1: balance = 1000\nThread 2: balance = 1000\nThread 1: deposit(100)\nThread 2: deposit(200)\nThread 1: balance = 1000 + 100 = 1100\nThread 2: balance = 1000 + 200 = 1200\nFinal balance: 1200\n")),(0,r.kt)("p",null,"The expected final balance should be 1300, but because of the race condition, we lost 100. To avoid this problem, we can use synchronization to make the deposit method thread-safe:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class BankAccount {\n    private int balance;\n\n    public BankAccount(int initialBalance) {\n        this.balance = initialBalance;\n    }\n\n    public synchronized int getBalance() {\n        return balance;\n    }\n\n    public synchronized void deposit(int amount) {\n        balance += amount;\n    }\n}\n")),(0,r.kt)("p",null,"Now, only one thread can enter the deposit method at a time, and any changes made by that thread will be visible to other threads. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Thread 1: balance = 1000\nThread 2: tries to enter deposit, but blocked by Thread 1\nThread 1: deposit(100)\nThread 1: balance = 1000 + 100 = 1100\nThread 1: exits deposit\nThread 2: enters deposit\nThread 2: balance = 1100\nThread 2: deposit(200)\nThread 2: balance = 1100 + 200 = 1300\nThread 2: exits deposit\nFinal balance: 1300\n")),(0,r.kt)("p",null,"The final balance is correct and consistent. This is how synchronization can help achieve thread-safety in Java.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"volatile (Common resource is like one common state for all threads)")),(0,r.kt)("p",null,'The word "volatile" means something that can change quickly and unpredictably. In Java, the volatile keyword is used to indicate that a variable ',(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"can be changed by different threads at any time")),", and that the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"compiler should not cache its value"))," or reorder its operations. The volatile keyword ensures that ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"all threads see a consistent value for the variable")),"."),(0,r.kt)("p",null,"One example of using the volatile keyword is when you have a boolean flag that controls the execution of a thread, such as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public class VolatileExample extends Thread {\n    private volatile boolean running = true;\n\n    public void run() {\n        while (running) {\n            System.out.println("Running");\n        }\n        System.out.println("Stopped");\n    }\n\n    public void stopThread() {\n        running = false;\n    }\n}\n')),(0,r.kt)("p",null,"In this example, the running variable is declared as volatile, so that when the ",(0,r.kt)("inlineCode",{parentName:"p"},"stopThread()")," method is called by another thread, the change will be visible to the thread that is executing the ",(0,r.kt)("inlineCode",{parentName:"p"},"run()")," method. If the running variable was not volatile, there is a possibility that the thread would not see the updated value and continue running indefinitely.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Atomic (Common resources is single unit of work)")),(0,r.kt)("p",null,"Atomic operations are operations that are performed as a ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"single unit of work"))," without the possibility of interference from other operations. Atomic operations are useful in multithreaded environments where you want to avoid race conditions and ensure data integrity."),(0,r.kt)("p",null,"One example of using atomic operations in Java is to use the classes in the java.util.concurrent.atomic package, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"AtomicInteger"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"AtomicLong"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"AtomicBoolean"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"AtomicReference"),". These classes provide methods to atomically update their values, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"incrementAndGet()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"compareAndSet()"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"getAndSet()"),"."),(0,r.kt)("p",null,"For example, the following class uses an AtomicInteger to count the number of tasks completed by multiple threads:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class TaskCounter {\n    private AtomicInteger counter = new AtomicInteger();\n\n    public void increment() {\n        counter.incrementAndGet();\n    }\n\n    public int getCount() {\n        return counter.get();\n    }\n}\n")),(0,r.kt)("p",null,"In this example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"increment()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"getCount()")," methods are thread-safe and do not need synchronization, because they use atomic operations on the counter variable.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Locks (Common resources are locked to be proccessed untill unlock)")),(0,r.kt)("p",null,"Locks are thread synchronization mechanisms that ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"allow only one thread to access a shared resource"))," or a critical section at a time. Locks are useful in multithreaded environments where you want to avoid race conditions and ensure data consistency."),(0,r.kt)("p",null,"One example of using locks in Java is to use the Lock interface and its implementations, such as ReentrantLock, in the java.util.concurrent.locks package. These classes provide methods to acquire and release locks, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"lock()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"unlock()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"tryLock()"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"lockInterruptibly()"),"."),(0,r.kt)("p",null,"For example, the following class uses a ReentrantLock to manage access to a printer queue:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class PrinterQueue {\n    private final Lock queueLock = new ReentrantLock();\n\n    public void printJob(Object document) {\n        queueLock.lock();\n        try {\n            // print the document\n        } finally {\n            queueLock.unlock();\n        }\n    }\n}\n")),(0,r.kt)("p",null,"In this example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"printJob()")," method uses a queueLock to ensure that only one thread can print a document at a time. The ",(0,r.kt)("inlineCode",{parentName:"p"},"lock()")," method acquires the lock if it is available, or blocks the thread until it is released. The ",(0,r.kt)("inlineCode",{parentName:"p"},"unlock()")," method releases the lock so that other threads can acquire it. The try-finally block ensures that the lock is always released even if an exception occurs\xb2.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Immutable (Common resource is immutable)")),(0,r.kt)("p",null,"Immutable objects are objects whose internal state remains constant after they have been entirely created. Immutable objects are thread-safe because they ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"cannot be modified by multiple threads concurrently")),", and they do not require synchronization."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"class Person {\n    private final String name;\n    private final int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'Person person = new Person("Alice", 30);\n\nThread t1 = new Thread(() -> {\n    System.out.println(person.getName() + " is " + person.getAge() + " years old");\n});\n\nThread t2 = new Thread(() -> {\n    System.out.println(person.getName() + " is " + person.getAge() + " years old");\n});\n\nt1.start();\nt2.start();\n\nt1.join();\nt2.join();\n')),(0,r.kt)("p",null,"Both threads are trying to access the ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"age")," fields of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Person")," object. Since the fields are marked as ",(0,r.kt)("inlineCode",{parentName:"p"},"final"),", they cannot be modified once initialized, which means they are thread-safe. Even if both threads access the ",(0,r.kt)("inlineCode",{parentName:"p"},"Person")," object simultaneously, they will get the same value for ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"age"),", and the fields will not be overwritten."),(0,r.kt)("p",null,"In contrast, if we had not marked the ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"age")," fields as ",(0,r.kt)("inlineCode",{parentName:"p"},"final"),", there would be a risk of thread interference and memory consistency errors. Suppose one thread modifies the ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," field while the second thread is reading it. This can lead to unpredictable behavior and incorrect results."),(0,r.kt)("p",null,"To create a custom immutable class in Java, we need to follow some rules:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Declare the class as final so that it cannot be extended by other classes"),(0,r.kt)("li",{parentName:"ul"},"Declare all the fields as private and final so that they cannot be accessed or modified by other classes"),(0,r.kt)("li",{parentName:"ul"},"Provide only getters for the fields and no setters"),(0,r.kt)("li",{parentName:"ul"},"Initialize all the fields in the constructor and do not provide any methods that can change the state of the object"),(0,r.kt)("li",{parentName:"ul"},"If the class has any mutable fields, such as arrays or collections, do not expose them directly or return a copy of them")),(0,r.kt)("p",null,"For example, the following code shows how to create a custom immutable class called Money:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public final class Money {\n    private final double amount;\n    private final Currency currency;\n\n    public Money(double amount, Currency currency) {\n        this.amount = amount;\n        this.currency = currency;\n    }\n\n    public double getAmount() {\n        return amount;\n    }\n\n    public Currency getCurrency() {\n        return currency;\n    }\n}\n")),(0,r.kt)("p",null,"In this example, the Money class is immutable because it follows all the rules mentioned above. The amount and currency fields are private and final, and they are initialized in the constructor. The class only provides getters for the fields and no setters. The class does not have any mutable fields that need to be protected or copied.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Thread-safe collections")),(0,r.kt)("p",null,"Thread-safe collections are collections that can be safely accessed and modified by multiple threads concurrently without causing data inconsistency or corruption. Thread-safe collections ensure that their internal state and the values returned by their methods are correct even when they are invoked by different threads\xb9."),(0,r.kt)("p",null,"Some of the collection classes that are thread-safe in Java are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Stack"),": A thread-safe implementation of a last-in-first-out (LIFO) data structure that extends Vector."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Vector"),": A thread-safe implementation of a resizable array that implements the List interface. All of its methods are synchronized."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Properties"),": A thread-safe implementation of a persistent set of key-value pairs that extends Hashtable."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Hashtable"),": A thread-safe implementation of a hash table that implements the Map interface. All of its methods are synchronized.")),(0,r.kt)("p",null,"However, these thread-safe collections have some drawbacks, such as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"They have ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"poor performance because synchronization"))," requires locking and unlocking, which takes time and reduces concurrency."),(0,r.kt)("li",{parentName:"ul"},"They ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"do not prevent concurrent modification exceptions"))," when iterating over them using iterators or enumerations."),(0,r.kt)("li",{parentName:"ul"},"They ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"do not provide any advanced concurrency features")),", such as atomic operations, non-blocking algorithms, or concurrent data structures.")),(0,r.kt)("p",null,"To overcome these drawbacks, Java provides some alternatives for thread-safe collections, such as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Synchronized wrappers"),": These are static methods in the Collections class that return synchronized views of the given collections. For example, ",(0,r.kt)("inlineCode",{parentName:"li"},"Collections.synchronizedList()")," returns a thread-safe List backed by the specified List."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Concurrent collections"),": These are classes in the ",(0,r.kt)("inlineCode",{parentName:"li"},"java.util.concurrent")," package that provide high-performance and scalable thread-safe collections. For example, ",(0,r.kt)("inlineCode",{parentName:"li"},"CopyOnWriteArrayList"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"ConcurrentHashMap"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"ConcurrentLinkedQueue"),", etc."))))}u.isMDXComponent=!0}}]);