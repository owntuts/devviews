"use strict";(self.webpackChunkinterviewdev=self.webpackChunkinterviewdev||[]).push([[2931,5787,6446,6288,927,6695,1649,2143,5270,1414,9870,3679,6295],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(n),m=r,h=d["".concat(s,".").concat(m)]||d[m]||p[m]||i;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:r,o[1]=l;for(var u=2;u<i;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},54312:function(e,t,n){n.d(t,{ZP:function(){return l}});var a=n(83117),r=(n(67294),n(3905));const i={toc:[]},o="wrapper";function l(e){let{components:t,...n}=e;return(0,r.kt)(o,(0,a.Z)({},i,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("div",{className:"interview"},n.level&&(0,r.kt)("span",{className:"level"},n.level),n.children))}l.isMDXComponent=!0},20095:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return u}});var a=n(83117),r=(n(67294),n(3905));const i={},o=void 0,l={unversionedId:"java/hero/OOP",id:"java/hero/OOP",title:"OOP",description:"OOP",source:"@site/docs/java/hero/OOP.md",sourceDirName:"java/hero",slug:"/java/hero/OOP",permalink:"/devviews/interviews/java/hero/OOP",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/java/hero/OOP.md",tags:[],version:"current",frontMatter:{},sidebar:"javaInterviewSidebar",previous:{title:"Java Type Conversion",permalink:"/devviews/interviews/java/hero/type-conversion"},next:{title:"concurrency",permalink:"/devviews/interviews/java/hero/concurrency"}},s={},u=[],c={toc:u},d="wrapper";function p(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"OOP")),"OOP is a programming paradigm that uses objects to model real-world entities and behaviors",(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Objects")," are instances of classes, which define the state and behavior of the objects. OOP aims to achieve ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"abstraction")),", ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"encapsulation")),", ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"inheritance")),", and ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"polymorphism"))," in programming"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Abstraction")," is hiding the implementation details and showing only the essential features. Abstraction can be achieved by using ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"abstract classes"))," and ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"interfaces")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Encapsulation")," is wrapping the data and methods together and restricting access to them. Encapsulation can be achieved by using access modifiers, such as ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"public")),", ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"private")),", ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"protected")),", and ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"default")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Inheritance")," is acquiring the features and behaviors of an existing class by another class. Inheritance can be achieved by using the ",(0,r.kt)("inlineCode",{parentName:"li"},"extends")," keyword or the ",(0,r.kt)("inlineCode",{parentName:"li"},"implements")," keyword."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Polymorphism")," is the ability of an object to take different forms depending on the context. Polymorphism can be achieved by using method ",(0,r.kt)("inlineCode",{parentName:"li"},"overriding"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"overloading"),"."))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Interface vs Abstract Class")),(0,r.kt)("p",null,"An interface and an abstract class are both ways to achieve ",(0,r.kt)("strong",{parentName:"p"},"abstraction")," in Java, which means hiding the implementation details and showing only the essential features to the user. However, there are some differences between them, such as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"An interface can only declare ",(0,r.kt)("strong",{parentName:"li"},"abstract methods"),", which are methods that have no body and must be implemented by the classes that implement the interface. An abstract class can declare both ",(0,r.kt)("strong",{parentName:"li"},"abstract methods")," and ",(0,r.kt)("strong",{parentName:"li"},"non-abstract methods"),", which are methods that have a body and can be inherited or overridden by the subclasses that extend the abstract class. Since Java 8, an interface can also have ",(0,r.kt)("strong",{parentName:"li"},"default methods")," and ",(0,r.kt)("strong",{parentName:"li"},"static methods"),", which are methods that have a body and provide a default or utility implementation for the interface. Since Java 9, an interface can also have ",(0,r.kt)("strong",{parentName:"li"},"private methods"),", which are methods that are only accessible within the interface."),(0,r.kt)("li",{parentName:"ul"},"An interface can only declare ",(0,r.kt)("strong",{parentName:"li"},"constant variables"),", which are variables that are public, static, and final by default. An abstract class can declare any kind of variables, such as public, private, protected, default, static, final, non-final, etc."),(0,r.kt)("li",{parentName:"ul"},"A class can implement multiple interfaces, but it can extend only one abstract class. This is because an interface represents a set of behaviors, while an abstract class represents a type of object. A class can have multiple behaviors, but it can only belong to one type hierarchy."),(0,r.kt)("li",{parentName:"ul"},"An interface cannot have a constructor, because it cannot be instantiated. An abstract class can have a constructor, which will be invoked during the subclass object creation.")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Interface"),(0,r.kt)("th",{parentName:"tr",align:null},"Abstract Class"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Can only declare abstract methods (except default, static, and private methods since Java 8 and 9)"),(0,r.kt)("td",{parentName:"tr",align:null},"Can declare both abstract and non-abstract methods")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Can only declare constant variables (public, static, and final)"),(0,r.kt)("td",{parentName:"tr",align:null},"Can declare any kind of variables (public, private, protected, default, static, final, non-final, etc.)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"A class can implement multiple interfaces"),(0,r.kt)("td",{parentName:"tr",align:null},"A class can extend only one abstract class")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Cannot have a constructor"),(0,r.kt)("td",{parentName:"tr",align:null},"Can have a constructor (but cannot initialize)")))),(0,r.kt)("p",null,"Here is an example of an interface and an abstract class in Java:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// An interface\ninterface Flyable {\n  // A constant variable\n  int WINGS = 2;\n  // An abstract method\n  void fly();\n  // A default method\n  default void glide() {\n    System.out.println("Gliding...");\n  }\n  // A static method\n  static void land() {\n    System.out.println("Landing...");\n  }\n}\n\n// An abstract class\nabstract class Animal {\n  // A non-final variable\n  private String name;\n  // A final variable\n  protected final int legs;\n  // A constructor\n  public Animal(String name, int legs) {\n    this.name = name;\n    this.legs = legs;\n  }\n  // A non-abstract method\n  public String getName() {\n    return name;\n  }\n  // An abstract method\n  public abstract void makeSound();\n}\n\n// A class that implements an interface\nclass Bird implements Flyable {\n  // Implementing the abstract method\n  public void fly() {\n    System.out.println("Flying...");\n  }\n}\n\n// A class that extends an abstract class and implements an interface\nclass Eagle extends Animal implements Flyable {\n  // Calling the superclass constructor\n  public Eagle(String name) {\n    super(name, 2);\n  }\n  // Implementing the abstract method from Animal\n  public void makeSound() {\n    System.out.println("Screaming...");\n  }\n  // Overriding the default method from Flyable\n  public void glide() {\n    System.out.println("Gliding high...");\n  }\n}\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Access modifiers & Non-access modifiers in java")),(0,r.kt)("p",null,"In Java, there are two types of modifiers: access modifiers and non-access modifiers."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Access modifiers")," ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"control the visibility and accessibility"))," of classes, methods, and fields. There are four access modifiers in Java:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"public"),": The class, method, or field is accessible from any other class or any package."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"private"),": The class, method, or field is accessible only within the same class."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"protected"),": The class, method, or field is accessible within the same package or from subclasses in different packages."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"default")," (no keyword): The class, method, or field is accessible within the same package.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Non-access modifiers")," ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"modify the behavior and properties"))," of classes, methods, and fields. There are several non-access modifiers in Java, such as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"static"),": The class, method, or field belongs to the class and not to any object of the class. It can be accessed without creating an object of the class."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"final"),": The class, method, or field cannot be changed or overridden. It can be initialized only once."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"abstract"),": The class or method is incomplete and cannot be instantiated. It can only be extended or implemented by subclasses or subinterfaces."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"synchronized"),": The method or block can be accessed by only one thread at a time."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"volatile"),": The field is not cached by threads and its value is always read from the main memory."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"transient"),": The field is not serialized when the object is saved to a file or sent over a network."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"native"),": The method is implemented in a platform-dependent language such as C or C++.")),(0,r.kt)("p",null,"Here are some examples of using these modifiers in Java:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// A public class that can be accessed from any package\npublic class Animal {\n  // A private field that can be accessed only within this class\n  private String name;\n  // A protected field that can be accessed within this package or from subclasses in different packages\n  protected int age;\n  // A default field that can be accessed within this package\n  String type;\n  // A public static final field that can be accessed from any class or package and cannot be changed\n  public static final int MAX_AGE = 100;\n  \n  // A public constructor that can be used to create an object of this class from any package\n  public Animal(String name, int age, String type) {\n    this.name = name;\n    this.age = age;\n    this.type = type;\n  }\n  \n  // A private method that can be called only within this class\n  private void setName(String name) {\n    this.name = name;\n  }\n  \n  // A protected method that can be called within this package or from subclasses in different packages\n  protected void setAge(int age) {\n    this.age = age;\n  }\n  \n  // A default method that can be called within this package\n  void setType(String type) {\n    this.type = type;\n  }\n  \n  // A public method that can be called from any class or package\n  public String getName() {\n    return name;\n  }\n  \n  // A public static method that can be called without creating an object of this class\n  public static boolean isOld(int age) {\n    return age > MAX_AGE;\n  }\n  \n  // An abstract method that has no implementation and must be overridden by subclasses\n  public abstract void makeSound();\n}\n\n// A final class that cannot be extended by any other class\nfinal class Dog extends Animal {\n  \n  // A public constructor that calls the super constructor\n  public Dog(String name, int age) {\n    super(name, age, "Dog");\n  }\n  \n  // An overridden method that provides the implementation for the abstract method in the superclass\n  @Override\n  public void makeSound() {\n    System.out.println("Woof!");\n  }\n}\n\n// An interface that defines some constants and abstract methods\ninterface Flyable {\n  \n  // A public static final field that is implicitly declared by the interface\n  int MAX_SPEED = 200;\n  \n  // An abstract method that has no implementation and must be implemented by classes that implement this interface\n  void fly();\n}\n\n// A class that implements an interface and inherits from another class\nclass Bird extends Animal implements Flyable {\n  \n  // A private volatile field that is not cached by threads and always read from the main memory\n  private volatile boolean flying;\n  \n  // A public constructor that calls the super constructor\n  public Bird(String name, int age) {\n    super(name, age, "Bird");\n    flying = false;\n  }\n  \n  // A synchronized method that can be accessed by only one thread at a time\n  public synchronized void setFlying(boolean flying) {\n    this.flying = flying;\n  }\n  \n  // An implemented method that provides the implementation for the interface method\n  @Override\n  public void fly() {\n    if (flying) {\n      System.out.println("I am flying at " + MAX_SPEED + " km/h");\n    } else {\n      System.out.println("I am not flying");\n    }\n  }\n  \n  // An overridden method that provides the implementation for the abstract method in the superclass\n  @Override\n  public void makeSound() {\n    System.out.println("Tweet!");\n  }\n}\n')),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Modifier"),(0,r.kt)("th",{parentName:"tr",align:null},"Access"),(0,r.kt)("th",{parentName:"tr",align:null},"Mutability"),(0,r.kt)("th",{parentName:"tr",align:null},"Inheritance"),(0,r.kt)("th",{parentName:"tr",align:null},"Overriding"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"public"),(0,r.kt)("td",{parentName:"tr",align:null},"Anywhere"),(0,r.kt)("td",{parentName:"tr",align:null},"Depends on other modifiers"),(0,r.kt)("td",{parentName:"tr",align:null},"Allowed for classes and methods"),(0,r.kt)("td",{parentName:"tr",align:null},"Allowed for methods")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"private"),(0,r.kt)("td",{parentName:"tr",align:null},"Same class only"),(0,r.kt)("td",{parentName:"tr",align:null},"Depends on other modifiers"),(0,r.kt)("td",{parentName:"tr",align:null},"Not allowed for classes and methods"),(0,r.kt)("td",{parentName:"tr",align:null},"Not allowed for methods")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"protected"),(0,r.kt)("td",{parentName:"tr",align:null},"Same package or subclasses in different packages"),(0,r.kt)("td",{parentName:"tr",align:null},"Depends on other modifiers"),(0,r.kt)("td",{parentName:"tr",align:null},"Allowed for classes and methods"),(0,r.kt)("td",{parentName:"tr",align:null},"Allowed for methods")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"default"),(0,r.kt)("td",{parentName:"tr",align:null},"Same package only"),(0,r.kt)("td",{parentName:"tr",align:null},"Depends on other modifiers"),(0,r.kt)("td",{parentName:"tr",align:null},"Allowed for classes and methods"),(0,r.kt)("td",{parentName:"tr",align:null},"Allowed for methods")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"static"),(0,r.kt)("td",{parentName:"tr",align:null},"Depends on other access modifiers"),(0,r.kt)("td",{parentName:"tr",align:null},"Depends on other modifiers"),(0,r.kt)("td",{parentName:"tr",align:null},"Not allowed for classes, allowed for methods and fields"),(0,r.kt)("td",{parentName:"tr",align:null},"Not allowed for methods and fields")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"final"),(0,r.kt)("td",{parentName:"tr",align:null},"Depends on other access modifiers"),(0,r.kt)("td",{parentName:"tr",align:null},"Not mutable"),(0,r.kt)("td",{parentName:"tr",align:null},"Not allowed for classes and methods, allowed for fields"),(0,r.kt)("td",{parentName:"tr",align:null},"Not allowed for methods and fields")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"non-final"),(0,r.kt)("td",{parentName:"tr",align:null},"Depends on other access modifiers"),(0,r.kt)("td",{parentName:"tr",align:null},"Mutable"),(0,r.kt)("td",{parentName:"tr",align:null},"Allowed for classes, methods, and fields"),(0,r.kt)("td",{parentName:"tr",align:null},"Allowed for methods and fields")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// A public class\npublic class A {\n  // A public static final field\n  public static final int VALUE = 10;\n  // A private non-static non-final field\n  private int number;\n  // A protected static non-final method\n  protected static void print() {\n    System.out.println("Printing...");\n  }\n  // A default non-static final method\n  final void display() {\n    System.out.println("Displaying...");\n  }\n}\n\n// A non-final class that inherits from A\nclass B extends A {\n  // A public non-static non-final method that overrides print()\n  public void print() {\n    System.out.println("Printing from B...");\n  }\n  // A private static final method\n  private static final void show() {\n    System.out.println("Showing...");\n  }\n}\n\n// A final class that inherits from B\nfinal class C extends B {\n  // A protected non-static non-final field\n  protected int value;\n  // A default static non-final method\n  static void display() {\n    System.out.println("Displaying from C...");\n  }\n}\n'))))}p.isMDXComponent=!0},52234:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return u}});var a=n(83117),r=(n(67294),n(3905));const i={},o=void 0,l={unversionedId:"java/hero/concurrency",id:"java/hero/concurrency",title:"concurrency",description:"Concurrency vs Multithreading vs Parallelism",source:"@site/docs/java/hero/concurrency.md",sourceDirName:"java/hero",slug:"/java/hero/concurrency",permalink:"/devviews/interviews/java/hero/concurrency",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/java/hero/concurrency.md",tags:[],version:"current",frontMatter:{},sidebar:"javaInterviewSidebar",previous:{title:"OOP",permalink:"/devviews/interviews/java/hero/OOP"},next:{title:"exceptions",permalink:"/devviews/interviews/java/hero/exceptions"}},s={},u=[],c={toc:u},d="wrapper";function p(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Concurrency vs Multithreading vs Parallelism")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Multithreading")," is a technique that splits applications into multiple threads/tasks."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Concurrency")," means doing those threads/tasks simultaneously on one or multiple processors."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parallelism")," means that multiple threads/tasks are executed at the same time on different processors or cores.")),(0,r.kt)("p",null,"Since version 5.0, the Java platform has also included high-level concurrency APIs in the ",(0,r.kt)("inlineCode",{parentName:"p"},"java.util.concurrent")," packages. These packages provide useful features such as ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"thread pools")),", ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"atomic variables")),", ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"locks")),", ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"concurrent collections")),", ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"synchronizers")),", ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"executors")),", ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"futures")),", and ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"completable futures")),".")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"ExecutorService")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ExecutorService")," in Java is an interface that provides methods to manage the execution of asynchronous tasks on threads. It is part of the ",(0,r.kt)("inlineCode",{parentName:"p"},"java.util.concurrent")," package, which contains classes and interfaces for concurrent programming. ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecutorService")," helps in ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"creating and managing a pool of threads, and assigning tasks to them")),". "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"You can ",(0,r.kt)("strong",{parentName:"p"},"create")," an ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecutorService")," instance by using one of the factory methods of the Executors class, or by using a specific implementation such as ",(0,r.kt)("inlineCode",{parentName:"p"},"ThreadPoolExecutor")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"ForkJoinPool"),". ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"You can ",(0,r.kt)("strong",{parentName:"p"},"assign tasks")," to the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecutorService")," using methods such as ",(0,r.kt)("inlineCode",{parentName:"p"},"execute()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"submit()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"invokeAll()")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"invokeAny()"),". These methods can accept ",(0,r.kt)("inlineCode",{parentName:"p"},"Runnable")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Callable")," objects, which represent the tasks to be executed. You can also use ",(0,r.kt)("inlineCode",{parentName:"p"},"Future")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"CompletableFuture")," objects to get the result or status of the tasks. ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"You can ",(0,r.kt)("strong",{parentName:"p"},"shut down")," the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecutorService")," when you don\u2019t need it anymore, by using methods such as ",(0,r.kt)("inlineCode",{parentName:"p"},"shutdown()")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"shutdownNow()"),"."))),(0,r.kt)("p",null,"Here is an example of how to use ExecutorService in Java:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.concurrent.*;\n\npublic class ExecutorServiceExample {\n\n    public static void main(String[] args) throws InterruptedException, ExecutionException {\n        // Create an executor service with 4 threads\n        ExecutorService executor = Executors.newFixedThreadPool(4);\n\n        // Create a runnable task that prints "Hello World"\n        Runnable task = () -> {\n            System.out.println("Hello World");\n        };\n\n        // Submit the task to the executor service 10 times\n        for (int i = 0; i < 10; i++) {\n            executor.submit(task);\n        }\n\n        // Shutdown the executor service gracefully\n        executor.shutdown();\n    }\n}\n')),(0,r.kt)("p",null,"This code will output something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Hello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\n")),(0,r.kt)("p",null,"You can see that the executor service executes the task 10 times on 4 threads, and then shuts down. This is the benefit of using ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecutorService")," in Java.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"ExecutorService vs ThreadPoolExecutor vs ForkJoinPool")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ExecutorService"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ThreadPoolExecutor")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ForkJoinPool")," are all interfaces or classes for managing and executing tasks in Java. However, they have some differences in their design and behavior, such as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ExecutorService")," is an interface that represents an executor that can ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"run tasks asynchronously")),". It provides methods to ",(0,r.kt)("inlineCode",{parentName:"li"},"submit"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"cancel"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"monitor")," and control the execution of tasks."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ThreadPoolExecutor")," is a concrete class that implements ",(0,r.kt)("inlineCode",{parentName:"li"},"ExecutorService"),". It ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"uses a pool of threads to execute tasks")),". It allows to configure the core pool size, maximum pool size, keep alive time, work queue, thread factory and rejected execution handler."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ForkJoinPool")," is another concrete class that implements ",(0,r.kt)("inlineCode",{parentName:"li"},"ExecutorService"),". It ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"uses a work-stealing algorithm to execute tasks")),". It is designed for tasks that can be split into smaller subtasks recursively, such as ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"divide-and-conquer algorithms")),". It allows to configure the parallelism level, thread factory and uncaught exception handler.")),(0,r.kt)("p",null,"Here is a table that compares some of the main features of ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecutorService"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ThreadPoolExecutor")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ForkJoinPool"),":"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Feature"),(0,r.kt)("th",{parentName:"tr",align:null},"ExecutorService"),(0,r.kt)("th",{parentName:"tr",align:null},"ThreadPoolExecutor"),(0,r.kt)("th",{parentName:"tr",align:null},"ForkJoinPool"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Interface or class"),(0,r.kt)("td",{parentName:"tr",align:null},"Interface"),(0,r.kt)("td",{parentName:"tr",align:null},"Class"),(0,r.kt)("td",{parentName:"tr",align:null},"Class")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Task queue"),(0,r.kt)("td",{parentName:"tr",align:null},"Common queue for all threads"),(0,r.kt)("td",{parentName:"tr",align:null},"Common queue for all threads"),(0,r.kt)("td",{parentName:"tr",align:null},"Separate queue for each thread")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Task splitting"),(0,r.kt)("td",{parentName:"tr",align:null},"No support"),(0,r.kt)("td",{parentName:"tr",align:null},"No support"),(0,r.kt)("td",{parentName:"tr",align:null},"Support for recursive subtasks")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Work stealing"),(0,r.kt)("td",{parentName:"tr",align:null},"No support"),(0,r.kt)("td",{parentName:"tr",align:null},"No support"),(0,r.kt)("td",{parentName:"tr",align:null},"Support for stealing subtasks from other threads")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Configuration options"),(0,r.kt)("td",{parentName:"tr",align:null},"Depends on the implementation"),(0,r.kt)("td",{parentName:"tr",align:null},"Core pool size, maximum pool size, keep alive time, work queue, thread factory, rejected execution handler"),(0,r.kt)("td",{parentName:"tr",align:null},"Parallelism level, thread factory, uncaught exception handler"))))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"execute() vs submit() vs invokeAll() vs invokeAny()")),(0,r.kt)("p",null,"ExecutorService is an interface that provides methods for managing and executing tasks in Java. It has four methods for submitting tasks: ",(0,r.kt)("inlineCode",{parentName:"p"},"execute()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"submit()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"invokeAll()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"invokeAny()"),". They have some differences in their design and behavior, such as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"execute()")," takes a ",(0,r.kt)("inlineCode",{parentName:"li"},"Runnable")," task as a parameter and does not return anything. It is suitable for tasks that do not need to produce any result or handle any exception. It ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"does not provide any way to cancel or monitor the task")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"submit()")," takes either a ",(0,r.kt)("inlineCode",{parentName:"li"},"Runnable")," or a ",(0,r.kt)("inlineCode",{parentName:"li"},"Callable")," task as a parameter and returns a ",(0,r.kt)("inlineCode",{parentName:"li"},"Future")," object. It is suitable for tasks that need to produce a result or handle an exception. It ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"provides a way to cancel or monitor the task using the ",(0,r.kt)("inlineCode",{parentName:"em"},"Future")," object")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"invokeAll()")," takes a collection of ",(0,r.kt)("inlineCode",{parentName:"li"},"Callable")," tasks as a parameter and returns a list of ",(0,r.kt)("inlineCode",{parentName:"li"},"Future")," objects. It ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"blocks until all the tasks are completed or the timeout expires")),". It is ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"suitable for tasks that need to be executed in parallel"))," and their results need to be collected."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"invokeAny()")," takes a collection of ",(0,r.kt)("inlineCode",{parentName:"li"},"Callable")," tasks as a parameter and returns the result of one of the completed tasks. It ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"blocks until at least one of the tasks is completed or the timeout expires")),". It is ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"suitable for tasks that are equivalent and only one result is needed")),".")),(0,r.kt)("p",null,"Here is a table that compares some of the main features of execute(), submit(), invokeAll() and invokeAny() methods in ExecutorService:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Method"),(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Return type"),(0,r.kt)("th",{parentName:"tr",align:null},"Blocking"),(0,r.kt)("th",{parentName:"tr",align:null},"Cancellation"),(0,r.kt)("th",{parentName:"tr",align:null},"Result"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"execute()"),(0,r.kt)("td",{parentName:"tr",align:null},"Runnable"),(0,r.kt)("td",{parentName:"tr",align:null},"void"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"None")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"submit()"),(0,r.kt)("td",{parentName:"tr",align:null},"Runnable or Callable"),(0,r.kt)("td",{parentName:"tr",align:null},"Future"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Optional")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"invokeAll()"),(0,r.kt)("td",{parentName:"tr",align:null},"Collection of Callable"),(0,r.kt)("td",{parentName:"tr",align:null},"List of Future"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"All")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"invokeAny()"),(0,r.kt)("td",{parentName:"tr",align:null},"Collection of Callable"),(0,r.kt)("td",{parentName:"tr",align:null},"Object"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"One")))),(0,r.kt)("p",null,"Here are some examples of using execute(), submit(), invokeAll() and invokeAny() methods in ExecutorService:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Using execute() to run a Runnable task:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Create an ExecutorService with a fixed thread pool\nExecutorService executor = Executors.newFixedThreadPool(2);\n\n// Create a Runnable task\nRunnable task = () -> {\n    // Do some work\n    System.out.println("Hello from execute()");\n};\n\n// Execute the task\nexecutor.execute(task);\n\n// Shutdown the executor\nexecutor.shutdown();\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Using submit() to run a Callable task and get the result:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Create an ExecutorService with a fixed thread pool\nExecutorService executor = Executors.newFixedThreadPool(2);\n\n// Create a Callable task\nCallable<String> task = () -> {\n    // Do some work\n    return "Hello from submit()";\n};\n\n// Submit the task and get a Future object\nFuture<String> future = executor.submit(task);\n\n// Get the result from the Future object\ntry {\n    String result = future.get();\n    System.out.println(result);\n} catch (InterruptedException | ExecutionException e) {\n    e.printStackTrace();\n}\n\n// Shutdown the executor\nexecutor.shutdown();\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Using invokeAll() to run a collection of Callable tasks and get a list of results:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Create an ExecutorService with a fixed thread pool\nExecutorService executor = Executors.newFixedThreadPool(2);\n\n// Create a collection of Callable tasks\nList<Callable<String>> tasks = new ArrayList<>();\ntasks.add(() -> "Task 1");\ntasks.add(() -> "Task 2");\ntasks.add(() -> "Task 3");\n\n// Invoke all the tasks and get a list of Future objects\nList<Future<String>> futures = executor.invokeAll(tasks);\n\n// Iterate over the futures and get the results\nfor (Future<String> future : futures) {\n    try {\n        String result = future.get();\n        System.out.println(result);\n    } catch (InterruptedException | ExecutionException e) {\n        e.printStackTrace();\n    }\n}\n\n// Shutdown the executor\nexecutor.shutdown();\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Using invokeAny() to run a collection of Callable tasks and get one result:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Create an ExecutorService with a fixed thread pool\nExecutorService executor = Executors.newFixedThreadPool(2);\n\n// Create a collection of Callable tasks\nList<Callable<String>> tasks = new ArrayList<>();\ntasks.add(() -> "Task 1");\ntasks.add(() -> "Task 2");\ntasks.add(() -> "Task 3");\n\n// Invoke any of the tasks and get one result\nString result = executor.invokeAny(tasks);\n\n// Print the result\nSystem.out.println(result);\n\n// Shutdown the executor\nexecutor.shutdown();\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Future  vs CompletableFuture")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Feature"),(0,r.kt)("th",{parentName:"tr",align:null},"Future"),(0,r.kt)("th",{parentName:"tr",align:null},"CompletableFuture"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Blocking"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes, ",(0,r.kt)("inlineCode",{parentName:"td"},"Future.get()")," blocks the current thread"),(0,r.kt)("td",{parentName:"tr",align:null},"No, ",(0,r.kt)("inlineCode",{parentName:"td"},"CompletableFuture.thenAccept()")," registers a callback function")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Completing"),(0,r.kt)("td",{parentName:"tr",align:null},"No, Future can only be cancelled"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes, CompletableFuture can be completed manually")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Composing"),(0,r.kt)("td",{parentName:"tr",align:null},"Limited, Future does not provide methods to chain or combine tasks"),(0,r.kt)("td",{parentName:"tr",align:null},"Rich, ",(0,r.kt)("inlineCode",{parentName:"td"},"CompletableFuture")," provides methods such as ",(0,r.kt)("inlineCode",{parentName:"td"},"thenApply()"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"thenCompose()"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"thenCombine()"),", etc.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Handling exceptions"),(0,r.kt)("td",{parentName:"tr",align:null},"Poor, ",(0,r.kt)("inlineCode",{parentName:"td"},"Future.get()")," throws an ",(0,r.kt)("inlineCode",{parentName:"td"},"ExecutionException")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Splendid"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"CompletableFuture.exceptionally()")," allows handling exceptions and providing fallback values")))),(0,r.kt)("p",null,"Here are some examples of using Future and CompletableFuture in Java:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Creating a Future with ExecutorService and getting the result with Future.get():")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'ExecutorService executor = Executors.newSingleThreadExecutor();\nFuture<Integer> future = executor.submit(() -> {\n    // Some long-running task\n    return 42;\n});\n// Do some other work\ntry {\n    // Get the result, blocking if necessary\n    Integer result = future.get();\n    System.out.println("Result: " + result);\n} catch (InterruptedException | ExecutionException e) {\n    e.printStackTrace();\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Creating a CompletableFuture with CompletableFuture.supplyAsync() and getting the result with CompletableFuture.join():")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {\n    // Some long-running task\n    return 42;\n});\n// Do some other work\n// Get the result, blocking if necessary\nInteger result = future.join();\nSystem.out.println("Result: " + result);\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Chaining multiple tasks with CompletableFuture.thenApply() and thenAccept():")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'CompletableFuture.supplyAsync(() -> {\n    // Some long-running task\n    return 42;\n}).thenApply(result -> {\n    // Apply a function to the previous result\n    return result * 2;\n}).thenAccept(result -> {\n    // Consume the final result\n    System.out.println("Result: " + result);\n});\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Handling exceptions with CompletableFuture.exceptionally():")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'CompletableFuture.supplyAsync(() -> {\n    // Some long-running task that may throw an exception\n    if (Math.random() > 0.5) {\n        throw new RuntimeException("Something went wrong");\n    }\n    return 42;\n}).exceptionally(ex -> {\n    // Handle the exception and provide a fallback value\n    System.out.println("Error: " + ex.getMessage());\n    return -1;\n}).thenAccept(result -> {\n    // Consume the final result\n    System.out.println("Result: " + result);\n});\n'))))}p.isMDXComponent=!0},580:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return u}});var a=n(83117),r=(n(67294),n(3905));const i={sidebar_position:1e3,sidebar_label:"Data Structure",title:"Data Structure",tags:["Java Knowledge"]},o=void 0,l={unversionedId:"java/hero/data-structure",id:"java/hero/data-structure",title:"Data Structure",description:"Data Structure",source:"@site/docs/java/hero/data-structure.md",sourceDirName:"java/hero",slug:"/java/hero/data-structure",permalink:"/devviews/interviews/java/hero/data-structure",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/java/hero/data-structure.md",tags:[{label:"Java Knowledge",permalink:"/devviews/interviews/tags/java-knowledge"}],version:"current",sidebarPosition:1e3,frontMatter:{sidebar_position:1e3,sidebar_label:"Data Structure",title:"Data Structure",tags:["Java Knowledge"]},sidebar:"javaInterviewSidebar",previous:{title:"Boxing vs Unboxing",permalink:"/devviews/interviews/java-coding"},next:{title:"Functional Interface",permalink:"/devviews/interviews/java/hero/funtional-interface"}},s={},u=[],c={toc:u},d="wrapper";function p(e){let{components:t,...i}=e;return(0,r.kt)(d,(0,a.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Data Structure")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"How Java Works",src:n(27490).Z,width:"930",height:"523"})),(0,r.kt)("p",null,"Data structure in Java can be classified into two types: primitive and non-primitive."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Primitive")," data structures are the basic types of data that are built-in in Java, such as byte, short, int, long, float, double, char, and boolean. "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Non-primitive")," data structures are the complex types of data that are derived from primitive data structures or defined by the user, such as array, string, class, object, interface, etc.")),(0,r.kt)("p",null,"Non-primitive data structures can be further classified into two types: linear and non-linear."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Linear data structures")," are the ones that store data ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"in a sequential and ordered manner")),", such that each element has a unique predecessor and successor, except the first and last element. Examples of linear data structures are ",(0,r.kt)("inlineCode",{parentName:"p"},"array"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"linked list"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"stack"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"queue"),", etc.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Non-linear data structures")," are the ones that store data ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"in a hierarchical or networked manner")),", such that each element may have more than one predecessor or successor. Examples of non-linear data structures are ",(0,r.kt)("inlineCode",{parentName:"p"},"tree"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"graph"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"heap"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"hash table"),", etc."))),(0,r.kt)("p",null,":::note Tips To Remember"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Linear prefix: ",(0,r.kt)("inlineCode",{parentName:"li"},"Array"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Linked"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Priority")),(0,r.kt)("li",{parentName:"ul"},"Non-linear prefix: ",(0,r.kt)("inlineCode",{parentName:"li"},"Hash"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Tree")),(0,r.kt)("li",{parentName:"ul"},"Suffix: ",(0,r.kt)("inlineCode",{parentName:"li"},"Set"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"List"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Map"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Table"))),(0,r.kt)("p",null,":::")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Iterable")),(0,r.kt)("p",null,"Iterable in Java is an interface that represents a collection of elements that can be iterated over using a for-each loop or an iterator & allows sequential access to the elements of a collection. It has three methods: ",(0,r.kt)("inlineCode",{parentName:"p"},"hasNext()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"next()"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"remove()"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"// A custom class that implements Iterable interface\nclass MyCollection<T> implements Iterable<T> {\n  // An array to store the elements\n  private T[] array;\n\n  // A constructor to initialize the array\n  public MyCollection(T[] array) {\n    this.array = array;\n  }\n\n  // An implementation of iterator () method that returns an Iterator object\n  public Iterator<T> iterator() {\n    // Return an anonymous inner class that implements Iterator interface\n    return new Iterator<T>() {\n      // A variable to keep track of the current index\n      private int index = 0;\n\n      // An implementation of hasNext () method that checks if there are more elements\n      public boolean hasNext() {\n        return index < array.length;\n      }\n\n      // An implementation of next () method that returns the next element\n      public T next() {\n        return array[index++];\n      }\n\n      // An implementation of remove () method that is not supported\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }\n}\n")),(0,r.kt)("p",null,"To use an Iterable object in Java, we can either use a for-each loop or an explicit iterator. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Create an array of strings\nString[] names = {"Alice", "Bob", "Charlie"};\n\n// Create an instance of MyCollection class with the array\nMyCollection<String> myCollection = new MyCollection<>(names);\n\n// Use a for-each loop to iterate over the elements\nfor (String name : myCollection) {\n  System.out.println(name);\n}\n\n// Use an explicit iterator to iterate over the elements\nIterator<String> iterator = myCollection.iterator();\nwhile (iterator.hasNext()) {\n  System.out.println(iterator.next());\n}\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Array vs Array List")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Difference"),(0,r.kt)("th",{parentName:"tr",align:null},"Array"),(0,r.kt)("th",{parentName:"tr",align:null},"ArrayList"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Size"),(0,r.kt)("td",{parentName:"tr",align:null},"Fixed-size data structure"),(0,r.kt)("td",{parentName:"tr",align:null},"Variable-size data structure")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Type"),(0,r.kt)("td",{parentName:"tr",align:null},"Can store primitive types or objects"),(0,r.kt)("td",{parentName:"tr",align:null},"Can only store objects")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Access"),(0,r.kt)("td",{parentName:"tr",align:null},"By using the index operator []"),(0,r.kt)("td",{parentName:"tr",align:null},"By using the get () and set () methods")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Methods"),(0,r.kt)("td",{parentName:"tr",align:null},"Does not have any built-in methods"),(0,r.kt)("td",{parentName:"tr",align:null},"Has many methods to manipulate the data")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Generics"),(0,r.kt)("td",{parentName:"tr",align:null},"Can\u2019t use generics along"),(0,r.kt)("td",{parentName:"tr",align:null},"Can use generics along")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"// Declare and initialize an array of int type\nint[] numbers = {10, 20, 30, 40};\n\n// Print the length of the array\nSystem.out.println(numbers.length); // Output: 4\n\n// Print the first element of the array\nSystem.out.println(numbers[0]); // Output: 10\n\n// Change the value of the second element of the array\nnumbers[1] = 25;\n\n// Print the second element of the array\nSystem.out.println(numbers[1]); // Output: 25\n\n// Try to add a new element to the array\nnumbers[4] = 50; // Error: ArrayIndexOutOfBoundsException\n\n// Declare and initialize an ArrayList of Integer type\nArrayList<Integer> numbersList = new ArrayList<Integer>();\n\n// Add some elements to the ArrayList\nnumbersList.add(10);\nnumbersList.add(20);\nnumbersList.add(30);\nnumbersList.add(40);\n\n// Print the size of the ArrayList\nSystem.out.println(numbersList.size()); // Output: 4\n\n// Print the first element of the ArrayList\nSystem.out.println(numbersList.get(0)); // Output: 10\n\n// Change the value of the second element of the ArrayList\nnumbersList.set(1, 25);\n\n// Print the second element of the ArrayList\nSystem.out.println(numbersList.get(1)); // Output: 25\n\n// Add a new element to the end of the ArrayList\nnumbersList.add(50);\n\n// Print the size of the ArrayList\nSystem.out.println(numbersList.size()); // Output: 5\n\n// Print the last element of the ArrayList\nSystem.out.println(numbersList.get(4)); // Output: 50\n\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"ArrayList vs. LinkedList vs. Vector vs. Stack")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Difference"),(0,r.kt)("th",{parentName:"tr",align:null},"ArrayList"),(0,r.kt)("th",{parentName:"tr",align:null},"LinkedList"),(0,r.kt)("th",{parentName:"tr",align:null},"Vector"),(0,r.kt)("th",{parentName:"tr",align:null},"Stack"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Implementation"),(0,r.kt)("td",{parentName:"tr",align:null},"Uses a dynamic array as its internal data structure"),(0,r.kt)("td",{parentName:"tr",align:null},"Uses a doubly linked list as its internal data structure"),(0,r.kt)("td",{parentName:"tr",align:null},"Uses a synchronized dynamic array as its internal data structure"),(0,r.kt)("td",{parentName:"tr",align:null},"Extends Vector and uses a LIFO (last-in first-out) order for its elements")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Size"),(0,r.kt)("td",{parentName:"tr",align:null},"Can grow or shrink dynamically as needed"),(0,r.kt)("td",{parentName:"tr",align:null},"Can grow or shrink dynamically as needed"),(0,r.kt)("td",{parentName:"tr",align:null},"Can grow or shrink dynamically as needed"),(0,r.kt)("td",{parentName:"tr",align:null},"Can grow or shrink dynamically as needed")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Access"),(0,r.kt)("td",{parentName:"tr",align:null},"Allows random access to any element by using its index"),(0,r.kt)("td",{parentName:"tr",align:null},"Does not allow random access, requires sequential traversal to access any element"),(0,r.kt)("td",{parentName:"tr",align:null},"Allows random access to any element by using its index"),(0,r.kt)("td",{parentName:"tr",align:null},"Does not allow random access, only allows access to the top element")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Performance"),(0,r.kt)("td",{parentName:"tr",align:null},"Fast for get and set operations, slow for add and remove operations when resizing is involved or shifting is required"),(0,r.kt)("td",{parentName:"tr",align:null},"Fast for add and remove operations at any position, slow for get and set operations"),(0,r.kt)("td",{parentName:"tr",align:null},"Similar to ArrayList, but slower due to synchronization overhead"),(0,r.kt)("td",{parentName:"tr",align:null},"Similar to Vector, but provides additional methods such as push, pop, peek, and search")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Synchronization"),(0,r.kt)("td",{parentName:"tr",align:null},"Not synchronized, not thread-safe"),(0,r.kt)("td",{parentName:"tr",align:null},"Not synchronized, not thread-safe"),(0,r.kt)("td",{parentName:"tr",align:null},"Synchronized, thread-safe"),(0,r.kt)("td",{parentName:"tr",align:null},"Synchronized, thread-safe")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Legacy"),(0,r.kt)("td",{parentName:"tr",align:null},"Not a legacy class, introduced in Java 1.2"),(0,r.kt)("td",{parentName:"tr",align:null},"Not a legacy class, introduced in Java 1.2"),(0,r.kt)("td",{parentName:"tr",align:null},"A legacy class, part of the original Java 1.0 API"),(0,r.kt)("td",{parentName:"tr",align:null},"A legacy class, part of the original Java 1.0 API")))),(0,r.kt)("p",null,"Here are some examples to demonstrate the usage of these classes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Import the required classes\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Vector;\nimport java.util.Stack;\n\n// Create a class with a main method\npublic class Main {\n\n  // Define the main method\n  public static void main(String[] args) {\n\n    // Create an ArrayList of String type\n    ArrayList<String> names = new ArrayList<String>();\n\n    // Add some elements to the ArrayList\n    names.add("Alice");\n    names.add("Bob");\n    names.add("Charlie");\n\n    // Print the size and contents of the ArrayList\n    System.out.println("ArrayList size: " + names.size());\n    System.out.println("ArrayList elements: " + names);\n\n    // Get and set an element using its index\n    System.out.println("First element: " + names.get(0));\n    names.set(0, "Ann");\n    System.out.println("First element after update: " + names.get(0));\n\n    // Create a LinkedList of Integer type\n    LinkedList<Integer> numbers = new LinkedList<Integer>();\n\n    // Add some elements to the LinkedList\n    numbers.add(10);\n    numbers.add(20);\n    numbers.add(30);\n\n    // Print the size and contents of the LinkedList\n    System.out.println("LinkedList size: " + numbers.size());\n    System.out.println("LinkedList elements: " + numbers);\n\n    // Add and remove an element at any position\n    numbers.add(1, 15);\n    System.out.println("LinkedList elements after adding 15 at index 1: " + numbers);\n    numbers.remove(2);\n    System.out.println("LinkedList elements after removing element at index 2: " + numbers);\n\n    // Create a Vector of Character type\n    Vector<Character> letters = new Vector<Character>();\n\n    // Add some elements to the Vector\n    letters.add(\'A\');\n    letters.add(\'B\');\n    letters.add(\'C\');\n\n    // Print the size and contents of the Vector\n    System.out.println("Vector size: " + letters.size());\n    System.out.println("Vector elements: " + letters);\n\n    // Sort and search the Vector using Collections class methods\n    Collections.sort(letters);\n    System.out.println("Vector elements after sorting: " + letters);\n    int index = Collections.binarySearch(letters, \'B\');\n    System.out.println("Index of B in Vector: " + index);\n\n    // Create a Stack of Double type\n    Stack<Double> values = new Stack<Double>();\n\n    // Add some elements to the Stack using push method\n    values.push(1.0);\n    values.push(2.0);\n    values.push(3.0);\n\n    // Print the size and contents of the Stack\n    // Print the size and contents of the Stack\n    System.out.println("Stack size: " + values.size());\n    System.out.println("Stack elements: " + values);\n\n    // Access and remove the top element using pop and peek methods\n    System.out.println("Top element: " + values.peek());\n    values.pop();\n    System.out.println("Top element after pop: " + values.peek());\n\n    // Search for an element using search method\n    int position = values.search(2.0);\n    System.out.println("Position of 2.0 in Stack: " + position);\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"HashSet vs. TreeSet vs. LinkedHashSet")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Feature"),(0,r.kt)("th",{parentName:"tr",align:null},"HashSet"),(0,r.kt)("th",{parentName:"tr",align:null},"LinkedHashSet"),(0,r.kt)("th",{parentName:"tr",align:null},"TreeSet"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Internal Working"),(0,r.kt)("td",{parentName:"tr",align:null},"Uses HashMap for storing objects"),(0,r.kt)("td",{parentName:"tr",align:null},"Uses LinkedHashMap for storing objects"),(0,r.kt)("td",{parentName:"tr",align:null},"Uses TreeMap for storing objects")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"When To Use"),(0,r.kt)("td",{parentName:"tr",align:null},"If you don\u2019t want to maintain insertion order but want to store unique objects"),(0,r.kt)("td",{parentName:"tr",align:null},"If you want to ",(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"maintain the insertion order"))," of elements then you can use LinkedHashSet"),(0,r.kt)("td",{parentName:"tr",align:null},"If you want to ",(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"sort the elements"))," according to some Comparator then use TreeSet")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Order"),(0,r.kt)("td",{parentName:"tr",align:null},"Does not maintain insertion order"),(0,r.kt)("td",{parentName:"tr",align:null},"Maintains the insertion order of objects"),(0,r.kt)("td",{parentName:"tr",align:null},"Orders the elements according to supplied Comparator or natural ascending order")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Complexity of Operations"),(0,r.kt)("td",{parentName:"tr",align:null},"O(1) for insertion, removing, and retrieving objects"),(0,r.kt)("td",{parentName:"tr",align:null},"O(1) for insertion, removing, and retrieving operations"),(0,r.kt)("td",{parentName:"tr",align:null},"O(log(n)) for insertion, removing, and retrieving operations")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Performance"),(0,r.kt)("td",{parentName:"tr",align:null},"Better than LinkedHashSet and TreeSet"),(0,r.kt)("td",{parentName:"tr",align:null},"Slower than HashSet but faster than TreeSet"),(0,r.kt)("td",{parentName:"tr",align:null},"Slower than HashSet and LinkedHashSet due to sorting")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Compare"),(0,r.kt)("td",{parentName:"tr",align:null},"Uses equals() and hashCode() methods to compare the objects"),(0,r.kt)("td",{parentName:"tr",align:null},"Uses equals() and hashCode() methods to compare it\u2019s objects"),(0,r.kt)("td",{parentName:"tr",align:null},"Uses compare() and compareTo() methods to compare the objects")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Null Elements"),(0,r.kt)("td",{parentName:"tr",align:null},"Allows only one null value"),(0,r.kt)("td",{parentName:"tr",align:null},"Allows only one null value"),(0,r.kt)("td",{parentName:"tr",align:null},"Does not permit null value")))),(0,r.kt)("p",null,"Here is an example of how to use each of these classes in Java:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.*;\n\nclass Example {\n\n  public static void main(String args[]) {\n\n    // Create HashSet\n    HashSet<String> hashSet = new HashSet<>();\n    // Add elements to HashSet\n    hashSet.add("Java");\n    hashSet.add("Angular");\n    hashSet.add("Spring");\n    hashSet.add("Oracle");\n    hashSet.add("MySQL");\n    // Add duplicate elements to HashSet\n    hashSet.add("Java");\n    hashSet.add("Spring");\n    // Add null values to HashSet\n    hashSet.add(null);\n    hashSet.add(null);\n    // Print HashSet elements\n    System.out.println(hashSet); // [null, Java, MySQL, Spring, Oracle, Angular]\n\n    // Create LinkedHashSet\n    LinkedHashSet<String> linkedHashSet = new LinkedHashSet<>();\n    // Add elements to LinkedHashSet\n    linkedHashSet.add("Java");\n    linkedHashSet.add("Angular");\n    linkedHashSet.add("Spring");\n    linkedHashSet.add("Oracle");\n    linkedHashSet.add("MySQL");\n    // Add duplicate elements to LinkedHashSet\n    linkedHashSet.add("Java");\n    linkedHashSet.add("Spring");\n    // Add null values to LinkedHashSet\n    linkedHashSet.add(null);\n    linkedHashSet.add(null);\n    // Print LinkedHashSet elements\n    System.out.println(linkedHashSet); // [Java, Angular, Spring, Oracle, MySQL, null]\n\n    // Create TreeSet\n    TreeSet<String> treeSet = new TreeSet<>();\n    // Add elements to TreeSet\n    treeSet.add("Java");\n    treeSet.add("Angular");\n    treeSet.add("Spring");\n    treeSet.add("Oracle");\n    treeSet.add("MySQL");\n    // Add duplicate elements to TreeSet\n    treeSet.add("Java");\n    treeSet.add("Spring");\n    // Print TreeSet elements\n    System.out.println(treeSet); // [Angular, Java, MySQL, Oracle, Spring]\n  }\n}\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"HashMap vs. TreeMap vs. HashTable vs. LinkedHashMap")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Feature"),(0,r.kt)("th",{parentName:"tr",align:null},"HashMap"),(0,r.kt)("th",{parentName:"tr",align:null},"TreeMap"),(0,r.kt)("th",{parentName:"tr",align:null},"HashTable"),(0,r.kt)("th",{parentName:"tr",align:null},"LinkedHashMap"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Internal Working"),(0,r.kt)("td",{parentName:"tr",align:null},"Uses hash table for storing key-value pairs"),(0,r.kt)("td",{parentName:"tr",align:null},"Uses red-black tree for storing key-value pairs"),(0,r.kt)("td",{parentName:"tr",align:null},"Uses hash table for storing key-value pairs"),(0,r.kt)("td",{parentName:"tr",align:null},"Uses hash table and doubly-linked list for storing key-value pairs")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"When To Use"),(0,r.kt)("td",{parentName:"tr",align:null},"If you don\u2019t care about the order of elements and want fast access and insertion"),(0,r.kt)("td",{parentName:"tr",align:null},"If you want to store elements in sorted order by keys or by a custom comparator"),(0,r.kt)("td",{parentName:"tr",align:null},"If you want a legacy thread-safe map that does not allow null keys or values"),(0,r.kt)("td",{parentName:"tr",align:null},"If you want to maintain the insertion order or access order of elements")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Order"),(0,r.kt)("td",{parentName:"tr",align:null},"Does not maintain any order"),(0,r.kt)("td",{parentName:"tr",align:null},"Maintains ascending order by keys or by a custom comparator"),(0,r.kt)("td",{parentName:"tr",align:null},"Does not maintain any order"),(0,r.kt)("td",{parentName:"tr",align:null},"Maintains insertion order or access order")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Complexity of Operations"),(0,r.kt)("td",{parentName:"tr",align:null},"O(1) for get, put, remove and containsKey (average case)"),(0,r.kt)("td",{parentName:"tr",align:null},"O(log(n)) for get, put, remove and containsKey"),(0,r.kt)("td",{parentName:"tr",align:null},"O(1) for get, put, remove and containsKey (average case)"),(0,r.kt)("td",{parentName:"tr",align:null},"O(1) for get, put, remove and containsKey (average case)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Performance"),(0,r.kt)("td",{parentName:"tr",align:null},"Faster than TreeMap and HashTable"),(0,r.kt)("td",{parentName:"tr",align:null},"Slower than HashMap and HashTable due to sorting"),(0,r.kt)("td",{parentName:"tr",align:null},"Slower than HashMap and LinkedHashMap due to synchronization"),(0,r.kt)("td",{parentName:"tr",align:null},"Slower than HashMap but faster than HashTable due to maintaining order")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Compare"),(0,r.kt)("td",{parentName:"tr",align:null},"Uses equals() and hashCode() methods to compare keys and values"),(0,r.kt)("td",{parentName:"tr",align:null},"Uses compare() or compareTo() methods to compare keys and values"),(0,r.kt)("td",{parentName:"tr",align:null},"Uses equals() and hashCode() methods to compare keys and values"),(0,r.kt)("td",{parentName:"tr",align:null},"Uses equals() and hashCode() methods to compare keys and values")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Null Elements/Keys"),(0,r.kt)("td",{parentName:"tr",align:null},"Allows one null key and multiple null values"),(0,r.kt)("td",{parentName:"tr",align:null},"Does not allow null key but allows multiple null values"),(0,r.kt)("td",{parentName:"tr",align:null},"Does not allow null key or null value"),(0,r.kt)("td",{parentName:"tr",align:null},"Allows one null key and multiple null values")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Thread-Safety"),(0,r.kt)("td",{parentName:"tr",align:null},"Not thread-safe as it is not synchronized"),(0,r.kt)("td",{parentName:"tr",align:null},"Not thread-safe as it is not synchronized"),(0,r.kt)("td",{parentName:"tr",align:null},"Thread-safe as it is synchronized on the whole map"),(0,r.kt)("td",{parentName:"tr",align:null},"Not thread-safe as it is not synchronized")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Fail-Fast Behavior"),(0,r.kt)("td",{parentName:"tr",align:null},"Iterator is fail-fast (throws ConcurrentModificationException) but cannot be guaranteed in the presence of unsynchronized concurrent modification"),(0,r.kt)("td",{parentName:"tr",align:null},"Iterator is fail-fast (throws ConcurrentModificationException) but cannot be guaranteed in the presence of unsynchronized concurrent modification Iterator is fail-fast (throws ConcurrentModificationException) but cannot be guaranteed in the presence of unsynchronized concurrent modification"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null}))))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"String vs StringBuilder vs StringBuffer")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"String"),(0,r.kt)("th",{parentName:"tr",align:null},"StringBuilder"),(0,r.kt)("th",{parentName:"tr",align:null},"StringBuffer"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"string constant pool"),(0,r.kt)("td",{parentName:"tr",align:null},"heap"),(0,r.kt)("td",{parentName:"tr",align:null},"heap")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Immutable"),(0,r.kt)("td",{parentName:"tr",align:null},"Mutable"),(0,r.kt)("td",{parentName:"tr",align:null},"Mutable")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Not thread-safe"),(0,r.kt)("td",{parentName:"tr",align:null},"Thread-safe but not synchronized"),(0,r.kt)("td",{parentName:"tr",align:null},"Thread-safe and synchronized")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Fast for simple operations"),(0,r.kt)("td",{parentName:"tr",align:null},"Slow for simple operations"),(0,r.kt)("td",{parentName:"tr",align:null},"Slow for simple operations")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Slow for complex operations"),(0,r.kt)("td",{parentName:"tr",align:null},"Fast for complex operations"),(0,r.kt)("td",{parentName:"tr",align:null},"Fast for complex operations")))),(0,r.kt)("p",null,"The value of String, StringBuilder, and StringBuffer is stored in different areas of memory depending on how they are created and used. Generally, the following rules apply:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"String literals, such as ",(0,r.kt)("inlineCode",{parentName:"li"},'"Hello"'),", are stored in the ",(0,r.kt)("strong",{parentName:"li"},"string constant pool"),", which is a special area of the heap memory that stores unique strings that are referenced by the code. The string constant pool helps to save memory and improve performance by reusing the same string objects for multiple references."),(0,r.kt)("li",{parentName:"ul"},"String objects, such as ",(0,r.kt)("inlineCode",{parentName:"li"},'new String("Hello")'),", are stored in the ",(0,r.kt)("strong",{parentName:"li"},"normal heap"),", which is the area of the heap memory that stores regular objects that are created by the ",(0,r.kt)("inlineCode",{parentName:"li"},"new")," keyword. The normal heap is subject to garbage collection, which means that unused objects can be reclaimed by the system to free up memory."),(0,r.kt)("li",{parentName:"ul"},"StringBuilder and StringBuffer objects, such as ",(0,r.kt)("inlineCode",{parentName:"li"},'new StringBuilder("Hello")')," or ",(0,r.kt)("inlineCode",{parentName:"li"},'new StringBuffer("Hello")'),", are also stored in the ",(0,r.kt)("strong",{parentName:"li"},"normal heap"),", but they have an internal ",(0,r.kt)("strong",{parentName:"li"},"character array")," that stores the actual character sequence. The character array can be modified by methods such as ",(0,r.kt)("inlineCode",{parentName:"li"},"append"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"insert"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"delete"),", etc. without creating a new object.")),(0,r.kt)("p",null,"Here is an example of how String, StringBuilder, and StringBuffer are stored in memory:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Creating a string literal\nString s1 = "Hello"; // Stored in the string constant pool\n// Creating another string literal with the same value\nString s2 = "Hello"; // Referencing the same object in the string constant pool\n// Creating a string object with the same value\nString s3 = new String("Hello"); // Stored in the normal heap\n// Creating a string builder object with the same value\nStringBuilder sb = new StringBuilder("Hello"); // Stored in the normal heap with an internal character array\n// Creating a string buffer object with the same value\nStringBuffer sbf = new StringBuffer("Hello"); // Stored in the normal heap with an internal character array\n'))))}p.isMDXComponent=!0},95762:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return u}});var a=n(83117),r=(n(67294),n(3905));const i={},o=void 0,l={unversionedId:"java/hero/exceptions",id:"java/hero/exceptions",title:"exceptions",description:"Types of exceptions in java",source:"@site/docs/java/hero/exceptions.md",sourceDirName:"java/hero",slug:"/java/hero/exceptions",permalink:"/devviews/interviews/java/hero/exceptions",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/java/hero/exceptions.md",tags:[],version:"current",frontMatter:{},sidebar:"javaInterviewSidebar",previous:{title:"concurrency",permalink:"/devviews/interviews/java/hero/concurrency"},next:{title:"thread",permalink:"/devviews/interviews/java/hero/thread"}},s={},u=[],c={toc:u},d="wrapper";function p(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Types of exceptions in java")),(0,r.kt)("p",null,"Exceptions are events that occur during the execution of a program and disrupt the normal flow of instructions. Exceptions can be classified into two main types: ",(0,r.kt)("strong",{parentName:"p"},"checked exceptions")," and ",(0,r.kt)("strong",{parentName:"p"},"unchecked exceptions"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Checked exceptions")," are exceptions that are ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"checked by the compiler at compile-time")),". They represent conditions that are ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"outside the control of the program")),", such as file not found, network error, invalid input, etc. Checked exceptions must be either handled by the program using ",(0,r.kt)("inlineCode",{parentName:"li"},"try-catch")," blocks or declared in the ",(0,r.kt)("inlineCode",{parentName:"li"},"throws")," clause of the method that may cause them. Examples of checked exceptions are IOException, SQLException, ClassNotFoundException, etc."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Unchecked exceptions")," are exceptions that are ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"runtime exceptions"))," - ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"not checked by the compiler at compile-time")),". They represent conditions that are caused by the program ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"logic errors")),", such as null pointer dereference, array index out of bounds, arithmetic exception, etc. Unchecked exceptions do not need to be handled or declared by the program, but they can be caught and handled if desired. Examples of unchecked exceptions are RuntimeException and its subclasses, such as NullPointerException, ArithmeticException, IndexOutOfBoundsException, etc.")),(0,r.kt)("p",null,"Another type of exception is ",(0,r.kt)("strong",{parentName:"p"},"error"),", which is a subclass of Throwable class, just like Exception class. Errors are also unchecked exceptions, but they represent conditions that are beyond the control and recovery of the program, such as system crash, memory overflow, stack overflow, etc. Errors are usually not handled by the program, but they can be caught and logged if needed. Examples of errors are Error and its subclasses, such as OutOfMemoryError, StackOverflowError, VirtualMachineError, etc."),(0,r.kt)("p",null,"Here is an example of using different types of exceptions in Java:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// A checked exception\nclass CheckedExceptionDemo {\n  public static void main(String[] args) {\n    try {\n      // This may throw a FileNotFoundException\n      File file = new File("test.txt");\n      Scanner sc = new Scanner(file);\n      while (sc.hasNextLine()) {\n        System.out.println(sc.nextLine());\n      }\n      sc.close();\n    } catch (FileNotFoundException e) {\n      // Handle the exception\n      System.out.println("File not found");\n    }\n  }\n}\n\n// An unchecked exception\nclass UncheckedExceptionDemo {\n  public static void main(String[] args) {\n    // This may throw an ArithmeticException\n    int a = 10;\n    int b = 0;\n    int c = a / b; // Divide by zero\n    System.out.println(c);\n  }\n}\n\n// An error\nclass ErrorDemo {\n  public static void main(String[] args) {\n    // This may throw a StackOverflowError\n    recursiveMethod(); // Call itself infinitely\n  }\n\n  public static void recursiveMethod() {\n    recursiveMethod();\n  }\n}\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Explain about Exception Propagation")),(0,r.kt)("p",null,"Exception propagation in Java is a process in which an exception that occurs in a method is passed to the caller method if it is not handled in the current method. This way, the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"exception can be propagated up the call stack until it reaches a method that can handle it"))," or the main method. Exception propagation allows the separation of error handling logic from the normal business logic."),(0,r.kt)("p",null,"By default, ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"only unchecked exceptions (RuntimeException and its subclasses) are propagated in Java")),". Checked exceptions (Exception and its subclasses except RuntimeException) must be either handled in the current method using ",(0,r.kt)("inlineCode",{parentName:"p"},"try-catch")," blocks or declared in the ",(0,r.kt)("inlineCode",{parentName:"p"},"throws")," clause of the method signature. If a checked exception is thrown and not handled or declared, the compiler will report an error."),(0,r.kt)("p",null,"Here is an example of exception propagation in Java:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// An unchecked exception\nclass UncheckedExceptionDemo {\n  // This method throws an unchecked exception\n  void m() {\n    // This may throw an ArithmeticException\n    int a = 10;\n    int b = 0;\n    int c = a / b; // Divide by zero\n  }\n\n  // This method calls m() and does not declare or handle the exception\n  void n() {\n    m();\n  }\n\n  // This method calls n() and handles the exception\n  void p() {\n    try {\n      n();\n    } catch (ArithmeticException e) {\n      // Handle the exception\n      System.out.println("Cannot divide by zero");\n    }\n  }\n\n  public static void main(String[] args) {\n    UncheckedExceptionDemo obj = new UncheckedExceptionDemo();\n    obj.p();\n    System.out.println("Normal flow");\n  }\n}\n')),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Call Stack"),(0,r.kt)("th",{parentName:"tr",align:null},"Exception"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"m()"),(0,r.kt)("td",{parentName:"tr",align:null},"ArithmeticException")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"n()"),(0,r.kt)("td",{parentName:"tr",align:null},"ArithmeticException")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"p()"),(0,r.kt)("td",{parentName:"tr",align:null},"ArithmeticException (handled)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"main()"),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("p",null,"If an exception occurs in the ",(0,r.kt)("inlineCode",{parentName:"p"},"m()")," method is not caught, then it moves to the method ",(0,r.kt)("inlineCode",{parentName:"p"},"n()"),", then ",(0,r.kt)("inlineCode",{parentName:"p"},"p()"),". Then it is moved to the ",(0,r.kt)("inlineCode",{parentName:"p"},"main()")," method and then it will stop the flow of execution."),(0,r.kt)("p",null,"In case of Checked Exception, you must either handled (using ",(0,r.kt)("inlineCode",{parentName:"p"},"try"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"catch"),") or declared by the method that may cause it (using ",(0,r.kt)("inlineCode",{parentName:"p"},"throws"),"). "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// A checked exception\nclass CheckedExceptionDemo {\n  // This method throws a checked exception\n  void m() throws IOException {\n    // This may throw an IOException\n    FileReader fr = new FileReader("test.txt");\n  }\n\n  // This method calls m() and declares the exception\n  void n() throws IOException {\n    m();\n  }\n\n  // This method calls n() and handles the exception\n  void p() {\n    try {\n      n();\n    } catch (IOException e) {\n      // Handle the exception\n      System.out.println("File not found");\n    }\n  }\n\n  public static void main(String[] args) {\n    CheckedExceptionDemo obj = new CheckedExceptionDemo();\n    obj.p();\n    System.out.println("Normal flow");\n  }\n}\n')),(0,r.kt)("p",null,"If the ",(0,r.kt)("inlineCode",{parentName:"p"},"m()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"n()")," method does not handle the exception, then it must declare it in the ",(0,r.kt)("inlineCode",{parentName:"p"},"throws")," clause of its signature.")))}p.isMDXComponent=!0},41032:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return u}});var a=n(83117),r=(n(67294),n(3905));const i={sidebar_position:1e3,sidebar_label:"Functional Interface",title:"Functional Interface",tags:["Java Knowledge"]},o=void 0,l={unversionedId:"java/hero/funtional-interface",id:"java/hero/funtional-interface",title:"Functional Interface",description:"Functional Interface",source:"@site/docs/java/hero/funtional-interface.md",sourceDirName:"java/hero",slug:"/java/hero/funtional-interface",permalink:"/devviews/interviews/java/hero/funtional-interface",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/java/hero/funtional-interface.md",tags:[{label:"Java Knowledge",permalink:"/devviews/interviews/tags/java-knowledge"}],version:"current",sidebarPosition:1e3,frontMatter:{sidebar_position:1e3,sidebar_label:"Functional Interface",title:"Functional Interface",tags:["Java Knowledge"]},sidebar:"javaInterviewSidebar",previous:{title:"Data Structure",permalink:"/devviews/interviews/java/hero/data-structure"},next:{title:"How Java Works",permalink:"/devviews/interviews/java/hero/how-java-works"}},s={},u=[],c={toc:u},d="wrapper";function p(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Functional Interface")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"A functional interface")," can have any number of default or static methods, but only one abstract method. A functional interface can also declare methods of the Object class, such as equals or toString. A functional interface is also known as a ",(0,r.kt)("strong",{parentName:"p"},"Single Abstract Method (SAM) interface"),"."),(0,r.kt)("p",null,"A functional interface can be annotated with ",(0,r.kt)("inlineCode",{parentName:"p"},"@FunctionalInterface")," annotation. However, this annotation is not mandatory, and the compiler will treat any interface with one abstract method as a functional interface."),(0,r.kt)("p",null,"A functional interface ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"can be used as the target type of a lambda expression"))," or a method reference, which are concise ways of creating ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"anonymous"))," implementations of the interface. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// A functional interface with one abstract method\n@FunctionalInterface\ninterface Greeting {\n    void sayHello(String name);\n}\n\n// A lambda expression that implements the interface\nGreeting greeting = name -> System.out.println("Hello, " + name);\n\n// A method reference that implements the interface\nGreeting greeting2 = System.out::println;\n\n// Calling the abstract method using the lambda expression\ngreeting.sayHello("John");\n\n// Calling the abstract method using the method reference\ngreeting2.sayHello("Jane");\n')),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"Hello, John\nJane\n")),(0,r.kt)("p",null,"Some examples of functional interfaces in Java are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Runnable"),": Represents an action that can be run ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"without any argument")),"s and ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"returns no result")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Predicate<T>"),": Represents a ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"boolean-valued function"))," of ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"one argument")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Function<T,R>"),": Represents a function that accepts ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"one argumen")),"t and produces ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"a result."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Consumer<T>"),": Represents an operation that accepts ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"one argument"))," and returns ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"no result")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Supplier<T>"),": Represents a ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"supplier of results"))," that takes ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"no arguments")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Comparator<T>"),": Represents a comparison function that ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"compares two objects of the same type")),"."))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Predicate")),(0,r.kt)("p",null,"A Predicate in Java is a functional interface that represents a boolean-valued function of one argument. It is defined in the ",(0,r.kt)("inlineCode",{parentName:"p"},"java.util.function")," package."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'Predicate<String> isEmpty = s -> s.isEmpty(); // lambda expression\nPredicate<String> isNull = Objects::isNull; // method reference\nSystem.out.println(isEmpty.test("")); // true\nSystem.out.println(isNull.test(null)); // true\n')),(0,r.kt)("p",null,"A Predicate also has some default methods that can be used to compose more complex predicates from existing ones. These methods are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"and")," (Predicate other): returns a predicate that represents the logical AND of this predicate and another."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"or")," (Predicate other): returns a predicate that represents the logical OR of this predicate and another."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"negate"),": returns a predicate that represents the logical negation of this predicate.")),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'Predicate<String> isNotNull = isNull.negate(); // not null\nPredicate<String> isNotEmpty = isEmpty.negate(); // not empty\nPredicate<String> isNotNullOrEmpty = isNotNull.and(isNotEmpty); // not null and not empty\nSystem.out.println(isNotNullOrEmpty.test("Hello")); // true\nSystem.out.println(isNotNullOrEmpty.test(null)); // false\nSystem.out.println(isNotNullOrEmpty.test("")); // false\n')),(0,r.kt)("p",null,"A Predicate also has a static method ",(0,r.kt)("inlineCode",{parentName:"p"},"isEqual(Object targetRef)")," that returns a predicate that tests if two arguments are equal according to ",(0,r.kt)("inlineCode",{parentName:"p"},"Objects.equals(Object, Object)"),". For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'Predicate<String> isEqualToHello = Predicate.isEqual("Hello"); // equal to "Hello"\nSystem.out.println(isEqualToHello.test("Hello")); // true\nSystem.out.println(isEqualToHello.test("World")); // false\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Runnable")),(0,r.kt)("p",null,"Runnable is a functional interface that has a single abstract method run () that takes no arguments and returns no result. Runnable is ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"used to create a task that can run in parallel with the main thread or other threads")),"."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Create a Runnable object using a lambda expression\nRunnable task = () -> {\n    // Task logic\n    System.out.println("Hello from " + Thread.currentThread().getName());\n};\n\n// Create a Thread object and pass the Runnable object\nThread thread = new Thread(task);\n\n// Start the thread\nthread.start();\n\n// Output: Hello from Thread-0\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Callable")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Callable")," is an interface that represents a task that can be executed by a thread in Java. It has a single method ",(0,r.kt)("inlineCode",{parentName:"p"},"call()")," that defines the logic of the task and returns a value or throws an exception."),(0,r.kt)("p",null,"Some of the features and benefits of using Callable are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Callable")," is a generic interface, so it can accept and return any type of value. It is suitable for tasks that need to produce a result or handle a checked exception."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Callable")," was introduced in Java 1.5 as an ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"improvement over ",(0,r.kt)("inlineCode",{parentName:"em"},"Runnable"))),", which does not return any value or throw any checked exception."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Callable")," instances can be combined with ",(0,r.kt)("inlineCode",{parentName:"li"},"Future")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"FutureTask")," classes to obtain the result of the task asynchronously and cancel the task if needed.")),(0,r.kt)("p",null,"Here is an example of creating and running a Callable task using a lambda expression:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Create a Callable task\nCallable<Integer> task = () -> {\n    // Do some work\n    return 42;\n};\n\n// Run the task using an ExecutorService\nExecutorService executor = Executors.newSingleThreadExecutor();\nFuture<Integer> future = executor.submit(task);\nexecutor.shutdown();\n\n// Get the result of the task\ntry {\n    Integer result = future.get();\n    System.out.println("Result: " + result);\n} catch (InterruptedException | ExecutionException e) {\n    e.printStackTrace();\n}\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Function")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Function<T,R> "),"functional interface in Java is an interface that represents a function that accepts one argument of type T and produces a result of type R."),(0,r.kt)("p",null,"The functions of Function<T,R> interface are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"apply(T t)"),": This is the abstract method that takes an argument of type T and returns a value of type R. It defines the logic of the function."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"andThen(Function<? super R,? extends V> after)"),": This is a default method that returns a composed function that first applies this function to its input, and then applies the after function to the result. It can be used to chain multiple functions together."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"compose(Function<? super V,? extends T> before)"),": This is a default method that returns a composed function that first applies the before function to its input, and then applies this function to the result. It can be used to create a function from other functions."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"identity()"),": This is a static method that returns a function that always returns its input argument. It can be used as a no-op function.")),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Import the Function interface\nimport java.util.function.Function;\n\n// Create some Function objects using lambda expressions\nFunction<String, Integer> lengthFunction = s -> s.length(); // returns the length of a string\nFunction<Integer, Integer> squareFunction = x -> x * x; // returns the square of an integer\nFunction<String, String> upperFunction = s -> s.toUpperCase(); // returns the upper case of a string\n\n// Apply the functions to some arguments\nSystem.out.println(lengthFunction.apply("Hello")); // 5\nSystem.out.println(squareFunction.apply(4)); // 16\nSystem.out.println(upperFunction.apply("world")); // WORLD\n\n// Compose the functions using andThen and compose methods\nFunction<String, Integer> lengthSquareFunction = lengthFunction.andThen(squareFunction); // returns the square of the length of a string\nFunction<Integer, String> squareUpperFunction = squareFunction.andThen(upperFunction); // returns the upper case of the square of an integer\nFunction<String, String> upperLengthFunction = lengthFunction.compose(upperFunction); // returns the length of the upper case of a string\n\n// Apply the composed functions to some arguments\nSystem.out.println(lengthSquareFunction.apply("Hello")); // 25\nSystem.out.println(squareUpperFunction.apply(4)); // 16\nSystem.out.println(upperLengthFunction.apply("world")); // 5\n\n// Use the identity function\nFunction<String, String> identityFunction = Function.identity(); // returns the same string\nSystem.out.println(identityFunction.apply("Hello")); // Hello\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Consumer")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Consumer<T>")," is a functional interface that represents an operation that ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"accepts/comsumes"))," a single input argument of type T and returns no result."),(0,r.kt)("p",null,"The functions of ",(0,r.kt)("inlineCode",{parentName:"p"},"Consumer<T>")," interface are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"accept(T t)"),": This is the abstract method that takes an argument of type T and performs some action on it. It defines the logic of the operation."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"andThen(Consumer<? super T> after)"),": This is a default method that returns a composed consumer that performs this operation followed by the after operation. It can be used to ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"chain multiple consumers together")),"."),(0,r.kt)("li",{parentName:"ul"},"For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Import the Consumer interface\nimport java.util.function.Consumer;\n\n// Create some Consumer objects using lambda expressions\nConsumer<String> printConsumer = s -> System.out.println(s); // prints a string\nConsumer<String> lengthConsumer = s -> System.out.println(s.length()); // prints the length of a string\nConsumer<String> upperConsumer = s -> System.out.println(s.toUpperCase()); // prints the upper case of a string\n\n// Apply the consumers to an argument\nprintConsumer.accept("Hello"); // Hello\nlengthConsumer.accept("Hello"); // 5\nupperConsumer.accept("Hello"); // HELLO\n\n// Compose the consumers using andThen method\nConsumer<String> printLengthConsumer = printConsumer.andThen(lengthConsumer); // prints a string and its length\nConsumer<String> printUpperConsumer = printConsumer.andThen(upperConsumer); // prints a string and its upper case\nConsumer<String> printLengthUpperConsumer = printConsumer.andThen(lengthConsumer).andThen(upperConsumer); // prints a string, its length and its upper case\n\n// Apply the composed consumers to an argument\nprintLengthConsumer.accept("Hello"); // Hello 5\nprintUpperConsumer.accept("Hello"); // Hello HELLO\nprintLengthUpperConsumer.accept("Hello"); // Hello 5 HELLO\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Supplier")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Supplier<T>")," is a functional interface that represents ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"a supplier of results"))," (it produces/supplies result). It is a functional interface that ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"has a single abstract method ",(0,r.kt)("inlineCode",{parentName:"em"},"get()")))," that takes no arguments and returns a value of type T."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Import the Supplier interface\nimport java.util.function.Supplier;\n\n// Create a Supplier object using a lambda expression\nSupplier<String> helloSupplier = () -> "Hello";\n\n// Get the result from the supplier\nString result = helloSupplier.get();\n\n// Print the result\nSystem.out.println(result);\n\n// Output: Hello\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Comparator")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Comparator<T>")," is a functional interface that represents ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"a comparison function that compares two objects of the same type")),"."),(0,r.kt)("p",null,"The functions of ",(0,r.kt)("inlineCode",{parentName:"p"},"Comparator<T>")," interface are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"compare(T o1, T o2)"),": This is the abstract method that takes two arguments of type T and returns an int value that indicates their order. It ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"defines the logic of the comparison function")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"reversed()"),": This is a default method that returns a comparator that imposes the reverse order of this comparator. It can be used to sort a collection in descending order."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"thenComparing(Comparator<? super T> other)"),": This is a default method that returns a lexicographic-order comparator that compares two objects by first applying this comparator and then applying the other comparator if the first comparison is equal. It can be used to sort a collection by multiple criteria."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"naturalOrder()"),": This is a static method that returns a comparator that compares two objects according to their natural order. It can be used to sort a collection of objects that implement Comparable interface."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"nullsFirst(Comparator<? super T> comparator)"),": This is a static method that returns a comparator that considers null values to be less than any non-null values and compares non-null values using the specified comparator. It can be used to sort a collection that may contain null values.")),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Import the Comparator interface\nimport java.util.Comparator;\n\n// Create some Comparator objects using lambda expressions\nComparator<String> lengthComparator = (s1, s2) -> s1.length() - s2.length(); // compares two strings by their lengths\nComparator<String> alphaComparator = (s1, s2) -> s1.compareTo(s2); // compares two strings by their alphabetical order\nComparator<String> reverseComparator = lengthComparator.reversed(); // reverses the order of lengthComparator\nComparator<String> lengthAlphaComparator = lengthComparator.thenComparing(alphaComparator); // compares two strings by their lengths and then by their alphabetical order\nComparator<String> naturalComparator = Comparator.naturalOrder(); // compares two strings by their natural order\nComparator<String> nullsFirstComparator = Comparator.nullsFirst(lengthComparator); // compares two strings by their lengths and considers null values to be less than any non-null values\n\n// Compare some strings using the comparators\nSystem.out.println(lengthComparator.compare("Hello", "World")); // 0\nSystem.out.println(alphaComparator.compare("Hello", "World")); // -15\nSystem.out.println(reverseComparator.compare("Hello", "World")); // 0\nSystem.out.println(lengthAlphaComparator.compare("Hello", "World")); // -15\nSystem.out.println(naturalComparator.compare("Hello", "World")); // -15\nSystem.out.println(nullsFirstComparator.compare("Hello", null)); // 1\n'))))}p.isMDXComponent=!0},42002:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return u}});var a=n(83117),r=(n(67294),n(3905));const i={sidebar_position:1e3,sidebar_label:"How Java Works",title:"How Java Works",tags:["Java Knowledge"]},o=void 0,l={unversionedId:"java/hero/how-java-works",id:"java/hero/how-java-works",title:"How Java Works",description:"How Java Works",source:"@site/docs/java/hero/how-java-works.md",sourceDirName:"java/hero",slug:"/java/hero/how-java-works",permalink:"/devviews/interviews/java/hero/how-java-works",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/java/hero/how-java-works.md",tags:[{label:"Java Knowledge",permalink:"/devviews/interviews/tags/java-knowledge"}],version:"current",sidebarPosition:1e3,frontMatter:{sidebar_position:1e3,sidebar_label:"How Java Works",title:"How Java Works",tags:["Java Knowledge"]},sidebar:"javaInterviewSidebar",previous:{title:"Functional Interface",permalink:"/devviews/interviews/java/hero/funtional-interface"},next:{title:"How JVM Works",permalink:"/devviews/interviews/java/hero/how-jvm-works"}},s={},u=[],c={toc:u},d="wrapper";function p(e){let{components:t,...i}=e;return(0,r.kt)(d,(0,a.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"How Java Works")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"How Java Works",src:n(64438).Z,width:"3907",height:"2348"})),(0,r.kt)("p",null,"Java is a programming language that works by following these steps:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A programmer writes a Java source code file with a .java extension, such as Program.java."),(0,r.kt)("li",{parentName:"ul"},"The Java compiler (javac) converts the source code into bytecode, which is a platform-independent representation of the program. The bytecode file has a .class extension, such as Program.class."),(0,r.kt)("li",{parentName:"ul"},"The Java Virtual Machine (JVM) interprets the bytecode and executes it on the underlying hardware. The JVM is a software layer that provides an abstract interface between the bytecode and the operating system. The JVM can run on any device that has a compatible version of it installed."),(0,r.kt)("li",{parentName:"ul"},"The JVM also performs various tasks such as memory management, garbage collection, security checks, exception handling, etc. to ensure the smooth and efficient execution of the program.")),(0,r.kt)("p",null,'This is how Java works and enables the "write once, run anywhere" feature. Java programs can run on any device that has a JVM, regardless of the hardware or operating system differences.')))}p.isMDXComponent=!0},70007:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return u}});var a=n(83117),r=(n(67294),n(3905));const i={sidebar_position:1e3,sidebar_label:"How JVM Works",title:"How JVM Works",tags:["Java Knowledge"]},o=void 0,l={unversionedId:"java/hero/how-jvm-works",id:"java/hero/how-jvm-works",title:"How JVM Works",description:"How JVM Works",source:"@site/docs/java/hero/how-jvm-works.md",sourceDirName:"java/hero",slug:"/java/hero/how-jvm-works",permalink:"/devviews/interviews/java/hero/how-jvm-works",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/java/hero/how-jvm-works.md",tags:[{label:"Java Knowledge",permalink:"/devviews/interviews/tags/java-knowledge"}],version:"current",sidebarPosition:1e3,frontMatter:{sidebar_position:1e3,sidebar_label:"How JVM Works",title:"How JVM Works",tags:["Java Knowledge"]},sidebar:"javaInterviewSidebar",previous:{title:"How Java Works",permalink:"/devviews/interviews/java/hero/how-java-works"},next:{title:"Innerclass",permalink:"/devviews/interviews/java/hero/innerclass"}},s={},u=[],c={toc:u},d="wrapper";function p(e){let{components:t,...i}=e;return(0,r.kt)(d,(0,a.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"How JVM Works")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"How JVM Works",src:n(76302).Z,width:"818",height:"845"})),(0,r.kt)("p",null,"JVM (Java Virtual Machine) is a software layer that provides a runtime environment for Java applications. It works by performing the following steps:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"It loads the Java bytecode (the .class files) into the memory using a ",(0,r.kt)("strong",{parentName:"li"},"class loader subsystem"),". The class loader subsystem consists of ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"three phases")),": ",(0,r.kt)("strong",{parentName:"li"},"loading"),", ",(0,r.kt)("strong",{parentName:"li"},"linking"),", and ",(0,r.kt)("strong",{parentName:"li"},"initialization"),". ",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"It reads the bytecode and stores the ",(0,r.kt)("strong",{parentName:"li"},"class information")," (like class name, immediate parent class name, methods and variables information etc. are stored, including static variables.\n) in the method area. "),(0,r.kt)("li",{parentName:"ul"},"It also creates an ",(0,r.kt)("strong",{parentName:"li"},"object of type Class")," (All the Objects and their corresponding instance variables and arrays) for each loaded class in the heap memory."))),(0,r.kt)("li",{parentName:"ul"},"It executes the bytecode using an execution engine. The ",(0,r.kt)("strong",{parentName:"li"},"execution engine")," consists of an interpreter and a just-in-time (JIT) compiler. The ",(0,r.kt)("strong",{parentName:"li"},"interpreter")," reads and executes the bytecode instructions one by one. The ",(0,r.kt)("strong",{parentName:"li"},"JIT compiler")," optimizes the performance by compiling frequently executed parts of the bytecode into native machine code."),(0,r.kt)("li",{parentName:"ul"},"It manages the memory using various areas such as ",(0,r.kt)("strong",{parentName:"li"},"heap"),", ",(0,r.kt)("strong",{parentName:"li"},"stack"),", ",(0,r.kt)("strong",{parentName:"li"},"method area"),", etc. It also performs garbage collection to reclaim the unused memory space. It allocates memory for objects and variables and stores them in the heap and stack respectively. It also stores static data and class information in the method area."),(0,r.kt)("li",{parentName:"ul"},"It handles various tasks such as exception handling, security checks, thread synchronization, etc. It also interacts with the native libraries and operating system using a native method interface (JNI) and a native method library.")),(0,r.kt)("p",null,"This is how JVM works in Java and enables the cross-platform compatibility of Java applications. JVM can run on any device that has a compatible version of it installed.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"loading, linking, and initialization")),"The three phases of class loading in Java are:",(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Loading"),": This is ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"the process of finding the binary representation (bytecode)"))," of a class or interface with a particular name and creating a Class object from that. The class loader subsystem reads the .class file and stores the class information in the method area. It also creates an object of type Class for each loaded class in the heap memory. There are three built-in class loaders in Java: bootstrap, extension, and application. ",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The bootstrap class loader ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"loads the core Java classes"))," from the ",(0,r.kt)("inlineCode",{parentName:"li"},"rt.jar")," file. "),(0,r.kt)("li",{parentName:"ul"},"The extension class loader ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"loads the classes that are extensions of the core Java classes"))," from the ",(0,r.kt)("inlineCode",{parentName:"li"},"ext")," directory. "),(0,r.kt)("li",{parentName:"ul"},"The application class loader ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"loads the classes that are specific to the application"))," from the ",(0,r.kt)("inlineCode",{parentName:"li"},"classpath"),"."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Linking"),": This is ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"the process of taking a Class object and combining it"))," into the runtime state of the JVM so that it can be executed. Linking consists of three sub-phases: verification, preparation, and resolution. ",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Verification")," checks that the bytecode is well-formed and adheres to the language rules. "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Preparation")," allocates memory for static fields and assigns default values to them. "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Resolution")," resolves symbolic references to other classes, fields, and methods in the constant pool to direct references."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Initialization"),": This is ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"the process of executing"))," the static initializers and initializers for static fields of a class or interface. Initialization is triggered by the first active use of a class or interface, such as creating an instance, invoking a static method, accessing a static field, etc. Initialization invokes the ",(0,r.kt)("inlineCode",{parentName:"li"},"<clinit>")," method of a class or interface, which contains all the static initialization code.")),(0,r.kt)("p",null,"These are the three phases of class loading in Java that ensure that a class or interface is ready to be used by the JVM.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"method erea vs heap vs stack")),(0,r.kt)("p",null,"Method area, heap, and stack are three memory areas used by the JVM to store different types of data. Here is a table that summarizes their main features and differences:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Memory Area"),(0,r.kt)("th",{parentName:"tr",align:null},"Purpose"),(0,r.kt)("th",{parentName:"tr",align:null},"Content"),(0,r.kt)("th",{parentName:"tr",align:null},"Scope"),(0,r.kt)("th",{parentName:"tr",align:null},"Size"),(0,r.kt)("th",{parentName:"tr",align:null},"Access"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Method area"),(0,r.kt)("td",{parentName:"tr",align:null},"To store class structures and metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"Runtime constant pool, field and method data, code for methods, etc."),(0,r.kt)("td",{parentName:"tr",align:null},"Shared by all threads"),(0,r.kt)("td",{parentName:"tr",align:null},"No fixed size, can grow or shrink as needed"),(0,r.kt)("td",{parentName:"tr",align:null},"By reference")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Heap"),(0,r.kt)("td",{parentName:"tr",align:null},"To store objects and class instances"),(0,r.kt)("td",{parentName:"tr",align:null},"Objects, arrays, instance variables, etc."),(0,r.kt)("td",{parentName:"tr",align:null},"Shared by all threads"),(0,r.kt)("td",{parentName:"tr",align:null},"No fixed size, can grow or shrink as needed"),(0,r.kt)("td",{parentName:"tr",align:null},"By reference")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Stack"),(0,r.kt)("td",{parentName:"tr",align:null},"To store local variables and method calls"),(0,r.kt)("td",{parentName:"tr",align:null},"Primitive values, references to objects in heap, method frames, etc."),(0,r.kt)("td",{parentName:"tr",align:null},"Private to each thread"),(0,r.kt)("td",{parentName:"tr",align:null},"Fixed size, can cause overflow or underflow errors if exceeded or unused"),(0,r.kt)("td",{parentName:"tr",align:null},"By value")))),(0,r.kt)("p",null,"Heap and stack in JVM are similar to data structures in some ways, but they are not exactly the same. Heap and stack are memory areas that store data in a specific way, while data structures are abstract models that define how data can be organized and manipulated.")))}p.isMDXComponent=!0},68368:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return u}});var a=n(83117),r=(n(67294),n(3905));const i={sidebar_position:1e3,sidebar_label:"Innerclass",title:"Innerclass",tags:["Java Knowledge"]},o=void 0,l={unversionedId:"java/hero/innerclass",id:"java/hero/innerclass",title:"Innerclass",description:"Innerclass",source:"@site/docs/java/hero/innerclass.md",sourceDirName:"java/hero",slug:"/java/hero/innerclass",permalink:"/devviews/interviews/java/hero/innerclass",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/java/hero/innerclass.md",tags:[{label:"Java Knowledge",permalink:"/devviews/interviews/tags/java-knowledge"}],version:"current",sidebarPosition:1e3,frontMatter:{sidebar_position:1e3,sidebar_label:"Innerclass",title:"Innerclass",tags:["Java Knowledge"]},sidebar:"javaInterviewSidebar",previous:{title:"How JVM Works",permalink:"/devviews/interviews/java/hero/how-jvm-works"},next:{title:"Scopes In Java",permalink:"/devviews/interviews/java/hero/scope"}},s={},u=[],c={toc:u},d="wrapper";function p(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Innerclass")),(0,r.kt)("p",null,"An inner class is a class that is defined inside another class or interface. The purpose of inner classes is to group classes that are logically related, to improve readability and maintainability, and to increase encapsulation and access control."),(0,r.kt)("p",null,"There are four types of inner classes in Java:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Syntax"),(0,r.kt)("th",{parentName:"tr",align:null},"Access to members of outer class"),(0,r.kt)("th",{parentName:"tr",align:null},"Requires instance of outer class"),(0,r.kt)("th",{parentName:"tr",align:null},"Can be declared abstract or final"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Member inner class"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"class OuterClass { class InnerClass { } }")),(0,r.kt)("td",{parentName:"tr",align:null},"Yes, both static and non-static"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes, using ",(0,r.kt)("inlineCode",{parentName:"td"},"OuterClass.InnerClass inner = outer.new InnerClass();")),(0,r.kt)("td",{parentName:"tr",align:null},"Yes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Local inner class"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"class OuterClass { void someMethod() { class LocalClass { } } }")),(0,r.kt)("td",{parentName:"tr",align:null},"Yes, both static and non-static (final or effectively final)"),(0,r.kt)("td",{parentName:"tr",align:null},"No, but can only be instantiated within the method"),(0,r.kt)("td",{parentName:"tr",align:null},"No")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Static nested class"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"class OuterClass { static class NestedClass { } }")),(0,r.kt)("td",{parentName:"tr",align:null},"Only static members of outer class"),(0,r.kt)("td",{parentName:"tr",align:null},"No, using ",(0,r.kt)("inlineCode",{parentName:"td"},"OuterClass.NestedClass nested = new OuterClass.NestedClass();")),(0,r.kt)("td",{parentName:"tr",align:null},"Yes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Anonymous inner class"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"class OuterClass { SomeInterface obj = new SomeInterface() { // implement methods here }; }")),(0,r.kt)("td",{parentName:"tr",align:null},"Yes, both static and non-static (final or effectively final)"),(0,r.kt)("td",{parentName:"tr",align:null},"No, but must extend a class or implement an interface"),(0,r.kt)("td",{parentName:"tr",align:null},"No")))),(0,r.kt)("p",null,"Here is an example that demonstrates each type of inner class in Java:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public class OuterClass {\n\n    // a private instance variable\n    private int x = 10;\n\n    // a public static variable\n    public static int y = 20;\n\n    // a member inner class\n    public class MemberInnerClass {\n        // a method of the member inner class\n        public void print() {\n            System.out.println("Member inner class: x = " + x);\n        }\n    }\n\n    // a method of the outer class\n    public void display() {\n        // a local variable\n        final int z = 30;\n\n        // a local inner class\n        class LocalInnerClass {\n            // a method of the local inner class\n            public void print() {\n                System.out.println("Local inner class: x = " + x + ", z = " + z);\n            }\n        }\n\n        // creating an object of the local inner class\n        LocalInnerClass lic = new LocalInnerClass();\n        // calling the method of the local inner class\n        lic.print();\n    }\n\n    // a static nested class\n    public static class StaticNestedClass {\n        // a method of the static nested class\n        public void print() {\n            System.out.println("Static nested class: y = " + y);\n        }\n    }\n\n    // a method that returns an anonymous inner class that implements an interface\n    public Printable getAnonymousInnerClass() {\n        return new Printable() {\n            @Override\n            public void print() {\n                System.out.println("Anonymous inner class: x = " + x);\n            }\n        };\n    }\n}\n\n// an interface for demonstration purpose\ninterface Printable {\n    void print();\n}\n\n// a test class\npublic class Main {\n\n    public static void main(String[] args) {\n        // creating an object of the outer class\n        OuterClass oc = new OuterClass();\n\n        // creating an object of the member inner class\n        OuterClass.MemberInnerClass mic = oc.new MemberInnerClass();\n        // calling the method of the member inner class\n        mic.print();\n\n        // calling the method of the outer class that contains a local inner class\n        oc.display();\n\n        // creating an object of the static nested class\n        OuterClass.StaticNestedClass snc = new OuterClass.StaticNestedClass();\n        // calling the method of the static nested class\n        snc.print();\n\n        // getting an object of the anonymous inner class that implements Printable interface\n        Printable p = oc.getAnonymousInnerClass();\n        // calling the method of the anonymous inner class\n        p.print();\n    }\n}\n')),(0,r.kt)("p",null,"The output of this program is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Member inner class: x = 10\nLocal inner class: x = 10, z = 30\nStatic nested class: y = 20\nAnonymous inner class: x = 10\n"))))}p.isMDXComponent=!0},94058:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return u}});var a=n(83117),r=(n(67294),n(3905));const i={sidebar_position:1e3,sidebar_label:"Scopes In Java",title:"Scopes In Java",tags:["Java Knowledge"]},o=void 0,l={unversionedId:"java/hero/scope",id:"java/hero/scope",title:"Scopes In Java",description:"Scopes In Java",source:"@site/docs/java/hero/scope.md",sourceDirName:"java/hero",slug:"/java/hero/scope",permalink:"/devviews/interviews/java/hero/scope",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/java/hero/scope.md",tags:[{label:"Java Knowledge",permalink:"/devviews/interviews/tags/java-knowledge"}],version:"current",sidebarPosition:1e3,frontMatter:{sidebar_position:1e3,sidebar_label:"Scopes In Java",title:"Scopes In Java",tags:["Java Knowledge"]},sidebar:"javaInterviewSidebar",previous:{title:"Innerclass",permalink:"/devviews/interviews/java/hero/innerclass"},next:{title:"Thread Safety In Java",permalink:"/devviews/interviews/java/hero/thread-safety"}},s={},u=[{value:"Here is a simple class that uses both types of blocks:",id:"here-is-a-simple-class-that-uses-both-types-of-blocks",level:4}],c={toc:u},d="wrapper";function p(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Scopes In Java")),(0,r.kt)("p",null,"Scope in Java refers to the region of the program where a variable or a method is accessible. Scope determines the visibility and lifetime of a variable or a method."),(0,r.kt)("p",null,"There are three types of scope in Java:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Method scope"),": Variables declared inside a method are only accessible within that method. They are created when the method is invoked and destroyed when the method returns."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Block scope"),": Variables declared inside a block of code (between curly braces) are only accessible within that block. They are created when the block is entered and destroyed when the block is exited."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Class scope"),": Variables declared inside a class (also known as instance variables or fields) are accessible by all methods in that class. They are created when an object of the class is instantiated and destroyed when the object is garbage collected.")),(0,r.kt)("p",null,"In addition to scope, Java also has access modifiers that restrict the accessibility of variables and methods to other classes. There are four access modifiers in Java:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"private"),": The most restrictive modifier. It limits access to variables and methods to the class in which they are declared. It is used to hide implementation details and enforce encapsulation."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"default"),": The modifier that is applied when no other modifier is specified. It allows access to variables and methods only from within the same package."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"protected"),": A modifier that allows access to variables and methods only from within the same package or from subclasses in other packages."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"public"),": The least restrictive modifier. It allows access to variables and methods from anywhere in the program."))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Static Block vs Non-static Block")),(0,r.kt)("p",null,"Static block and non-static block are two types of initializer blocks in Java. They are used to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"initialize variables or execute some code before the constructor is called")),"."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Static Block")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Non-static Block")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"A block of code that is preceded by the static keyword"),(0,r.kt)("td",{parentName:"tr",align:null},"A block of code that is not preceded by any keyword")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Executed only once when the class is loaded into memory"),(0,r.kt)("td",{parentName:"tr",align:null},"Executed every time an object of the class is created")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Can access only static variables and methods"),(0,r.kt)("td",{parentName:"tr",align:null},"Can access both static and instance variables and methods")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Executed before the main method"),(0,r.kt)("td",{parentName:"tr",align:null},"Executed after the super constructor and before the current constructor")))),(0,r.kt)("h4",{id:"here-is-a-simple-class-that-uses-both-types-of-blocks"},"Here is a simple class that uses both types of blocks:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public class Example {\n\n    // a static variable\n    private static int count;\n\n    // a non-static variable\n    private String name;\n\n    // a static block\n    static {\n        System.out.println("Static block is executed");\n        count = 10; // initialize the static variable\n    }\n\n    // a non-static block\n    {\n        System.out.println("Non-static block is executed");\n        name = "Example"; // initialize the non-static variable\n    }\n\n    // a constructor\n    public Example() {\n        System.out.println("Constructor is executed");\n        System.out.println("Name: " + name);\n        System.out.println("Count: " + count);\n    }\n\n    // a main method\n    public static void main(String[] args) {\n        System.out.println("Main method is executed");\n        Example ex1 = new Example(); // create the first object\n        Example ex2 = new Example(); // create the second object\n    }\n}\n')),(0,r.kt)("p",null,"The output of this program is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Static block is executed\nMain method is executed\nNon-static block is executed\nConstructor is executed\nName: Example\nCount: 10\nNon-static block is executed\nConstructor is executed\nName: Example\nCount: 10\n")),(0,r.kt)("p",null,"As you can see, the static block is executed only once when the class is loaded, before the main method. The non-static block is executed twice, once for each object creation, before the constructor. The constructor is also executed twice, once for each object creation, after the non-static block.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Static vs dynamic binding")),(0,r.kt)("p",null,"Static binding and dynamic binding are two types of binding in Java. Binding refers to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"the process of linking a method call with its implementation")),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Static binding")," (also called early binding) is when the compiler resolves the method call ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"at compile time")),". It uses the type information of the reference variable to determine which method to invoke. Static binding is used for private, final, and static methods and variables.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Dynamic binding "),"(also called late binding) is when the JVM resolves the method ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"call at runtime")),". It uses the type information of the actual object to determine which method to invoke. Dynamic binding is used for virtual methods (which are all non-static methods in Java by default)."))),(0,r.kt)("p",null,"The main differences between static binding and dynamic binding are:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Static Binding"),(0,r.kt)("th",{parentName:"tr",align:null},"Dynamic Binding"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Occurs at compile time"),(0,r.kt)("td",{parentName:"tr",align:null},"Occurs at runtime")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Uses reference type"),(0,r.kt)("td",{parentName:"tr",align:null},"Uses object type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Faster"),(0,r.kt)("td",{parentName:"tr",align:null},"Slower")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Supports method overloading"),(0,r.kt)("td",{parentName:"tr",align:null},"Supports method overriding")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Used for private, final, and static methods and variables"),(0,r.kt)("td",{parentName:"tr",align:null},"Used for virtual methods")))),(0,r.kt)("p",null,"Here is an example that demonstrates static binding and dynamic binding in Java:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public class Animal {\n    public static void eat() {\n        System.out.println("Animal eats");\n    }\n\n    public void sleep() {\n        System.out.println("Animal sleeps");\n    }\n}\n\npublic class Dog extends Animal {\n    public static void eat() {\n        System.out.println("Dog eats");\n    }\n\n    @Override\n    public void sleep() {\n        System.out.println("Dog sleeps");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal a1 = new Animal();\n        Animal a2 = new Dog();\n\n        a1.eat(); // static binding\n        a2.eat(); // static binding\n\n        a1.sleep(); // dynamic binding\n        a2.sleep(); // dynamic binding\n    }\n}\n')),(0,r.kt)("p",null,"The output of this program is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Animal eats\nAnimal eats\nAnimal sleeps\nDog sleeps\n")),(0,r.kt)("p",null,"As you can see, the eat() method is resolved by static binding, because it is a static method. The compiler uses the reference type (Animal) to determine which eat() method to call. Therefore, both a1 and a2 invoke the eat() method of Animal class."),(0,r.kt)("p",null,"The sleep() method is resolved by dynamic binding, because it is a virtual method. The JVM uses the object type (Animal or Dog) to determine which sleep() method to call. Therefore, a1 invokes the sleep() method of Animal class, while a2 invokes the sleep() method of Dog class."),(0,r.kt)("p",null,":::note"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"private"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"final")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"static")," methods and variables -> can't be overiden -> ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"use static binding"))," and are bonded by compiler "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"overloaded")," methods are bonded using ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"static binding "))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"overridden"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"virtual")," methods are bonded using ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"dynamic binding"))," at runtime.")),(0,r.kt)("p",null,":::")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Instance initializer block")),(0,r.kt)("p",null,"An instance initializer block in Java is a block of code that is placed inside a class but outside any method or constructor. It is used to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"initialize the instance variables of the class. It runs every time an object of the class is created")),". The Java compiler copies the instance initializer block in every constructor of the class ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"after the first statement ",(0,r.kt)("inlineCode",{parentName:"em"},"super()"))),". For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'class Bike {\n    int speed; // instance variable\n    // instance initializer block\n    {\n        speed = 100;\n    }\n    Bike() {\n        System.out.println("speed is " + speed);\n    }\n    public static void main(String[] args) {\n        Bike b1 = new Bike(); // creates an object and invokes constructor\n        Bike b2 = new Bike(); // creates another object and invokes constructor\n    }\n}\n')),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"speed is 100\nspeed is 100\n"))))}p.isMDXComponent=!0},70031:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return u}});var a=n(83117),r=(n(67294),n(3905));const i={sidebar_position:1e3,sidebar_label:"Thread Safety In Java",title:"Thread Safety In Java",tags:["Java Knowledge"]},o=void 0,l={unversionedId:"java/hero/thread-safety",id:"java/hero/thread-safety",title:"Thread Safety In Java",description:"Thread Safety In Java",source:"@site/docs/java/hero/thread-safety.md",sourceDirName:"java/hero",slug:"/java/hero/thread-safety",permalink:"/devviews/interviews/java/hero/thread-safety",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/java/hero/thread-safety.md",tags:[{label:"Java Knowledge",permalink:"/devviews/interviews/tags/java-knowledge"}],version:"current",sidebarPosition:1e3,frontMatter:{sidebar_position:1e3,sidebar_label:"Thread Safety In Java",title:"Thread Safety In Java",tags:["Java Knowledge"]},sidebar:"javaInterviewSidebar",previous:{title:"Scopes In Java",permalink:"/devviews/interviews/java/hero/scope"},next:{title:"Java Type Conversion",permalink:"/devviews/interviews/java/hero/type-conversion"}},s={},u=[],c={toc:u},d="wrapper";function p(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Thread Safety In Java")),(0,r.kt)("p",null,"Thread safety is a programming methodology that ensures different threads can access the same resources without exposing erroneous behavior or producing unpredictable results."),(0,r.kt)("p",null,"Here are some techniques to ensure thread safety in Java:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Synchronization"),": Synchronization ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"allows only one thread to access"))," the synchronized block or method at a time, thus preventing race conditions.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Volatile keyword"),": Volatile keyword is used to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"prevent the caching of shared variables"))," by different threads.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Atomic operations"),": Atomic operations are thread-safe and ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"guarantee consistency of shared data")),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Locks"),": Lock objects are used to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"protect shared resources from being accessed simultaneously"))," by multiple threads.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Immutable objects"),": Immutable objects ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"cannot be changed once created")),", so they are inherently thread-safe.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Thread-safe collections"),": Concurrent collections provided by Java's ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Concurrent"))," Collections Framework are thread-safe and can be used for shared resources."))),(0,r.kt)("p",null,"It is important to note that ensuring thread safety in Java code is not a one-size-fits-all solution, and the choice of technique will depend on the specific requirements of the application.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Synchronization (Common resources can only be acessed synchronously)")),(0,r.kt)("p",null,"Synchronization ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"ensures that only one thread can execute a block of code or a method at a time")),", and that any changes made by that thread are visible to other threads. This way, you can avoid race conditions and memory inconsistency errors that can lead to incorrect or unpredictable results."),(0,r.kt)("p",null,"For example, suppose you have a class that represents a bank account with a balance field and a deposit method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class BankAccount {\n    private int balance;\n\n    public BankAccount(int initialBalance) {\n        this.balance = initialBalance;\n    }\n\n    public int getBalance() {\n        return balance;\n    }\n\n    public void deposit(int amount) {\n        balance += amount;\n    }\n}\n")),(0,r.kt)("p",null,"If there're two threads try to deposit at the same time:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Thread 1: balance = 1000\nThread 2: balance = 1000\nThread 1: deposit(100)\nThread 2: deposit(200)\nThread 1: balance = 1000 + 100 = 1100\nThread 2: balance = 1000 + 200 = 1200\nFinal balance: 1200\n")),(0,r.kt)("p",null,"The expected final balance should be 1300, but because of the race condition, we lost 100. To avoid this problem, we can use synchronization to make the deposit method thread-safe:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class BankAccount {\n    private int balance;\n\n    public BankAccount(int initialBalance) {\n        this.balance = initialBalance;\n    }\n\n    public synchronized int getBalance() {\n        return balance;\n    }\n\n    public synchronized void deposit(int amount) {\n        balance += amount;\n    }\n}\n")),(0,r.kt)("p",null,"Now, only one thread can enter the deposit method at a time, and any changes made by that thread will be visible to other threads. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Thread 1: balance = 1000\nThread 2: tries to enter deposit, but blocked by Thread 1\nThread 1: deposit(100)\nThread 1: balance = 1000 + 100 = 1100\nThread 1: exits deposit\nThread 2: enters deposit\nThread 2: balance = 1100\nThread 2: deposit(200)\nThread 2: balance = 1100 + 200 = 1300\nThread 2: exits deposit\nFinal balance: 1300\n")),(0,r.kt)("p",null,"The final balance is correct and consistent. This is how synchronization can help achieve thread-safety in Java.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"volatile (Common resource is like one common state for all threads)")),(0,r.kt)("p",null,'The word "volatile" means something that can change quickly and unpredictably. In Java, the volatile keyword is used to indicate that a variable ',(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"can be changed by different threads at any time")),", and that the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"compiler should not cache its value"))," or reorder its operations. The volatile keyword ensures that ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"all threads see a consistent value for the variable")),"."),(0,r.kt)("p",null,"One example of using the volatile keyword is when you have a boolean flag that controls the execution of a thread, such as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public class VolatileExample extends Thread {\n    private volatile boolean running = true;\n\n    public void run() {\n        while (running) {\n            System.out.println("Running");\n        }\n        System.out.println("Stopped");\n    }\n\n    public void stopThread() {\n        running = false;\n    }\n}\n')),(0,r.kt)("p",null,"In this example, the running variable is declared as volatile, so that when the ",(0,r.kt)("inlineCode",{parentName:"p"},"stopThread()")," method is called by another thread, the change will be visible to the thread that is executing the ",(0,r.kt)("inlineCode",{parentName:"p"},"run()")," method. If the running variable was not volatile, there is a possibility that the thread would not see the updated value and continue running indefinitely.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Atomic (Common resources is single unit of work)")),(0,r.kt)("p",null,"Atomic operations are operations that are performed as a ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"single unit of work"))," without the possibility of interference from other operations. Atomic operations are useful in multithreaded environments where you want to avoid race conditions and ensure data integrity."),(0,r.kt)("p",null,"One example of using atomic operations in Java is to use the classes in the java.util.concurrent.atomic package, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"AtomicInteger"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"AtomicLong"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"AtomicBoolean"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"AtomicReference"),". These classes provide methods to atomically update their values, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"incrementAndGet()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"compareAndSet()"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"getAndSet()"),"."),(0,r.kt)("p",null,"For example, the following class uses an AtomicInteger to count the number of tasks completed by multiple threads:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class TaskCounter {\n    private AtomicInteger counter = new AtomicInteger();\n\n    public void increment() {\n        counter.incrementAndGet();\n    }\n\n    public int getCount() {\n        return counter.get();\n    }\n}\n")),(0,r.kt)("p",null,"In this example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"increment()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"getCount()")," methods are thread-safe and do not need synchronization, because they use atomic operations on the counter variable.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Locks (Common resources are locked to be proccessed untill unlock)")),(0,r.kt)("p",null,"Locks are thread synchronization mechanisms that ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"allow only one thread to access a shared resource"))," or a critical section at a time. Locks are useful in multithreaded environments where you want to avoid race conditions and ensure data consistency."),(0,r.kt)("p",null,"One example of using locks in Java is to use the Lock interface and its implementations, such as ReentrantLock, in the java.util.concurrent.locks package. These classes provide methods to acquire and release locks, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"lock()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"unlock()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"tryLock()"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"lockInterruptibly()"),"."),(0,r.kt)("p",null,"For example, the following class uses a ReentrantLock to manage access to a printer queue:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class PrinterQueue {\n    private final Lock queueLock = new ReentrantLock();\n\n    public void printJob(Object document) {\n        queueLock.lock();\n        try {\n            // print the document\n        } finally {\n            queueLock.unlock();\n        }\n    }\n}\n")),(0,r.kt)("p",null,"In this example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"printJob()")," method uses a queueLock to ensure that only one thread can print a document at a time. The ",(0,r.kt)("inlineCode",{parentName:"p"},"lock()")," method acquires the lock if it is available, or blocks the thread until it is released. The ",(0,r.kt)("inlineCode",{parentName:"p"},"unlock()")," method releases the lock so that other threads can acquire it. The try-finally block ensures that the lock is always released even if an exception occurs\xb2.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Immutable (Common resource is immutable)")),(0,r.kt)("p",null,"Immutable objects are objects whose internal state remains constant after they have been entirely created. Immutable objects are thread-safe because they ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"cannot be modified by multiple threads concurrently")),", and they do not require synchronization."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"class Person {\n    private final String name;\n    private final int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'Person person = new Person("Alice", 30);\n\nThread t1 = new Thread(() -> {\n    System.out.println(person.getName() + " is " + person.getAge() + " years old");\n});\n\nThread t2 = new Thread(() -> {\n    System.out.println(person.getName() + " is " + person.getAge() + " years old");\n});\n\nt1.start();\nt2.start();\n\nt1.join();\nt2.join();\n')),(0,r.kt)("p",null,"Both threads are trying to access the ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"age")," fields of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Person")," object. Since the fields are marked as ",(0,r.kt)("inlineCode",{parentName:"p"},"final"),", they cannot be modified once initialized, which means they are thread-safe. Even if both threads access the ",(0,r.kt)("inlineCode",{parentName:"p"},"Person")," object simultaneously, they will get the same value for ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"age"),", and the fields will not be overwritten."),(0,r.kt)("p",null,"In contrast, if we had not marked the ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"age")," fields as ",(0,r.kt)("inlineCode",{parentName:"p"},"final"),", there would be a risk of thread interference and memory consistency errors. Suppose one thread modifies the ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," field while the second thread is reading it. This can lead to unpredictable behavior and incorrect results."),(0,r.kt)("p",null,"To create a custom immutable class in Java, we need to follow some rules:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Declare the class as final so that it cannot be extended by other classes"),(0,r.kt)("li",{parentName:"ul"},"Declare all the fields as private and final so that they cannot be accessed or modified by other classes"),(0,r.kt)("li",{parentName:"ul"},"Provide only getters for the fields and no setters"),(0,r.kt)("li",{parentName:"ul"},"Initialize all the fields in the constructor and do not provide any methods that can change the state of the object"),(0,r.kt)("li",{parentName:"ul"},"If the class has any mutable fields, such as arrays or collections, do not expose them directly or return a copy of them")),(0,r.kt)("p",null,"For example, the following code shows how to create a custom immutable class called Money:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public final class Money {\n    private final double amount;\n    private final Currency currency;\n\n    public Money(double amount, Currency currency) {\n        this.amount = amount;\n        this.currency = currency;\n    }\n\n    public double getAmount() {\n        return amount;\n    }\n\n    public Currency getCurrency() {\n        return currency;\n    }\n}\n")),(0,r.kt)("p",null,"In this example, the Money class is immutable because it follows all the rules mentioned above. The amount and currency fields are private and final, and they are initialized in the constructor. The class only provides getters for the fields and no setters. The class does not have any mutable fields that need to be protected or copied.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Thread-safe collections")),(0,r.kt)("p",null,"Thread-safe collections are collections that can be safely accessed and modified by multiple threads concurrently without causing data inconsistency or corruption. Thread-safe collections ensure that their internal state and the values returned by their methods are correct even when they are invoked by different threads\xb9."),(0,r.kt)("p",null,"Some of the collection classes that are thread-safe in Java are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Stack"),": A thread-safe implementation of a last-in-first-out (LIFO) data structure that extends Vector."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Vector"),": A thread-safe implementation of a resizable array that implements the List interface. All of its methods are synchronized."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Properties"),": A thread-safe implementation of a persistent set of key-value pairs that extends Hashtable."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Hashtable"),": A thread-safe implementation of a hash table that implements the Map interface. All of its methods are synchronized.")),(0,r.kt)("p",null,"However, these thread-safe collections have some drawbacks, such as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"They have ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"poor performance because synchronization"))," requires locking and unlocking, which takes time and reduces concurrency."),(0,r.kt)("li",{parentName:"ul"},"They ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"do not prevent concurrent modification exceptions"))," when iterating over them using iterators or enumerations."),(0,r.kt)("li",{parentName:"ul"},"They ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"do not provide any advanced concurrency features")),", such as atomic operations, non-blocking algorithms, or concurrent data structures.")),(0,r.kt)("p",null,"To overcome these drawbacks, Java provides some alternatives for thread-safe collections, such as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Synchronized wrappers"),": These are static methods in the Collections class that return synchronized views of the given collections. For example, ",(0,r.kt)("inlineCode",{parentName:"li"},"Collections.synchronizedList()")," returns a thread-safe List backed by the specified List."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Concurrent collections"),": These are classes in the ",(0,r.kt)("inlineCode",{parentName:"li"},"java.util.concurrent")," package that provide high-performance and scalable thread-safe collections. For example, ",(0,r.kt)("inlineCode",{parentName:"li"},"CopyOnWriteArrayList"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"ConcurrentHashMap"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"ConcurrentLinkedQueue"),", etc."))))}p.isMDXComponent=!0},40924:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return u}});var a=n(83117),r=(n(67294),n(3905));const i={},o=void 0,l={unversionedId:"java/hero/thread",id:"java/hero/thread",title:"thread",description:"What is Multi-threading?",source:"@site/docs/java/hero/thread.md",sourceDirName:"java/hero",slug:"/java/hero/thread",permalink:"/devviews/interviews/java/hero/thread",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/java/hero/thread.md",tags:[],version:"current",frontMatter:{},sidebar:"javaInterviewSidebar",previous:{title:"exceptions",permalink:"/devviews/interviews/java/hero/exceptions"},next:{title:"Springboot AOP",permalink:"/devviews/interviews/java/springboot/AOP"}},s={},u=[],c={toc:u},d="wrapper";function p(e){let{components:t,...i}=e;return(0,r.kt)(d,(0,a.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"What is Multi-threading?")),(0,r.kt)("p",null,"Multi-threading in Java is a feature that allows concurrent execution of two or more parts of a program for maximum utilization of CPU. Each part of such program is called a thread, which is a lightweight sub-process that shares the same memory space and resources with other threads."),(0,r.kt)("p",null,"Java also provides some classes and interfaces ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"to manage and coordinate multiple threads")),", such as ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecutorService"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Future"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Callable"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Lock"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Condition"),", etc. These classes and interfaces help to create thread pools, submit tasks, return results, synchronize threads, communicate between threads, etc."),(0,r.kt)("p",null,"Here is an example of creating and running two threads using Thread and Runnable in Java:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// A task that prints "Hello" every second\nclass HelloTask implements Runnable {\n  @Override\n  public void run() {\n    while (true) {\n      System.out.println("Hello");\n      try {\n        // Sleep for one second\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        // Interrupted, break the loop\n        break;\n      }\n    }\n  }\n}\n\n// A task that prints "World" every two seconds\nclass WorldTask extends Thread {\n  @Override\n  public void run() {\n    while (true) {\n      System.out.println("World");\n      try {\n        // Sleep for two seconds\n        Thread.sleep(2000);\n      } catch (InterruptedException e) {\n        // Interrupted, break the loop\n        break;\n      }\n    }\n  }\n}\n\npublic class MultiThreadingDemo {\n  public static void main(String[] args) throws InterruptedException {\n    // Create a thread using Runnable\n    Thread t1 = new Thread(new HelloTask());\n    // Create a thread using Thread\n    Thread t2 = new WorldTask();\n\n    // Start the threads\n    t1.start();\n    t2.start();\n\n    // Wait for five seconds\n    Thread.sleep(5000);\n\n    // Interrupt the threads\n    t1.interrupt();\n    t2.interrupt();\n\n    // Wait for the threads to finish\n    t1.join();\n    t2.join();\n\n    System.out.println("Done");\n  }\n}\n')),(0,r.kt)("p",null,"The output of this program may look something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Hello\nWorld\nHello\nHello\nWorld\nHello\nHello\nWorld\nHello\nDone\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Thread and Runnable")),(0,r.kt)("p",null,"Okay, here is a table that compares Thread and Runnable in Java:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Thread"),(0,r.kt)("th",{parentName:"tr",align:null},"Runnable"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"A class that represents a thread of execution"),(0,r.kt)("td",{parentName:"tr",align:null},"An interface that represents a task that can be executed by a thread")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Provides the functionality of creating and managing threads"),(0,r.kt)("td",{parentName:"tr",align:null},"Defines only one method, run, that contains the logic of the task")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Implements Runnable, which means every thread is also a runnable"),(0,r.kt)("td",{parentName:"tr",align:null},"Not every runnable is a thread, a runnable is just a task")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"To create a thread, we need to extend Thread and override its run method"),(0,r.kt)("td",{parentName:"tr",align:null},"To create a thread, we need to implement Runnable and define its run method, then pass the runnable object to the Thread constructor or any other executor service")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Extending Thread has some disadvantages, such as limiting inheritance, violating composition over inheritance, and creating unnecessary coupling"),(0,r.kt)("td",{parentName:"tr",align:null},"Implementing Runnable has some advantages, such as allowing inheritance, following composition over inheritance, and creating loose coupling"))))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Explain the thread life cycle in Java")),(0,r.kt)("p",null,"The thread life cycle in Java is the sequence of states that a thread goes through during its execution. The thread can be in one of the following states at any given point of time:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"thread life cycle",src:n(61442).Z,width:"978",height:"800"})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"NEW"),": A thread is in the NEW state when it is created but not yet started. It remains in this state until the start method is invoked on the thread object."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"RUNNABLE"),": A thread is in the RUNNABLE state when it is ready to run or running. The thread scheduler can choose any thread in this state to execute on the available CPU core. A thread can move from RUNNABLE to RUNNING and vice versa depending on the thread scheduler's decision."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"BLOCKED"),": A thread is in the BLOCKED state when it is waiting to acquire a monitor lock to enter or re-enter a synchronized block or method. A thread can move from RUNNABLE to BLOCKED when it tries to access a synchronized resource that is held by another thread. A thread can move from BLOCKED to RUNNABLE when it acquires the lock or when the lock is released by another thread."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"WAITING"),": A thread is in the WAITING state when it is waiting for another thread to perform a specific action without any time limit. A thread can move from RUNNABLE to WAITING when it invokes methods such as Object.wait, Thread.join, or LockSupport.park. A thread can move from WAITING to RUNNABLE when it receives a notification from another thread, such as Object.notify, Thread.interrupt, or LockSupport.unpark."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"TIMED_WAITING"),": A thread is in the TIMED_WAITING state when it is waiting for another thread to perform a specific action for a specified period of time. A thread can move from RUNNABLE to TIMED_WAITING when it invokes methods such as Thread.sleep, Object.wait with timeout, Thread.join with timeout, or LockSupport.parkNanos. A thread can move from TIMED_WAITING to RUNNABLE when the timeout expires, when it receives a notification from another thread, or when it is interrupted by another thread."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"TERMINATED"),": A thread is in the TERMINATED state when it has completed its execution or when an uncaught exception or error occurs in the thread. A thread can move from RUNNABLE to TERMINATED when the run method returns normally or abnormally. A terminated thread cannot be restarted."))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Methods in the Thread")),(0,r.kt)("p",null,"There are several methods in the Thread class that are related to the thread life cycle in Java. Here is a list of some of them with examples for each:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"start"),": This method starts the execution of the thread by invoking its run method. It moves the thread from NEW to RUNNABLE state. Example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Create a thread using Runnable\nThread t = new Thread(new Runnable() {\n  @Override\n  public void run() {\n    System.out.println("Thread started");\n  }\n});\n\n// Start the thread\nt.start();\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"run"),": This method contains the logic of the task to be performed by the thread. It is invoked by the start method or directly by the programmer. It moves the thread from RUNNABLE to RUNNING state. Example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Create a thread using Runnable\nThread t = new Thread(new Runnable() {\n  @Override\n  public void run() {\n    System.out.println("Thread running");\n  }\n});\n\n// Invoke the run method directly\nt.run();\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"sleep"),": This method causes the current thread to pause its execution for a specified period of time. It moves the thread from RUNNING to TIMED_WAITING state. It can be interrupted by another thread. Example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Create a thread using Runnable\nThread t = new Thread(new Runnable() {\n  @Override\n  public void run() {\n    try {\n      System.out.println("Thread sleeping");\n      // Sleep for 5 seconds\n      Thread.sleep(5000);\n      System.out.println("Thread awake");\n    } catch (InterruptedException e) {\n      System.out.println("Thread interrupted");\n    }\n  }\n});\n\n// Start the thread\nt.start();\n\n// Interrupt the thread after 3 seconds\nThread.sleep(3000);\nt.interrupt();\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"join"),": This method causes the current thread to wait for the completion of another thread. It moves the thread from RUNNING to WAITING or TIMED_WAITING state. It can be interrupted by another thread. Example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Create two threads using Runnable\nThread t1 = new Thread(new Runnable() {\n  @Override\n  public void run() {\n    System.out.println("Thread 1 running");\n  }\n});\nThread t2 = new Thread(new Runnable() {\n  @Override\n  public void run() {\n    try {\n      System.out.println("Thread 2 waiting for Thread 1");\n      // Wait for Thread 1 to finish\n      t1.join();\n      System.out.println("Thread 2 running");\n    } catch (InterruptedException e) {\n      System.out.println("Thread 2 interrupted");\n    }\n  }\n});\n\n// Start both threads\nt1.start();\nt2.start();\n\n// Interrupt Thread 2 after 3 seconds\nThread.sleep(3000);\nt2.interrupt();\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"yield"),": This method causes the current thread to give up its CPU time voluntarily and allow other threads of the same or higher priority to execute. It moves the thread from RUNNING to RUNNABLE state. It is a hint to the thread scheduler and does not guarantee any specific behavior. Example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Create two threads using Runnable\nThread t1 = new Thread(new Runnable() {\n  @Override\n  public void run() {\n    for (int i = 0; i < 10; i++) {\n      System.out.println("Thread 1: " + i);\n      // Yield to other threads\n      Thread.yield();\n    }\n  }\n});\nThread t2 = new Thread(new Runnable() {\n  @Override\n  public void run() {\n    for (int i = 0; i < 10; i++) {\n      System.out.println("Thread 2: " + i);\n      // Yield to other threads\n      Thread.yield();\n    }\n  }\n});\n\n// Start both threads\nt1.start();\nt2.start();\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interrupt"),": This method interrupts the target thread and sets its interrupt status to true. It does not stop the thread, but it causes some methods that are blocking or waiting, such as sleep, join, wait, etc., to throw an InterruptedException. The target thread can also check its interrupt status by calling isInterrupted or interrupted methods and handle it accordingly. Example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Create a thread using Runnable\nThread t = new Thread(new Runnable() {\n  @Override\n  public void run() {\n    while (true) {\n      // Check if the thread is interrupted\n      if (Thread.interrupted()) {\n        System.out.println("Thread interrupted");\n        break;\n      }\n      System.out.println("Thread running");\n    }\n  }\n});\n\n// Start the thread\nt.start();\n\n// Interrupt the thread after 3 seconds\nThread.sleep(3000);\nt.interrupt();\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"wait"),": This method causes the current thread to wait until another thread invokes the notify or notifyAll method on the same object. It moves the thread from RUNNING to WAITING state. It can be interrupted by another thread. It must be called within a synchronized block or method on the same object. Example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Create a shared object\nObject obj = new Object();\n\n// Create two threads using Runnable\nThread t1 = new Thread(new Runnable() {\n  @Override\n  public void run() {\n    synchronized (obj) {\n      try {\n        System.out.println("Thread 1 waiting for notification");\n        // Wait on the shared object\n        obj.wait();\n        System.out.println("Thread 1 notified");\n      } catch (InterruptedException e) {\n        System.out.println("Thread 1 interrupted");\n      }\n    }\n  }\n});\nThread t2 = new Thread(new Runnable() {\n  @Override\n  public void run() {\n    synchronized (obj) {\n      System.out.println("Thread 2 notifying");\n      // Notify the shared object\n      obj.notify();\n    }\n  }\n});\n\n// Start both threads\nt1.start();\nt2.start();\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"notify"),": This method wakes up one thread that is waiting on the same object. It moves the thread from WAITING to RUNNABLE state. It must be called within a synchronized block or method on the same object. Example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Create a shared object\nObject obj = new Object();\n\n// Create two threads using Runnable\nThread t1 = new Thread(new Runnable() {\n  @Override\n  public void run() {\n    synchronized (obj) {\n      try {\n        System.out.println("Thread 1 waiting for notification");\n        // Wait on the shared object\n        obj.wait();\n        System.out.println("Thread 1 notified");\n      } catch (InterruptedException e) {\n        System.out.println("Thread 1 interrupted");\n      }\n    }\n  }\n});\nThread t2 = new Thread(new Runnable() {\n  @Override\n  public void run() {\n    synchronized (obj) {\n      System.out.println("Thread 2 notifying");\n      // Notify the shared object\n      obj.notify();\n    }\n  }\n});\n\n// Start both threads\nt1.start();\nt2.start();\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"notifyAll"),": This method wakes up all threads that are waiting on the same object. It moves the threads from WAITING to RUNNABLE state. It must be called within a synchronized block or method on the same object. Example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Create a shared object\nObject obj = new Object();\n\n// Create three threads using Runnable\nThread t1 = new Thread(new Runnable() {\n  @Override\n  public void run() {\n    synchronized (obj) {\n      try {\n        System.out.println("Thread 1 waiting for notification");\n        // Wait on the shared object\n        obj.wait();\n        System.out.println("Thread 1 notified");\n      } catch (InterruptedException e) {\n        System.out.println("Thread 1 interrupted");\n      }\n    }\n  }\n});\nThread t2 = new Thread(new Runnable() {\n  @Override\n  public void run() {\n    synchronized (obj) {\n      try {\n        System.out.println("Thread 2 waiting for notification");\n        // Wait on the shared object\n        obj.wait();\n        System.out.println("Thread 2 notified");\n      } catch (InterruptedException e) {\n        System.out.println("Thread 2 interrupted");\n      }\n    }\n  }\n});\nThread t3 = new Thread(new Runnable() {\n  @Override\n  public void run() {\n    synchronized (obj) {\n      System.out.println("Thread 3 notifying all");\n      // Notify all the shared object\n      obj.notifyAll();\n    }\n  }\n});\n\n// Start all threads\nt1.start();\nt2.start();\nt3.start();\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"ExecutorService")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ExecutorService")," in Java is an interface that provides methods to manage the execution of asynchronous tasks on threads. It is part of the ",(0,r.kt)("inlineCode",{parentName:"p"},"java.util.concurrent")," package, which contains classes and interfaces for concurrent programming. ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecutorService")," helps in ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"creating and managing a pool of threads, and assigning tasks to them")),". "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"You can ",(0,r.kt)("strong",{parentName:"p"},"create")," an ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecutorService")," instance by using one of the factory methods of the Executors class, or by using a specific implementation such as ",(0,r.kt)("inlineCode",{parentName:"p"},"ThreadPoolExecutor")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"ForkJoinPool"),". ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"You can ",(0,r.kt)("strong",{parentName:"p"},"assign tasks")," to the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecutorService")," using methods such as ",(0,r.kt)("inlineCode",{parentName:"p"},"execute()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"submit()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"invokeAll()")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"invokeAny()"),". These methods can accept ",(0,r.kt)("inlineCode",{parentName:"p"},"Runnable")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Callable")," objects, which represent the tasks to be executed. You can also use ",(0,r.kt)("inlineCode",{parentName:"p"},"Future")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"CompletableFuture")," objects to get the result or status of the tasks. ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"You can ",(0,r.kt)("strong",{parentName:"p"},"shut down")," the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecutorService")," when you don\u2019t need it anymore, by using methods such as ",(0,r.kt)("inlineCode",{parentName:"p"},"shutdown()")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"shutdownNow()"),"."))),(0,r.kt)("p",null,"Here is an example of how to use ExecutorService in Java:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.concurrent.*;\n\npublic class ExecutorServiceExample {\n\n    public static void main(String[] args) throws InterruptedException, ExecutionException {\n        // Create an executor service with 4 threads\n        ExecutorService executor = Executors.newFixedThreadPool(4);\n\n        // Create a runnable task that prints "Hello World"\n        Runnable task = () -> {\n            System.out.println("Hello World");\n        };\n\n        // Submit the task to the executor service 10 times\n        for (int i = 0; i < 10; i++) {\n            executor.submit(task);\n        }\n\n        // Shutdown the executor service gracefully\n        executor.shutdown();\n    }\n}\n')),(0,r.kt)("p",null,"This code will output something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Hello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\n")),(0,r.kt)("p",null,"You can see that the executor service executes the task 10 times on 4 threads, and then shuts down. This is the benefit of using ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecutorService")," in Java.")))}p.isMDXComponent=!0},68982:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return u}});var a=n(83117),r=(n(67294),n(3905));const i={sidebar_position:1e3,sidebar_label:"Java Type Conversion",title:"Java Type Conversion",tags:["Java Knowledge"]},o=void 0,l={unversionedId:"java/hero/type-conversion",id:"java/hero/type-conversion",title:"Java Type Conversion",description:"Java Type Conversion",source:"@site/docs/java/hero/type-conversion.md",sourceDirName:"java/hero",slug:"/java/hero/type-conversion",permalink:"/devviews/interviews/java/hero/type-conversion",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/java/hero/type-conversion.md",tags:[{label:"Java Knowledge",permalink:"/devviews/interviews/tags/java-knowledge"}],version:"current",sidebarPosition:1e3,frontMatter:{sidebar_position:1e3,sidebar_label:"Java Type Conversion",title:"Java Type Conversion",tags:["Java Knowledge"]},sidebar:"javaInterviewSidebar",previous:{title:"Thread Safety In Java",permalink:"/devviews/interviews/java/hero/thread-safety"},next:{title:"OOP",permalink:"/devviews/interviews/java/hero/OOP"}},s={},u=[],c={toc:u},d="wrapper";function p(e){let{components:t,...i}=e;return(0,r.kt)(d,(0,a.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Java Type Conversion")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Java Type Conversion",src:n(66013).Z,width:"2186",height:"1232"})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Widening Casting (automatically)")," - converting a smaller type to a larger type size\n",(0,r.kt)("inlineCode",{parentName:"li"},"byte -> short -> int -> (long | float) -> double"),"\nEx:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"int myInt = 9;\ndouble myDouble = myInt; // Automatic casting: int to double\nSystem.out.println(myInt);      // Outputs 9\nSystem.out.println(myDouble);   // Outputs 9.0\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Narrowing Casting (manually)")," - converting a larger type to a smaller size type\n",(0,r.kt)("inlineCode",{parentName:"li"},"double -> (float | long) -> int -> short -> byte"),"\nEx:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"double myDouble = 9.78;\nint myInt = (int) myDouble; // Manual casting: double to int\nSystem.out.println(myDouble);   // Outputs 9.78\nSystem.out.println(myInt);      // Outputs 9\n")),(0,r.kt)("p",null,":::note Tips To Remember"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"buy short [car] in (long | float) doubt")),(0,r.kt)("p",null,":::")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Autoboxing and Unboxing")),(0,r.kt)("p",null,"Autoboxing and unboxing are two features of Java that allow ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"automatic conversion between primitive types and their corresponding wrapper classes")),". Wrapper classes are classes that wrap a primitive value in an object, such as Integer, Double, Character, etc."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Autoboxing")," (wrapping) is the process of ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"converting a primitive value to a wrapper object")),". For example, assigning an int value to an Integer variable:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"int i = 10; // a primitive value\nInteger j = i; // autoboxing\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Unboxing")," (unwrapping) is the process of ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"converting a wrapper object to a primitive value")),". For example, passing an Integer object to a method that expects an int parameter:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"Integer k = 20; // a wrapper object\nint l = k; // unboxing\n")),(0,r.kt)("p",null,"Autoboxing and unboxing are useful because they allow us to use primitive values and wrapper objects interchangeably. For example, we can use them with generics, collections, and methods that require objects as arguments or return values."),(0,r.kt)("p",null,"Here is an example that demonstrates autoboxing and unboxing in Java:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        // autoboxing: converting int to Integer\n        int x = 100;\n        Integer y = x;\n\n        // unboxing: converting Integer to int\n        Integer z = 200;\n        int w = z;\n\n        // using autoboxing and unboxing with generics\n        List<Integer> list = new ArrayList<>();\n        list.add(x); // autoboxing\n        list.add(y);\n        list.add(z);\n        int sum = 0;\n        for (Integer num : list) {\n            sum += num; // unboxing\n        }\n        System.out.println("Sum: " + sum);\n\n        // using autoboxing and unboxing with methods\n        System.out.println("Square: " + square(x)); // autoboxing\n        System.out.println("Cube: " + cube(y)); // unboxing\n\n    }\n\n    // a method that returns the square of an Integer object\n    public static Integer square(Integer n) {\n        return n * n;\n    }\n\n    // a method that returns the cube of an int value\n    public static int cube(int n) {\n        return n * n * n;\n    }\n}\n')),(0,r.kt)("p",null,"The output of this program is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Sum: 400\nSquare: 10000\nCube: 8000000\n"))))}p.isMDXComponent=!0},46854:function(e,t,n){n.r(t),n.d(t,{assets:function(){return v},contentTitle:function(){return f},default:function(){return C},frontMatter:function(){return N},metadata:function(){return b},toc:function(){return y}});var a=n(83117),r=(n(67294),n(3905)),i=(n(54312),n(42002)),o=n(70007),l=n(68982),s=n(580),u=n(70031),c=n(94058),d=n(68368),p=n(41032),m=n(20095),h=n(95762),k=n(40924),g=n(52234);const N={sidebar_position:3,id:"java-zero-to-hero",sidebar_label:"Java Zero To Hero",title:"Java Zero To Hero",tags:["Java Knowledges"]},f="Java From Zero To Hero",b={unversionedId:"java/java-zero-to-hero",id:"java/java-zero-to-hero",title:"Java Zero To Hero",description:"How Java Works",source:"@site/docs/java/intro.md",sourceDirName:"java",slug:"/java/java-zero-to-hero",permalink:"/devviews/interviews/java/java-zero-to-hero",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/java/intro.md",tags:[{label:"Java Knowledges",permalink:"/devviews/interviews/tags/java-knowledges"}],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,id:"java-zero-to-hero",sidebar_label:"Java Zero To Hero",title:"Java Zero To Hero",tags:["Java Knowledges"]},sidebar:"javaInterviewSidebar",previous:{title:"Java Interviews",permalink:"/devviews/interviews/java/java-interview-questions-answers"},next:{title:"Spring Cloud Zero To Hero",permalink:"/devviews/interviews/java/spring-cloud-zero-to-hero"}},v={},y=[{value:"How Java Works",id:"how-java-works",level:3},{value:"How JVM Works",id:"how-jvm-works",level:3},{value:"Type Conversion",id:"type-conversion",level:3},{value:"Data Structure",id:"data-structure",level:3},{value:"Scopes",id:"scopes",level:3},{value:"OOP",id:"oop",level:3},{value:"Inner Class",id:"inner-class",level:3},{value:"Exceptions",id:"exceptions",level:3},{value:"Thread",id:"thread",level:3},{value:"Thread Safety",id:"thread-safety",level:3},{value:"Concurrency",id:"concurrency",level:3},{value:"Funtional Interface",id:"funtional-interface",level:3}],w={toc:y},x="wrapper";function C(e){let{components:t,...n}=e;return(0,r.kt)(x,(0,a.Z)({},w,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"java-from-zero-to-hero"},"Java From Zero To Hero"),(0,r.kt)("h3",{id:"how-java-works"},"How Java Works"),(0,r.kt)(i.default,{mdxType:"HowJavaWorks"}),(0,r.kt)("h3",{id:"how-jvm-works"},"How JVM Works"),(0,r.kt)(o.default,{mdxType:"HowJVMWorks"}),(0,r.kt)("h3",{id:"type-conversion"},"Type Conversion"),(0,r.kt)(l.default,{mdxType:"TypeConversion"}),(0,r.kt)("h3",{id:"data-structure"},"Data Structure"),(0,r.kt)(s.default,{mdxType:"DataStructure"}),(0,r.kt)("h3",{id:"scopes"},"Scopes"),(0,r.kt)(c.default,{mdxType:"Scope"}),(0,r.kt)("h3",{id:"oop"},"OOP"),(0,r.kt)(m.default,{mdxType:"OOP"}),(0,r.kt)("h3",{id:"inner-class"},"Inner Class"),(0,r.kt)(d.default,{mdxType:"Innerclass"}),(0,r.kt)("h3",{id:"exceptions"},"Exceptions"),(0,r.kt)(h.default,{mdxType:"Exceptions"}),(0,r.kt)("h3",{id:"thread"},"Thread"),(0,r.kt)(k.default,{mdxType:"Thread"}),(0,r.kt)("h3",{id:"thread-safety"},"Thread Safety"),(0,r.kt)(u.default,{mdxType:"ThreadSafety"}),(0,r.kt)("h3",{id:"concurrency"},"Concurrency"),(0,r.kt)(g.default,{mdxType:"Concurrency"}),(0,r.kt)("h3",{id:"funtional-interface"},"Funtional Interface"),(0,r.kt)(p.default,{mdxType:"FuntionalInterface"}))}C.isMDXComponent=!0},61442:function(e,t,n){t.Z=n.p+"assets/images/Life_cycle_of_a_Thread_in_Java-f4d64d77ae9b303727d66afd87c6b80d.jpg"},27490:function(e,t,n){t.Z=n.p+"assets/images/data-structure-e44e149cee82c3fbb1eb80da5950e3cc.png"},64438:function(e,t,n){t.Z=n.p+"assets/images/how-java-works-bca477607909823cc1ecb42912196c79.png"},76302:function(e,t,n){t.Z=n.p+"assets/images/how-jvm-works-c448181225b529ef952a22cf50497bf7.png"},66013:function(e,t,n){t.Z=n.p+"assets/images/type-conversion-2e63ce785874017dcdc9d145c2b2ad57.png"}}]);