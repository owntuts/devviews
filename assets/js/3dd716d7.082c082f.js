"use strict";(self.webpackChunkinterviewdev=self.webpackChunkinterviewdev||[]).push([[8046],{3905:function(e,t,r){r.d(t,{Zo:function(){return u},kt:function(){return f}});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),c=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=c(r),h=a,f=m["".concat(s,".").concat(h)]||m[h]||p[h]||o;return r?n.createElement(f,i(i({ref:t},u),{},{components:r})):n.createElement(f,i({ref:t},u))}));function f(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},69418:function(e,t,r){r.r(t),r.d(t,{assets:function(){return s},contentTitle:function(){return i},default:function(){return p},frontMatter:function(){return o},metadata:function(){return l},toc:function(){return c}});var n=r(83117),a=(r(67294),r(3905));const o={sidebar_position:1e3,sidebar_label:"Chart Resources",title:"Chart Resources",tags:["HELM Knowledge"]},i=void 0,l={unversionedId:"helm/hero/chart-resources",id:"helm/hero/chart-resources",title:"Chart Resources",description:"Directory Structure",source:"@site/docs/helm/hero/chart-resources.md",sourceDirName:"helm/hero",slug:"/helm/hero/chart-resources",permalink:"/devviews/interviews/helm/hero/chart-resources",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/helm/hero/chart-resources.md",tags:[{label:"HELM Knowledge",permalink:"/devviews/interviews/tags/helm-knowledge"}],version:"current",sidebarPosition:1e3,frontMatter:{sidebar_position:1e3,sidebar_label:"Chart Resources",title:"Chart Resources",tags:["HELM Knowledge"]},sidebar:"helmInterviewSidebar",previous:{title:"Helm Architecture",permalink:"/devviews/interviews/helm/hero/architecture"},next:{title:"Control Structure",permalink:"/devviews/interviews/helm/hero/control-structure"}},s={},c=[],u={toc:c},m="wrapper";function p(e){let{components:t,...r}=e;return(0,a.kt)(m,(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("details",{open:!0},(0,a.kt)("summary",null,(0,a.kt)("h5",null,"Directory Structure")),(0,a.kt)("p",null,"A Helm chart is a collection of files that describe a related set of Kubernetes resources. A Helm chart may have the following files:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Chart.yaml: A YAML file containing information about the chart, such as name, version, description, etc. (required)"),(0,a.kt)("li",{parentName:"ul"},"values.yaml: The default configuration values for the chart (required)"),(0,a.kt)("li",{parentName:"ul"},"values.schema.json: A JSON schema for imposing a structure on the values.yaml file (optional)"),(0,a.kt)("li",{parentName:"ul"},"charts/: A directory containing any charts upon which this chart depends (optional)"),(0,a.kt)("li",{parentName:"ul"},"crds/: A directory containing custom resource definitions (CRDs) that are installed by the chart (optional)"),(0,a.kt)("li",{parentName:"ul"},"templates/: A directory of templates that, when combined with values, will generate valid Kubernetes manifest files (",(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("em",{parentName:"strong"},"required & important")),")"),(0,a.kt)("li",{parentName:"ul"},"templates/NOTES.txt: A plain text file containing short usage notes for the chart (optional)"),(0,a.kt)("li",{parentName:"ul"},"templates/hooks.yaml: Hooks are optional scripts allow you to perform additional tasks before or after chart installation, upgrade, or deletion. You can use them to set up databases, configure load balancers, or perform other tasks related to the chart installation. Here's an example of a pre-install hook in a chart (hooks.yaml) that logs a message before installing the chart:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="templates/hooks.yaml"',title:'"templates/hooks.yaml"'},'apiVersion: v1\nkind: Pod\nmetadata:\n  name: "{{ .Release.Name }}-pre-install"\n  labels:\n    heritage: "{{ .Release.Service }}"\n    release: "{{ .Release.Name }}"\n    chart: "{{ .Chart.Name }}-{{ .Chart.Version }}"\n    app: "{{ .Chart.Name }}"\nspec:\n  containers:\n    - name: pre-install-logging\n      image: busybox\n      command: [\'sh\', \'-c\', \'echo "Installing {{ .Release.Name }}"\']\n      restartPolicy: Never\n\n'))))}p.isMDXComponent=!0}}]);