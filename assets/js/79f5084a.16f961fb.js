"use strict";(self.webpackChunkinterviewdev=self.webpackChunkinterviewdev||[]).push([[2701],{3905:function(e,n,t){t.d(n,{Zo:function(){return m},kt:function(){return h}});var a=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},m=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),c=p(t),u=o,h=c["".concat(s,".").concat(u)]||c[u]||d[u]||r;return t?a.createElement(h,i(i({ref:n},m),{},{components:t})):a.createElement(h,i({ref:n},m))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=u;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[c]="string"==typeof e?e:o,i[1]=l;for(var p=2;p<r;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},39038:function(e,n,t){t.r(n),t.d(n,{assets:function(){return B},contentTitle:function(){return q},default:function(){return U},frontMatter:function(){return V},metadata:function(){return L},toc:function(){return W}});var a=t(83117),o=(t(67294),t(3905));const r={toc:[{value:"Steps to create app with Standalone components",id:"steps-to-create-app-with-standalone-components",level:4},{value:"1. Bootstrapping an application using a standalone component",id:"1-bootstrapping-an-application-using-a-standalone-component",level:4},{value:"2. Routing &amp; Lazy loading many routes",id:"2-routing--lazy-loading-many-routes",level:4}]},i="wrapper";function l(e){let{components:n,...t}=e;return(0,o.kt)(i,(0,a.Z)({},r,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("details",{open:!0},(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Standalone Component")),(0,o.kt)("p",null,"A standalone component in Angular is a component that is not part of any Angular module. This means that it can be used without being imported into a module. Standalone components are useful for creating reusable components that can be used in multiple applications."),(0,o.kt)("h4",{id:"steps-to-create-app-with-standalone-components"},"Steps to create app with Standalone components"),(0,o.kt)("h4",{id:"1-bootstrapping-an-application-using-a-standalone-component"},"1. Bootstrapping an application using a standalone component"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"import {LibraryModule} from 'ngmodule-based-library';\n\nbootstrapApplication(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    importProvidersFrom(\n      LibraryModule.forRoot()\n    ),\n    provideRouter([/* app routes */]),\n    // ...\n  ]\n  ]\n});\n")),(0,o.kt)("h4",{id:"2-routing--lazy-loading-many-routes"},"2. Routing & Lazy loading many routes"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"// Main application:\nexport const ROUTES: Route[] = {\n  // Lazy-load the admin routes.\n  {path: 'admin', loadChildren: () => import('./admin/routes').then(mod => mod.ADMIN_ROUTES)},\n  // ... rest of the routes\n}\n\n// In admin/routes.ts:\nexport const ADMIN_ROUTES: Route[] = [{\n  path: '',\n  pathMatch: 'prefix',\n  providers: [\n    AdminService,\n    {provide: ADMIN_API_KEY, useValue: 12345},\n  ],\n  children: [\n    {path: 'users', component: AdminUsersCmp},\n    {path: 'teams', component: AdminTeamsCmp},\n  ],\n}];\n"))),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Types of providers")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@NgModule.providers")," (in applications bootstrapping through an NgModule);"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},'@Injectable({provideIn: "..."})'),"(in both the NgModule-based and the \u201cstandalone\u201d applications);"),(0,o.kt)("li",{parentName:"ul"},"providers option in the bootstrapApplication call (in fully \u201cstandalone\u201d applications);")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"bootstrapApplication(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    {provide: PhotosService, useClass: PhotosService},\n    // ...\n  ]\n});\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"providers field in a Route configuration like above.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Environment injectors")," are used to provide services to components and directives outside of the component tree. This can be useful for providing services to services, directives, and components that are not defined in an Angular module."))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"import { createEnvironmentInjector, ENVIRONMENT_INITIALIZER } from '@angular/core';\n\nconst environmentInjector = createEnvironmentInjector([\n  { provide: 'MyService', useClass: MyService },\n  { provide: ENVIRONMENT_INITIALIZER, useValue: () => {\n    console.log('This function runs when this EnvironmentInjector gets created');\n  }}\n]);\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"import { Component, OnInit } from '@angular/core';\nimport { MyService } from './my.service';\n\n@Component({\n  selector: 'my-component',\n  templateUrl: './my-component.component.html',\n  styleUrls: ['./my-component.component.css']\n})\nexport class MyComponent implements OnInit {\n\n  constructor(private injector: Injector) {}\n\n  ngOnInit() {\n    const myService = this.injector.get(MyService);\n  }\n\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Standalone injectors"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"@Component({\n        selector: 'date-modal',\n        template: '<datepicker></datepicker>',\n        standalone: true,\n        imports: [DatePickerModule]\n})\nclass DateModalComponent {\n}\n"))),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Resolve circular dependencies")),(0,o.kt)("p",null,"Circular problem happens when class 'A' refers to class 'B' and 'B' refers to 'A'. One of them has to be defined first. To solve this problem, we use ",(0,o.kt)("inlineCode",{parentName:"p"},"forwardRef"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"@Component({\n  standalone: true, \n  imports: [ChildComponent],\n  selector: 'app-parent',\n  template: `<app-child [hideParent]=\"hideParent\"></app-child>`,\n})\nexport class ParentComponent {\n  @Input() hideParent: boolean;\n}\n\n\n@Component({\n  standalone: true,\n  imports: [CommonModule, forwardRef(() => ParentComponent)],\n  selector: 'app-child',\n  template: `<app-parent *ngIf=\"!hideParent\"></app-parent>`,\n})\nexport class ChildComponent {\n  @Input() hideParent: boolean;\n}\n"))))}l.isMDXComponent=!0;const s={toc:[]},p="wrapper";function m(e){let{components:n,...t}=e;return(0,o.kt)(p,(0,a.Z)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("details",{open:!0},(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Typed Forms")),(0,o.kt)("p",null,"Typed Forms are a new feature in Angular 14 that ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"}," provide type safety to your Angular forms")),". This can help you avoid errors and make your code easier to read and maintain."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { Component } from '@angular/core';\nimport { FormArray, FormBuilder, FormControl, FormGroup } from '@angular/forms';\n\ninterface FormModel {\n  title: FormControl<string | null>;\n  name: FormGroup<{\n    firstName: FormControl<string | null>;\n    lastName: FormControl<string | null>;\n  }>;\n  interest: FormArray<FormControl<string | null>>;\n}\n\n@Component({\n  selector: 'my-app',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css'],\n})\nexport class AppComponent {\n  form = this.fb.group<FormModel>({\n    title: this.fb.control('This is title'),\n    name: this.fb.group({\n      firstName: this.fb.control('Will'),\n      lastName: this.fb.control('Huang'),\n    }),\n    interest: this.fb.array([\n      this.fb.control('HTML'),\n      this.fb.control('Angular'),\n    ]),\n  });\n\n  constructor(private fb: FormBuilder) {}\n}\n\n"))),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("h5",null,"FormRecord - Dynamic Form")),(0,o.kt)("p",null,"Some FormGroup usages do not fit the above pattern (",(0,o.kt)("inlineCode",{parentName:"p"},"FormModel"),") because ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"the keys are not known ahead of time")),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"FormRecord")," class is designed for that case. ",(0,o.kt)("inlineCode",{parentName:"p"},"FormRecord")," is a class from the ",(0,o.kt)("inlineCode",{parentName:"p"},"@angular/forms")," module that ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"extends the ",(0,o.kt)("inlineCode",{parentName:"em"},"FormGroup")))," class and allows you to create a form group with dynamic keys and type-safe controls."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"export class AppComponent implements OnInit {\n\n  public myForm: FormRecord;\n  public formKeys = ['Andrew', 'Barry']\n\n  ngOnInit(): void {\n    this.myForm = new FormRecord<FormControl<string|null>>({});\n    this.formKeys.forEach((key, i) => \n      this.myForm.addControl(key, new FormControl(`${(i + 1) * 100} Default-Value St.`))\n    );\n\n  }\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'<div>\n  <form [formGroup]="myForm">\n    <div *ngFor="let key of formKeys">\n      <b>{{key}}: </b><input  [formControlName]="key"><br/>\n    </div>\n  </form>\n</div>\n<div>\n<br/>\n<div *ngFor="let key of formKeys">\n  <div>{{key}}: {{myForm.get(key).value}}</div>\n</div>\n</div>\n'))))}m.isMDXComponent=!0;const c={toc:[]},d="wrapper";function u(e){let{components:n,...t}=e;return(0,o.kt)(d,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("details",{open:!0},(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Angular Signals")),(0,o.kt)("p",null,"Angular Signals are a new feature in Angular 16 that provides ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"a way to notify interested consumers when a value changes")),". Signals can be used to improve the performance of Angular applications by ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"reducing the number of change detection runs")),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"import { Component, OnInit } from '@angular/core';\nimport { Signal } from '@angular/common';\n\n@Component({\n  selector: 'my-app',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit {\n\n  constructor(private signal: Signal<string>) {}\n\n  ngOnInit() {\n    this.signal.subscribe((value) => {\n      console.log(value);\n    });\n\n    this.signal.value = 'Hello, world!';\n  }\n\n}\n\n"))),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Types of of signals")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Writable signal:")),(0,o.kt)("p",null,"Writable signals are ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"signals that can be changed"))," by consumers. When a writable signal is changed, all of its consumers will be notified of the change."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"import { Signal } from '@angular/common';\n\nconst mySignal = new Signal<string>();\n\nmySignal.value = 'Hello, world!';\n\nmySignal.subscribe((value) => {\n  console.log(value);\n});\n")),(0,o.kt)("p",null,"In this example, we create a writable signal called ",(0,o.kt)("inlineCode",{parentName:"p"},"mySignal")," and set its initial value to ",(0,o.kt)("inlineCode",{parentName:"p"},"'Hello, world!'"),". We then subscribe to the signal and print the value of the signal to the console when it changes."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Computed signal:")),(0,o.kt)("p",null,"Computed signals are signals that ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"are derived from other signals")),". When one of the signals that a computed signal is derived from changes, the computed signal will be automatically updated."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"import { Signal } from '@angular/common';\n\nconst mySignal1 = new Signal<string>();\nconst mySignal2 = new Signal<string>();\n\nconst myComputedSignal = computed(() => {\n  return mySignal1.value + mySignal2.value;\n});\n\nmySignal1.value = 'Hello';\nmySignal2.value = 'World!';\n\nconsole.log(myComputedSignal.value); // HelloWorld!\n")),(0,o.kt)("p",null,"In this example, we create two writable signals called ",(0,o.kt)("inlineCode",{parentName:"p"},"mySignal1")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"mySignal2"),". We then create a computed signal called ",(0,o.kt)("inlineCode",{parentName:"p"},"myComputedSignal")," that is derived from the values of ",(0,o.kt)("inlineCode",{parentName:"p"},"mySignal1")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"mySignal2"),". When the values of ",(0,o.kt)("inlineCode",{parentName:"p"},"mySignal1")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"mySignal2")," change, the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"myComputedSignal")," will be automatically updated.")))}u.isMDXComponent=!0;const h={toc:[]},g="wrapper";function k(e){let{components:n,...t}=e;return(0,o.kt)(g,(0,a.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("details",{open:!0},(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Angular Dynamic Component")),(0,o.kt)("p",null,"Angular Dynamic Component is a feature that allows you to ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"load components dynamically at runtime")),". It can be useful for creating complex and conditional views, or for loading components from external sources."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"import {\n  Component,\n  ViewContainerRef,\n  ComponentFactoryResolver,\n  ViewChild,\n} from '@angular/core';\n\n@Component({\n  selector: 'my-app',\n  template: `\n    <div>\n      {{ name }}\n      <ng-container #ref></ng-container>\n    </div>\n  `\n})\nexport class AppComponent {\n  name = 'Angular';\n\n  @ViewChild('ref', { read: ViewContainerRef, static: true }) ref: ViewContainerRef;\n\n  constructor(\n    private resolver: ComponentFactoryResolver\n  ) {}\n\n  ngOnInit() {\n    import('./created/created.component').then((mod) => {\n      const component = mod.CreatedComponent;\n      const cmpFactory = this.resolver.resolveComponentFactory(component);\n      this.ref.clear();\n      this.ref.createComponent(cmpFactory);\n    });\n  }\n}\n\n"))))}k.isMDXComponent=!0;const f={toc:[]},N="wrapper";function y(e){let{components:n,...r}=e;return(0,o.kt)(N,(0,a.Z)({},f,r,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("details",{open:!0},(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Angular Custom Element")),(0,o.kt)("p",null,"Custom Element Transform an Angular component into a web component => It allows you to use Angular component as a nomal DOM."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"custom element",src:t(83053).Z,width:"797",height:"514"})),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// Import the necessary modules\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule, Injector } from '@angular/core';\nimport { createCustomElement } from '@angular/elements';\n\n// Define the component to be packaged as a custom element\n@Component({\n  selector: 'hello-world',\n  template: `<h1>Hello {{name}}!</h1>`\n})\nexport class HelloWorldComponent {\n  @Input() name: string;\n}\n\n// Declare the module that contains the component\n@NgModule({\n  declarations: [HelloWorldComponent],\n  imports: [BrowserModule],\n  entryComponents: [HelloWorldComponent]\n})\nexport class AppModule {\n  constructor(private injector: Injector) {}\n\n  // Register the custom element with the browser\n  ngDoBootstrap() {\n    const el = createCustomElement(HelloWorldComponent, {injector: this.injector});\n    customElements.define('hello-world', el); // `customElements.define` is a built-in function\n  }\n}\n\n")),(0,o.kt)("p",null,"Now, you can use the component in HTML as if it's a HTML element"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},"<html>\n<head>\n  <title>Using Angular Custom Element</title>\n</head>\n<body>\n  <h1>Using Angular Custom Element</h1>\n  <hello-world name=\"Angular\"></hello-world>\n  <script>\n    const hW = document.querySelector('hello-world');\n    hW.addEventListener('action', function() {\n      // ...\n    })\n  <\/script>\n</body>\n</html>\n"))))}y.isMDXComponent=!0;const v={toc:[]},C="wrapper";function w(e){let{components:n,...t}=e;return(0,o.kt)(C,(0,a.Z)({},v,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("details",{open:!0},(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Angular Built-In Directives")),(0,o.kt)("p",null,"Angular has a number of built-in directives that can be used to change the appearance and behavior of HTML elements. These directives are divided into two categories: attribute directives and structural directives."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Attribute directives")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngClass")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngStyle")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngModel")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngForm")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngControl")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngDisabled")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngReadonly")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngChange")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngSubmit")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngInit")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngDoCheck")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngAfterViewInit")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngAfterContentInit")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngAfterContentChecked")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngAfterViewChecked"))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Structural directives")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngIf")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngFor")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngSwitch")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngSwitchCase")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngSwitchDefault")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngTemplateOutlet")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngTemplateRef")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngContent")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngOutletContext")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngOutletHost")))),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Angular Built-In Attribute Directives")),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"Directive")),(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"Description")),(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"Example")))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"ngClass")),(0,o.kt)("td",{parentName:"tr",align:null},"Adds and removes CSS classes from an element."),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"<div [ngClass]=\"{'active': isActive}\"></div>"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"ngStyle")),(0,o.kt)("td",{parentName:"tr",align:null},"Sets inline styles on an element."),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"<div [ngStyle]=\"{'color': color}\"></div>"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"ngModel")),(0,o.kt)("td",{parentName:"tr",align:null},"Adds two-way data binding to an HTML form element."),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},'<input type="text" [(ngModel)]="name"></input>'))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"ngForm")),(0,o.kt)("td",{parentName:"tr",align:null},"Creates a form object that can be used to validate and submit form data."),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},'<form [ngForm]="form"></form>'))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"ngControl")),(0,o.kt)("td",{parentName:"tr",align:null},"Creates a control object that can be used to validate and submit form data."),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},'<input type="text" [ngControl]="name"></input>'))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"ngDisabled")),(0,o.kt)("td",{parentName:"tr",align:null},"Disables an element."),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},'<button [ngDisabled]="isDisabled">Click me</button>'))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"ngReadonly")),(0,o.kt)("td",{parentName:"tr",align:null},"Makes an element read-only."),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},'<input type="text" [ngReadonly]="isReadonly"></input>'))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"ngChange")),(0,o.kt)("td",{parentName:"tr",align:null},"Called when the value of an input element changes."),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},'<input type="text" [(ngModel)]="name" (ngChange)="onNameChange($event)"></input>'))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"ngSubmit")),(0,o.kt)("td",{parentName:"tr",align:null},"Called when the user submits a form."),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},'<form [ngForm]="form" (ngSubmit)="onSubmit($event)"></form>')))))),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Angular Built-In Structural Directives")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"ngIf"),": Conditionally renders an element. "),(0,o.kt)("p",{parentName:"li"},"Example: ",(0,o.kt)("inlineCode",{parentName:"p"},'<div *ngIf="isVisible">This element will be rendered if isVisible is true</div>'))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"ngFor"),": Repeats an element for each item in an array. Example:\n",(0,o.kt)("inlineCode",{parentName:"p"},'<div *ngFor="let item of items">This element will be repeated for each item in the items array</div>'))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"ngSwitch"),": Switches between different views based on a value. Example: "),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<div [ngSwitch]="value">\n  <br>\n  <div *ngSwitchCase="\'1\'">This view will be rendered if value is 1</div>\n  <div *ngSwitchCase="\'2\'">This view will be rendered if value is 2</div>\n  <div *ngSwitchDefault>This view will be rendered if value is anything else</div>\n</div>\n'))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"ngSwitchCase"),": Specifies a view to be rendered by the ngSwitch directive. Example: ",(0,o.kt)("inlineCode",{parentName:"p"},"<div *ngSwitchCase=\"'1'\">This view will be rendered if value is 1</div>"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"ngSwitchDefault"),": Specifies a view to be rendered by the ngSwitch directive if no other cases match. Example: ",(0,o.kt)("inlineCode",{parentName:"p"},"<div *ngSwitchDefault>This view will be rendered if value is anything else</div>"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"ngTemplateOutlet"),": Inserts the content of a template into the current view. Example:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'@Component({\n  selector: \'my-app\',\n  template: `      \n<ng-template #estimateTemplate let-lessonsCounter="estimate">\n    <div> Approximately {{lessonsCounter}} lessons ...</div>\n</ng-template>\n<ng-container \n  *ngTemplateOutlet="estimateTemplate;context:ctx">\n</ng-container>\n`})\nexport class AppComponent {\n\n    totalEstimate = 10;\n    ctx = {estimate: this.totalEstimate};\n  \n}\n')),(0,o.kt)("p",{parentName:"li"},"  or"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"<div *ngTemplateOutlet=\"template; context: { item: item }; host: { 'id': 'my-id', 'style': 'color: red' }\"></div>\n")),(0,o.kt)("p",{parentName:"li"},"  This will create a div with the id my-id and the style color: red as the host element.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"ngContent"),": Inserts the content of a child element into the current view. Example: ",(0,o.kt)("inlineCode",{parentName:"p"},'<div *ngFor="let item of items"> <div [ngContent]="item"></div> </div>'))))),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Standalone Directives (Directive Composition)")),(0,o.kt)("p",null,"Standalone directives are directives that ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"do not need to be declared in an NgModule"))," and do not depend on any intermediate context of an NgModule. You can use ",(0,o.kt)("inlineCode",{parentName:"p"},"hostDirectives")," to ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"compose multiple behaviors on a host element"))," without duplicating them in the template."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"@Component({\n  selector: 'admin-menu',\n  template: `\n    <admin-menu id=\"top-menu\" (closed)=\"logMenuClosed()\">\n  `,\n  hostDirectives: [{\n    directive: MenuBehavior,\n    inputs: ['menuId: id'],\n    outputs: ['menuClosed: closed'],\n  }],\n})\nexport class AdminMenu { }\n")),(0,o.kt)("p",null,"Here's the directive"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"import { Directive, ElementRef, EventEmitter, HostListener, Input, Output } from '@angular/core';\n\n@Directive({\n  selector: '[menuBehavior]',\n  standalone: true // this is required for hostDirectives\n})\nexport class MenuBehavior {\n  @Input() menuId: string; // this will be aliased as id on the host element\n  @Output() menuClosed = new EventEmitter<void>(); // this will be aliased as closed on the host element\n\n  constructor(private elementRef: ElementRef) {}\n\n  @HostListener('click')\n  onClick() {\n    // toggle the menu visibility\n    this.elementRef.nativeElement.classList.toggle('open');\n  }\n\n  @HostListener('document:click', ['$event'])\n  onDocumentClick(event: Event) {\n    // close the menu if clicked outside\n    if (!this.elementRef.nativeElement.contains(event.target)) {\n      this.elementRef.nativeElement.classList.remove('open');\n      this.menuClosed.emit(); // emit the menuClosed event\n    }\n  }\n}\n\n"))))}w.isMDXComponent=!0;const b={toc:[]},x="wrapper";function A(e){let{components:n,...r}=e;return(0,o.kt)(x,(0,a.Z)({},b,r,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("details",{open:!0},(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Angular Dependency Injection")),(0,o.kt)("p",null,"Angular uses dependency injection (DI) to provide components and services with their required dependencies. Dependencies are passed as parameters to the class (component, sevice) constructor. The DI framework ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"looks for a provider of the dependency in the injector hierarchy")),", starting from the component\u2019s own injector and going up to the root injector if needed. The DI framework creates and injects the dependencies based on the Inversion of Control (IoC) principle, which separates the consumers and providers of dependencies for better testing and maintenance."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Angular Dependency Injection",src:t(7802).Z,width:"1155",height:"645"}))),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("h5",null,"@Self() vs @Optional() vs @SkipSelf() vs @Host()")),(0,o.kt)("p",null,"These are Angular decorators that modify how the dependency injection framework resolves dependencies. Here is a brief explanation and example for each:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@Self()")," tells Angular to ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"look for the dependency only in the local injector of the current component"))," or directive. For example:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"@Component({\n  selector: 'my-grandChild',\n  template: `\n    <div class=\"box\">\n      GrandChildComponent => {{ randomNo }}\n    </div>\n  `,\n  providers: [RandomService]\n})\nexport class GrandChildComponent {\n  randomNo: number;\n  constructor(@Self() private randomService: RandomService) {\n    this.randomNo = this.randomService.getRandom();\n  }\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@Optional()")," tells Angular to assign null to the dependency if it is not found. For example:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"@Component({\n  selector: 'my-grandChild',\n  template: `\n    <div class=\"box\">\n      GrandChildComponent => {{ randomNo }}\n    </div>\n  `\n})\nexport class GrandChildComponent {\n  randomNo: number;\n  constructor(@Optional() private randomService: RandomService) {\n    this.randomNo = this.randomService ? this.randomService.getRandom() : null;\n  }\n}\n")),(0,o.kt)("p",null,"In this example, if ",(0,o.kt)("inlineCode",{parentName:"p"},"RandomService")," is not provided by any injector, Angular will not throw an error but assign ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"randomService")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@SkipSelf()")," tells Angular to ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"skip the local injector of the current component"))," or directive and look for the dependency in its parent injectors. For example:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"@Component({\n  selector: 'my-grandChild',\n  template: `\n    <div class=\"box\">\n      GrandChildComponent => {{ randomNo }}\n    </div>\n  `\n})\nexport class GrandChildComponent {\n  randomNo: number;\n  constructor(@SkipSelf() private randomService: RandomService) {\n    this.randomNo = this.randomService.getRandom();\n  }\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@Host()")," tells Angular to ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"look for the dependency in the local injector of the current component or directive and its host component")),". For example:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"@Component({\n  selector: 'my-grandChild',\n  template: `\n    <div class=\"box\">\n      GrandChildComponent => {{ randomNo }}\n    </div>\n    <testDirective></testDirective>\n  `,\n  providers: [RandomService]\n})\nexport class GrandChildComponent {\n  randomNo: number;\n  constructor(private randomService: RandomService) {\n    this.randomNo = this.randomService.getRandom();\n  }\n}\n\n@Directive({\n  selector: 'testDirective'\n})\nexport class TestDirective {\n  randomNo: number;\n  constructor(@Host() private randomService: RandomService) {\n    this.randomNo = this.randomService.getRandom();\n  }\n}\n"))),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("h5",null,"providers vs. viewProviders")),(0,o.kt)("p",null,"providers and viewProviders are properties of the ",(0,o.kt)("inlineCode",{parentName:"p"},"@Component")," decorator that specify where Angular can find the providers of the dependencies for the component. The difference is that ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"providers are available to both view children and content children of the component")),", while ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"viewProviders are only available to view children")),". View children are the elements that are defined in the component's template, while content children are the elements that are projected into the component using ",(0,o.kt)("inlineCode",{parentName:"p"},"<ng-content>"),". For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"@Component({\n  selector: 'my-parent',\n  template: `\n    <div class=\"box\">\n      ParentComponent => {{ randomNo }}\n    </div>\n    <my-child></my-child>\n    <ng-content></ng-content>\n  `,\n  providers: [RandomService]\n})\nexport class ParentComponent {\n  randomNo: number;\n  constructor(private randomService: RandomService) {\n    this.randomNo = this.randomService.getRandom();\n  }\n}\n\n@Component({\n  selector: 'my-child',\n  template: `\n    <div class=\"box\">\n      ChildComponent => {{ randomNo }}\n    </div>\n  `\n})\nexport class ChildComponent {\n  randomNo: number;\n  constructor(private randomService: RandomService) {\n    this.randomNo = this.randomService.getRandom();\n  }\n}\n\n@Component({\n  selector: 'my-grandChild',\n  template: `\n    <div class=\"box\">\n      GrandChildComponent => {{ randomNo }}\n    </div>\n  `\n})\nexport class GrandChildComponent {\n  randomNo: number;\n  constructor(private randomService: RandomService) {\n    this.randomNo = this.randomService.getRandom();\n  }\n}\n")),(0,o.kt)("p",null,"In this example, RandomService is provided by ParentComponent using providers. This means that both ChildComponent and GrandChildComponent can inject RandomService as their dependencies. ChildComponent is a view child of ParentComponent, while GrandChildComponent is a content child of ParentComponent (projected using ",(0,o.kt)("inlineCode",{parentName:"p"},"<ng-content>"),")."),(0,o.kt)("p",null,"If we change providers to viewProviders in ParentComponent, then only ChildComponent can inject RandomService, but not GrandChildComponent. This is because viewProviders limits the provider to view children only. This can be useful to prevent projected content from interfering with your services.")),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("h5",null,"@SkipSelf() and @Host() in viewProviders")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"@SkipSelf() and viewProviders"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"@Component({\n  selector: 'app-child',\n  viewProviders:\n  [{ provide: AnimalService, useValue: { emoji: '\ud83d\udc36' } }]\n})\nexport class ChildComponent {\n\n  // add @SkipSelf()\n  constructor(@SkipSelf() public animal : AnimalService) { }\n\n}\n")),(0,o.kt)("p",null,"The logical tree looks like this with @SkipSelf() in ",(0,o.kt)("inlineCode",{parentName:"p"},"<app-child>"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<app-root @NgModule(AppModule)\n          @Inject(AnimalService=>"\ud83d\udc33")>\n  <#VIEW>\x3c!-- search begins here and up --\x3e\n    <app-child>\n      <#VIEW @Provide(AnimalService="\ud83d\udc36")\n             @Inject(AnimalService, SkipSelf=>"\ud83d\udc33")>\n        \x3c!--Add @SkipSelf --\x3e\n      </#VIEW>\n    </app-child>\n  </#VIEW>\n</app-root>\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"@Host() and viewProviders"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"@Component({\n  selector: 'app-child',\n  \u2026\n  viewProviders:\n  [{ provide: AnimalService, useValue: { emoji: '\ud83d\udc36' } }]\n\n})\nexport class ChildComponent {\n  constructor(@Host() public animal : AnimalService) { }\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<app-root @NgModule(AppModule)\n          @Inject(AnimalService=>"\ud83d\udc33")>\n  <#VIEW>\n    <app-child>\n      <#VIEW @Provide(AnimalService="\ud83d\udc36")\n             @Inject(AnimalService, @Host=>"\ud83d\udc36")> \x3c!-- @Host stops search here: because AnimalService is provided here so Angular does not look further up the injector hierarchy --\x3e\n      </#VIEW>\n    </app-child>\n  </#VIEW>\n</app-root>\n'))))}A.isMDXComponent=!0;const T={toc:[{value:"Example 1",id:"example-1",level:4},{value:"Example 2",id:"example-2",level:4}]},S="wrapper";function M(e){let{components:n,...t}=e;return(0,o.kt)(S,(0,a.Z)({},T,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("details",{open:!0},(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Angular Animation")),(0,o.kt)("p",null,"Animation is ",(0,o.kt)("inlineCode",{parentName:"p"},"transition")," from a ",(0,o.kt)("inlineCode",{parentName:"p"},"state")," to another ",(0,o.kt)("inlineCode",{parentName:"p"},"state"),"."),(0,o.kt)("h4",{id:"example-1"},"Example 1"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"@Component({\n  template: `<div [@openClose]=\"isOpen ? true : false\" class=\"open-close-container\"></div>`\n  animations: [\n    trigger('openClose', [\n      state('true', style({ height: '*' })),\n      state('false', style({ height: '0px' })),\n      transition('false <=> true', animate(500))\n    ])\n  ]\n})\n")),(0,o.kt)("h4",{id:"example-2"},"Example 2"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"@Component({\n  template: `<my-element [@filterAnimation]=\"heroesTotal\"></my-element>`,\n  animations: [\n    trigger('filterAnimation', [\n      // [] means no animation will happen when the element enters the DOM, or when the expression bound to the trigger changes from any value to 0 or -1\n      transition(':enter, * => 0, * => -1', []),\n      transition(':increment', [\n        query(':enter', [\n          style({ opacity: 0, width: 0 }),\n          stagger(50, [\n            animate('300ms ease-out', style({ opacity: 1, width: '*' })),\n          ]),\n        ], { optional: true })\n      ]),\n      transition(':decrement', [\n        query(':leave', [\n          stagger(50, [\n            animate('300ms ease-out', style({ opacity: 0, width: 0 })),\n          ]),\n        ])\n      ]),\n    ]),\n  ]\n})\nexport class HeroListPageComponent implements OnInit {\n  heroesTotal = 1; // or -1\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"trigger():")," This function ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"creates an animation trigger")),". An animation trigger is a name that can be used to refer to a set of animation steps."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"transition():")," defines ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"how an element moves from one state to another")),". There are three transitions:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},":enter:")," This transition is used to animate the element when it ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"is created")),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},":increment:")," This transition is used to animate the element ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"when its width is increased")),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},":decrement:")," This transition is used to animate the element ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"when its width is decreased")),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},":leave"),": is to specify that the animation should be triggered when the element leaves the document flow."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"animate():")," This function ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"defines an animation step")),". An animation step defines the initial and final styles of an element and the duration and easing curve of the animation.",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"  transition('* => *', [\n    animate('1s', keyframes ( [\n      style({ opacity: 0.1, offset: 0.1 }), // the opacity of the element will be 0.1 when 10% of the animation time has elapsed\n      style({ opacity: 0.6, offset: 0.2 }),\n      style({ opacity: 1,   offset: 0.5 }),\n      style({ opacity: 0.2, offset: 0.7 })\n    ]))\n  ])\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"query():")," This function ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"queries all elements that match a certain criteria")),". The ",(0,o.kt)("inlineCode",{parentName:"li"},"query()")," function in Angular animation takes the following parameters:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"element:")," The element to query, or a set of elements that contain Angular-specific characteristics, specified with one or more of the following tokens:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},":enter"),": Query an element enters the viewport."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},":leave"),": Query an element leaves the viewport. Example, ",(0,o.kt)("inlineCode",{parentName:"li"},"query(':enter, :leave', [...])")," when an element enters or leaves the viewport"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},":animating")," : Query all currently animating elements."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@triggerName")," : Query elements that contain an animation trigger."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@*"),": Query all elements that contain animation triggers. If you use it on template like this ",(0,o.kt)("inlineCode",{parentName:"li"},'<div [@.disabled]="true">'),", it means disable all children's animations."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},":self"),": Include the current element into the animation sequence."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"options:")," An object that can be used to control the behavior of the query. The following options are supported:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"deep:")," If true, the query will recurse into child elements."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"children:")," If true, the query will only return child elements."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"exclude:")," An array of element names that should be excluded from the query.")))),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'const childElementsWithoutFoo = query(":self", { deep: true, exclude: ["foo"] });\n'))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"stagger():")," This function allows you to ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"define a timing gap between each animated element")),". In the above code, the stagger() function is used to add a 50 millisecond delay between each animation."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"group():")," Runs multiple animation steps ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"in parallel")),".",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'group([\n  animate("1s", style({ background: "black" })),\n  animate("2s", style({ color: "white" }))\n])\n'))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"sequence():")," This function allows you to ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"play multiple animation steps in sequence")),".",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'sequence([\n  style({ opacity: 0 }),\n  animate("1s", style({ opacity: 1 }))\n])\n'))))),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Route transition animations")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"@NgModule({\n  imports: [\n    RouterModule.forRoot([\n      {\n        path: 'home',\n        component: HomeComponent,\n        data: { animation: 'HomePage' }\n      },\n      {\n        path: 'about',\n        component: AboutComponent,\n        data: { animation: 'AboutPage' }\n      },\n    ])\n  ],\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const slideInAnimation =\n  trigger('routeAnimations', [\n    transition('HomePage <=> AboutPage', [\n      style({ position: 'relative' }),\n      query(':enter, :leave', [\n        style({\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%'\n        })\n      ]),\n    ])\n  ]);\n\n@Component({\n  template: `\n    <div [@routeAnimations]=\"getRouteAnimationData()\">\n      <router-outlet></router-outlet>\n    </div>\n  `,\n  animations: [\n    slideInAnimation\n  ]\n})\nclass AppComponent {\n  constructor(private contexts: ChildrenOutletContexts) {}\n\n  getRouteAnimationData() {\n    return this.contexts.getContext('primary')?.route?.snapshot?.data?.['animation'];\n  }\n}\n"))))}M.isMDXComponent=!0;const I={toc:[]},D="wrapper";function j(e){let{components:n,...t}=e;return(0,o.kt)(D,(0,a.Z)({},I,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("details",{open:!0},(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Ivy Rendering Engine In Angular")),(0,o.kt)("p",null,"Ivy is the new rendering engine for Angular that compiles and converts Angular code (template HTML + TS) into pure HTML and JavaScript that the browser understands. ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"Ivy works by using incremental DOM and locality principle"))," to optimize the compilation and rendering process."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Incremental DOM")," means that Ivy ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"only updates the parts of the DOM that have changed, rather than recreating the entire DOM tree")),". This improves performance and memory usage.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Locality principle")," means that Ivy only ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"compiles the components that are needed for rendering")),", rather than compiling all the components in an ",(0,o.kt)("inlineCode",{parentName:"p"},"NgModule"),". This reduces the bundle size and enables faster recompilation."))),(0,o.kt)("p",null,"Ivy also supports ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"tree shaking, template type checking, and improved debugging tools")),"."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Tree shaking")," means that Ivy removes any unused code or dependencies from the final bundle, reducing its size and improving performance.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Template type checking")," means that Ivy checks for errors and inconsistencies in the templates at compile time, rather than at runtime.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Improved debugging tools")," means that Ivy provides new functions such as ",(0,o.kt)("inlineCode",{parentName:"p"},"ng.probe")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ng.getComponent"),", which allow you to inspect and manipulate the components and their properties in the browser console.")))),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Annotations vs Decorators in Angular")),(0,o.kt)("p",null,"Annotations and decorators are both used to add metadata to code in Angular. However, there are some key differences between the two."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Annotations")," are ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"static metadata"))," that is ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"added to code at compile time")),". They are simply strings that are attached to a declaration, such as a class, method, or property. Annotations create an ",(0,o.kt)("inlineCode",{parentName:"p"},"annotations")," array on the class using the ",(0,o.kt)("inlineCode",{parentName:"p"},"Reflect Metadata library"),". Annotations ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"do not change the behavior of the code")),", but they can be used by tools and frameworks to provide information about the code. Annotations (which are commonly used in Angular 1) are still supported in Angular, ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"but they are not as commonly used as decorators & you need to hardcorded to use them")),"."),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"import {\n    ComponentAnnotation as Component,\n} from '@angular/core';\n\n")),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"export class ComponentAnnotation extends DirectiveMetadata {\n    constructor() {\n        \n    }\n}\n\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Decorators")," are ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"dynamic metadata"))," that is ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"added to code at runtime")),". They are functions ( using the ",(0,o.kt)("inlineCode",{parentName:"p"},"Reflect.defineMetadata")," method) that are called when the decorated code is executed. Decorators can be used to ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"change the behavior of the code")),", such as by adding functionality or injecting dependencies. There are different types of decorators:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Class Decorator")," : @Component"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Method Decorator"),": @HostListener"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Property Decorator"),": @Input/@Output"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Parameter Decorator"),": @Inject"))))),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Pure Pipes vs Impure Pipes in angular")),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Pure Pipes"),(0,o.kt)("th",{parentName:"tr",align:null},"Impure Pipes"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Only executed when the value or parameter(s) changes"),(0,o.kt)("td",{parentName:"tr",align:null},"Executed on every change detection cycle")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Detect changes to primitive values or object references"),(0,o.kt)("td",{parentName:"tr",align:null},"Detect changes within objects or external factors")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Must be pure functions with no side effects"),(0,o.kt)("td",{parentName:"tr",align:null},"Can have side effects or depend on other values")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"More efficient and performant"),(0,o.kt)("td",{parentName:"tr",align:null},"More flexible and powerful")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Default for all pipes"),(0,o.kt)("td",{parentName:"tr",align:null},"Need to set pure property to false in the pipe decorator")))),(0,o.kt)("p",null,"Here is a code snippet of an impure filter pipe:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'filter',\n  pure: false // make it impure\n})\nexport class FilterPipe implements PipeTransform {\n\n  transform(items: any[], filter: string): any[] {\n    if (!items || !filter) {\n      return items;\n    }\n    // filter items array, items which match and return true will be kept, false will be filtered out\n    return items.filter(item => item.name.indexOf(filter) !== -1);\n  }\n}\n\n")),(0,o.kt)("p",null,"The impure pipe will be executed whenever the change detection cycle runs, regardless of whether the ",(0,o.kt)("inlineCode",{parentName:"p"},"items")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"filter")," have changed or not. If you want the pipe to be executed only when the items or filter change, you need to make it pure.")),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("h5",null,"@ViewChild, @ViewChildren")),(0,o.kt)("p",null,"@ViewChild and @ViewChildren are decorators that allow you to access the child elements or components of a parent component. They are useful when you need to manipulate the DOM elements or communicate with the child components."),(0,o.kt)("p",null,"The arguments of @ViewChild and @ViewChildren are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The first argument is the ",(0,o.kt)("strong",{parentName:"li"},"selector")," of the element or component to query. It can be one of the following types:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"A ",(0,o.kt)("strong",{parentName:"li"},"string")," that matches the name of a local template variable, a directive type, or a component type."),(0,o.kt)("li",{parentName:"ul"},"A ",(0,o.kt)("strong",{parentName:"li"},"function")," that returns the directive or component type."),(0,o.kt)("li",{parentName:"ul"},"A ",(0,o.kt)("strong",{parentName:"li"},"template reference variable")," as an expression, such as ",(0,o.kt)("inlineCode",{parentName:"li"},"#myVar")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"ref-myVar"),"."))),(0,o.kt)("li",{parentName:"ul"},"The second argument is an ",(0,o.kt)("strong",{parentName:"li"},"options object")," that has the following properties:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"read"),": This property specifies what token should be read from the queried element or component. For example, you can use ",(0,o.kt)("inlineCode",{parentName:"li"},"read: ElementRef")," to get the ",(0,o.kt)("inlineCode",{parentName:"li"},"ElementRef")," instance of the element, or ",(0,o.kt)("inlineCode",{parentName:"li"},"read: ViewContainerRef")," to get the ",(0,o.kt)("inlineCode",{parentName:"li"},"ViewContainerRef")," instance of the element. If you omit this property, Angular will try to infer the best option based on the selector type."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"static"),": This property indicates whether the query should be resolved before change detection runs. If set to ",(0,o.kt)("inlineCode",{parentName:"li"},"true"),", the query will be ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"resolved once and not updated later")),". If set to ",(0,o.kt)("inlineCode",{parentName:"li"},"false"),", the query will be ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"resolved after change detection runs, and updated if the query results change")),". This property is only available for @ViewChild, not for @ViewChildren.")))),(0,o.kt)("p",null,"Here are some examples of how to use @ViewChild and @ViewChildren with different arguments:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Using @ViewChild with a string selector and no options object:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { Component, ViewChild } from '@angular/core';\nimport { ChildComponent } from './child.component';\n\n@Component({\n  selector: 'app-parent',\n  template: `\n    <h2>Parent Component</h2>\n    <app-child></app-child>\n  `,\n})\nexport class ParentComponent {\n  // Get a reference to the child component by its type\n  @ViewChild(ChildComponent) child: ChildComponent;\n\n  ngAfterViewInit() {\n    // Access the child component properties or methods\n    console.log(this.child.message); // Hello from child\n    this.child.greet(); // Greet from child\n  }\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Using @ViewChild with a template reference variable and an options object:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { Component, ViewChild, ElementRef } from '@angular/core';\n\n@Component({\n  selector: 'app-parent',\n  template: `\n    <h2>Parent Component</h2>\n    <div #myDiv>Some content</div>\n  `,\n})\nexport class ParentComponent {\n  // Get a reference to the div element by its template reference variable\n  // Specify that we want to read its ElementRef instance\n  @ViewChild('myDiv', { read: ElementRef }) myDiv: ElementRef;\n\n  ngAfterViewInit() {\n    // Access the native element of the div\n    console.log(this.myDiv.nativeElement); // <div _ngcontent-c0>Some content</div>\n  }\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Using @ViewChildren with a function selector and no options object:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { Component, ViewChildren, QueryList } from '@angular/core';\nimport { Pane } from './pane.directive';\n\n@Component({\n  selector: 'app-parent',\n  template: `\n    <h2>Parent Component</h2>\n    <div pane id=\"1\">Pane 1</div>\n    <div pane id=\"2\">Pane 2</div>\n    <div pane id=\"3\">Pane 3</div>\n  `,\n})\nexport class ParentComponent {\n  // Get a list of references to the elements with the pane directive\n  // Use a function that returns the directive type as the selector\n  @ViewChildren(Pane) panes: QueryList<Pane>;\n\n  ngAfterViewInit() {\n    // Iterate over the elements with the pane directive\n    this.panes.forEach((pane) => {\n      // Access the pane directive properties or methods\n      console.log(pane.id); // 1, then 2, then 3\n      pane.doSomething(); // Do something with each pane\n    });\n  }\n}\n"))))}j.isMDXComponent=!0;const E={toc:[]},O="wrapper";function R(e){let{components:n,...r}=e;return(0,o.kt)(O,(0,a.Z)({},E,r,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("details",{open:!0},(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Lifecycle Hooks")),(0,o.kt)("p",null,"  ","*",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"\u25d4\u032f\u25d4")),"*"," :\nIn Angular, every component instance has a lifecycle which is phases from initialization the component -> rendering it's view along with its child views to destroying the component instance and removes its rendered template from the DOM. Along with these phases Angular provides hooks to tap into to change or add your custom functions at specific phases in a lifecycle."),(0,o.kt)("p",null,"There's 8 lifecycle hooks in ANgular"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Angular Lifcycle hooks",src:t(72102).Z,width:"1740",height:"940"}))),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("h5",null,"ngAfterContentCheck")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"ngAfterContentChecked")," is a lifecycle hook that is ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"called after Angular checks the content projected into the component")),". It will run after the content has been checked and most of the time it's during a change detection cycle."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},'What does "Angular checks the content" mean?')," It means that Angular ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"compares the current state of the content with the previous state and updates the view accordingly")),". The content is the part of the template that is inserted by another component using the ",(0,o.kt)("inlineCode",{parentName:"p"},"<ng-content>")," directive.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"When does Angular check the content?")," Initially, after the ngAfterContentInit hook finishes. ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"Every time the change detection is run (application state change)")),". What causes the application state change? Events - click, submit, etc. Ajax calls - fetching data from a remote server Timers - setTimeout, setInterval, etc.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Why use ",(0,o.kt)("inlineCode",{parentName:"strong"},"ngAfterContentChecked"),"?")," You can use this hook to perform any custom logic or actions after the content has been checked and updated. For example, you can access and manipulate the content children using the @ContentChild and ",(0,o.kt)("inlineCode",{parentName:"p"},"@ContentChildren")," decorators."))),(0,o.kt)("p",null,"Here is an example of how to use ",(0,o.kt)("inlineCode",{parentName:"p"},"ngAfterContentChecked")," in Angular:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { Component, AfterContentChecked, ContentChild } from '@angular/core';\n\n@Component({\n  selector: 'app-parent',\n  template: `\n    <h2>Parent Component</h2>\n    <ng-content></ng-content>\n  `,\n})\nexport class ParentComponent implements AfterContentChecked {\n  @ContentChild('child') child; // get a reference to the child element\n\n  ngAfterContentChecked() {\n    console.log('ngAfterContentChecked');\n    console.log(this.child); // log the child element\n  }\n}\n\n@Component({\n  selector: 'app-child',\n  template: `\n    <h3 #child>Child Component</h3>\n  `,\n})\nexport class ChildComponent {}\n"))),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Order of lifecycle running of nested components")),(0,o.kt)("p",null,"The order of lifecycle running of nested components in Angular is determined by the order of creation and destruction of the components. Angular creates and destroys components in a ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"depth-first manner, which means it goes from the parent to the child, and then back to the parent")),"."),(0,o.kt)("p",null,"For example, if you have a nested component structure like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},"<app-parent>\n  <app-child>\n    <app-grandchild></app-grandchild>\n  </app-child>\n</app-parent>\n")),(0,o.kt)("p",null,"The order of lifecycle running of these components would be:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"When creating components:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"app-parent: ngOnChanges, ngOnInit, ngDoCheck, ngAfterContentInit, ngAfterContentChecked"),(0,o.kt)("li",{parentName:"ul"},"app-child: ngOnChanges, ngOnInit, ngDoCheck, ngAfterContentInit, ngAfterContentChecked"),(0,o.kt)("li",{parentName:"ul"},"app-grandchild: ngOnChanges, ngOnInit, ngDoCheck, ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked"),(0,o.kt)("li",{parentName:"ul"},"app-child: ngAfterViewInit, ngAfterViewChecked"),(0,o.kt)("li",{parentName:"ul"},"app-parent: ngAfterViewInit, ngAfterViewChecked"))),(0,o.kt)("li",{parentName:"ul"},"When destroying components:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"app-parent: ngOnDestroy"),(0,o.kt)("li",{parentName:"ul"},"app-child: ngOnDestroy"),(0,o.kt)("li",{parentName:"ul"},"app-grandchild: ngOnDestroy"))))))}R.isMDXComponent=!0;const P={toc:[]},F="wrapper";function H(e){let{components:n,...t}=e;return(0,o.kt)(F,(0,a.Z)({},P,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Testing Component with Async Service")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Component with Async Service"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Component, OnInit } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Component({\n  selector: 'my-component',\n  templateUrl: './my-component.component.html',\n  styleUrls: ['./my-component.component.css']\n})\nexport class MyComponent implements OnInit {\n\n  constructor(private http: HttpClient) {}\n\n  ngOnInit() {\n    this.getQuote();\n  }\n\n  getQuote() {\n    // This is an asynchronous call\n    this.http.get('https://api.chucknorris.io/jokes/random')\n      .subscribe(\n        (data: any) => {\n          this.quote = data.value;\n        },\n        (error: any) => {\n          this.errorMessage = error;\n        }\n      );\n  }\n\n  quote: string;\n  errorMessage: string;\n}\n"))),(0,o.kt)("p",null,"The test for this component would look something like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import { async, flush } from '@angular/core/testing';\nimport { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { MyComponent } from './my-component.component';\n\ndescribe('MyComponent', () => {\n  let component: MyComponent;\n  let fixture: ComponentFixture<MyComponent>;\n\n  beforeEach(async(() => {\n    TestBed.configureTestingModule({\n      declarations: [MyComponent]\n    })\n      .compileComponents();\n\n    fixture = TestBed.createComponent(MyComponent);\n    component = fixture.componentInstance;\n  }));\n\n  it('should show the quote after the async call', async(() => {\n    // Wait for the async call to complete\n    await fixture.whenStable();\n\n    expect(component.quote).toBeDefined();\n  }));\n});\n")),(0,o.kt)("p",null,"This test uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"async")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"whenStable")," functions to wait for the async call to complete before asserting that the ",(0,o.kt)("inlineCode",{parentName:"p"},"quote")," property is defined."),(0,o.kt)("p",null,"Here is a breakdown of what the test is doing:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"beforeEach")," function configures the testing module and compiles the components."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"it")," function defines the test."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"async")," function tells Angular to treat the test as an asynchronous function."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"fixture.whenStable()")," function waits for all asynchronous tasks to complete."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"expect(component.quote).toBeDefined()")," assertion checks that the ",(0,o.kt)("inlineCode",{parentName:"li"},"quote")," property is defined."))),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("h5",null,"Testing with Spy")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Component with Async Service"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Component, OnInit } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Component({\n  selector: 'my-component',\n  templateUrl: './my-component.component.html',\n  styleUrls: ['./my-component.component.css']\n})\nexport class MyComponent implements OnInit {\n\n  constructor(private http: HttpClient) {}\n\n  ngOnInit() {\n    this.getQuote();\n  }\n\n  getQuote() {\n    // This is an asynchronous call\n    this.http.get('https://api.chucknorris.io/jokes/random')\n      .subscribe(\n        (data: any) => {\n          this.quote = data.value;\n        },\n        (error: any) => {\n          this.errorMessage = error;\n        }\n      );\n  }\n\n  quote: string;\n  errorMessage: string;\n}\n"))),(0,o.kt)("p",null,"The test for this component would look something like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import { async, flush, spyOn } from '@angular/core/testing';\nimport { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { MyComponent } from './my-component.component';\n\ndescribe('MyComponent', () => {\n  let component: MyComponent;\n  let fixture: ComponentFixture<MyComponent>;\n  let spy: any;\n\n  beforeEach(async(() => {\n    TestBed.configureTestingModule({\n      declarations: [MyComponent]\n    })\n      .compileComponents();\n\n    fixture = TestBed.createComponent(MyComponent);\n    component = fixture.componentInstance;\n\n    spy = spyOn(component.http, 'get');\n  }));\n\n  it('should call the getQuote() method', async(() => {\n    // The spy will be called when the getQuote() method is called\n    expect(spy).toHaveBeenCalled();\n  }));\n\n  it('should return a quote from the API', async(() => {\n    // The spy will return a mocked quote\n    spy.and.returnValue({\n      value: 'This is a Chuck Norris quote'\n    });\n\n    await fixture.whenStable();\n\n    expect(component.quote).toEqual('This is a Chuck Norris quote');\n  }));\n});\n")),(0,o.kt)("p",null,"This test uses a spy to check that the ",(0,o.kt)("inlineCode",{parentName:"p"},"getQuote()")," method is called and that it returns a quote from the API."),(0,o.kt)("p",null,"Here is a breakdown of what the test is doing:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"beforeEach")," function configures the testing module and compiles the components."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"it")," function defines the test."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"spyOn")," function creates a spy on the ",(0,o.kt)("inlineCode",{parentName:"li"},"get")," method of the ",(0,o.kt)("inlineCode",{parentName:"li"},"http")," service."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"and.returnValue")," function tells the spy to return a mocked quote."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"await fixture.whenStable()")," function waits for all asynchronous tasks to complete."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"expect(component.quote).toEqual('This is a Chuck Norris quote')")," assertion checks that the ",(0,o.kt)("inlineCode",{parentName:"li"},"quote")," property is equal to the mocked quote."))),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Async test with fakeAsync()"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"import { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { fakeAsync, tick } from '@angular/core/testing';\nimport { MyComponent } from './my.component';\n\ndescribe('MyComponent', () => {\n  let component: MyComponent;\n  let fixture: ComponentFixture<MyComponent>;\n\n  beforeEach(async () => {\n    TestBed.configureTestingModule({\n      declarations: [MyComponent]\n    });\n    fixture = await TestBed.createComponent(MyComponent);\n    component = fixture.componentInstance;\n  });\n\n  it('should load data asynchronously', fakeAsync(() => {\n    // Simulate loading data asynchronously.\n    setTimeout(() => {\n      component.dataLoaded = true;\n    }, 1000);\n\n    // Wait for the data to load.\n    tick(1000);\n\n    // Assert that the data is loaded.\n    expect(component.dataLoaded).toBeTruthy();\n  }));\n});\n")),(0,o.kt)("p",null,"This test uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"fakeAsync()")," function to wrap the test body in a special zone that allows us to control the execution of asynchronous code. The ",(0,o.kt)("inlineCode",{parentName:"p"},"tick()")," function is used to advance the virtual clock by a set amount of time. In this case, we are using ",(0,o.kt)("inlineCode",{parentName:"p"},"tick()")," to wait for the data to load before asserting that it is loaded.")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Async test with fakeAsync()"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"import { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { fakeAsync, tick } from '@angular/core/testing';\nimport { jasmine } from '@jasmine/core';\nimport { MyComponent } from './my.component';\n\ndescribe('MyComponent', () => {\n  let component: MyComponent;\n  let fixture: ComponentFixture<MyComponent>;\n\n  beforeEach(async () => {\n    TestBed.configureTestingModule({\n      declarations: [MyComponent]\n    });\n    fixture = await TestBed.createComponent(MyComponent);\n    component = fixture.componentInstance;\n  });\n\n  it('should load data asynchronously', fakeAsync(() => {\n    // Simulate loading data asynchronously.\n    const clock = jasmine.clock();\n    clock.tick(1000);\n    component.dataLoaded = true;\n\n    // Assert that the data is loaded.\n    expect(component.dataLoaded).toBeTruthy();\n  }));\n});\n")),(0,o.kt)("p",null,"This test uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"jasmine.clock()")," function to create a virtual clock that can be used to control the execution of asynchronous code. The ",(0,o.kt)("inlineCode",{parentName:"p"},"tick()")," function is used to advance the virtual clock by a set amount of time. In this case, we are using ",(0,o.kt)("inlineCode",{parentName:"p"},"tick()")," to simulate the passage of 1000 milliseconds before asserting that the data is loaded."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"fakeAsync()")," function is used to wrap the test body in a special zone that allows us to control the execution of asynchronous code. This is necessary because ",(0,o.kt)("inlineCode",{parentName:"p"},"jasmine.clock()")," only works in a zone that allows for asynchronous control flow.")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Testing with mock"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Mocking a service:")," You can mock a service by using the ",(0,o.kt)("inlineCode",{parentName:"li"},"MockProvider")," function. This function creates a mock object that implements the interface of the real service. You can then use the mock object to control the behavior of the service in your tests.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"import { MockProvider } from '@angular/core/testing';\nimport { MyService } from './my.service';\n\ndescribe('MyComponent', () => {\n  let component: MyComponent;\n  let fixture: ComponentFixture<MyComponent>;\n\n  beforeEach(async () => {\n    TestBed.configureTestingModule({\n      declarations: [MyComponent]\n    });\n    const mockService = MockProvider(MyService);\n    fixture = await TestBed.createComponent(MyComponent, {\n      providers: [mockService]\n    });\n    component = fixture.componentInstance;\n  });\n\n  it('should call the service', () => {\n    // Expect the service to be called.\n    spyOn(mockService).getSomething();\n\n    // Trigger the service call.\n    component.something();\n\n    // Assert that the service was called.\n    expect(mockService.getSomething).toHaveBeenCalled();\n  });\n});\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Mocking a component:")," You can mock a component by using the ",(0,o.kt)("inlineCode",{parentName:"li"},"MockComponent")," function. This function creates a mock object that implements the interface of the real component. You can then use the mock object to control the behavior of the component in your tests.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"import { MockComponent } from '@angular/core/testing';\nimport { MyComponent } from './my.component';\n\ndescribe('MyComponent', () => {\n  let component: MyComponent;\n  let fixture: ComponentFixture<MyComponent>;\n\n  beforeEach(async () => {\n    TestBed.configureTestingModule({\n      declarations: [MyComponent]\n    });\n    const mockComponent = MockComponent(MyComponent);\n    fixture = await TestBed.createComponent(mockComponent);\n    component = fixture.componentInstance;\n  });\n\n  it('should call the component', () => {\n    // Expect the component to be called.\n    spyOn(mockComponent).doSomething();\n\n    // Trigger the component call.\n    component.doSomething();\n\n    // Assert that the component was called.\n    expect(mockComponent.doSomething).toHaveBeenCalled();\n  });\n});\n"))),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Testing with Stub"),(0,o.kt)("p",null,"Let's say you have a component that depends on a service that makes an HTTP request to get some data from an API. You want to test the component's logic without actually making the HTTP request, so you use a stub to mock the service and return some fake data. Here is how you can do it:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"First, you need to import the necessary modules and classes for your test. You also need to create a stub object that implements the same interface as your service, and define the methods and properties that you want to mock. For example:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import { TestBed, ComponentFixture } from '@angular/core/testing';\nimport { HttpClientTestingModule } from '@angular/common/http/testing';\nimport { MyComponent } from './my-component.component';\nimport { MyService } from './my-service.service';\n\n// Create a stub object that implements MyService interface\nconst myServiceStub = {\n  getData: jasmine.createSpy('getData').and.returnValue({ name: 'John', age: 25 }),\n  // Add any other methods or properties that you want to mock\n};\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Next, you need to configure the testing module and provide the stub object as a replacement for the real service. You also need to create a component instance and a fixture for your test. For example:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"describe('MyComponent', () => {\n  let component: MyComponent;\n  let fixture: ComponentFixture<MyComponent>;\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      declarations: [MyComponent],\n      providers: [\n        // Use the stub object instead of the real service\n        { provide: MyService, useValue: myServiceStub },\n      ],\n    }).compileComponents();\n  });\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(MyComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  // Add your test cases here\n});\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Finally, you can write your test cases and use the stub object to verify the component's behavior. For example, you can check if the component calls the service's getData method, or if it displays the data correctly in the template. For example:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"it('should call getData method of MyService', () => {\n  // Call the component's method that depends on the service\n  component.fetchData();\n  // Check if the service's getData method was called\n  expect(myServiceStub.getData).toHaveBeenCalled();\n});\n\nit('should display data in the template', () => {\n  // Call the component's method that depends on the service\n  component.fetchData();\n  // Trigger a change detection cycle\n  fixture.detectChanges();\n  // Get the element that displays the data\n  const dataElement = fixture.nativeElement.querySelector('.data');\n  // Check if the element contains the expected data\n  expect(dataElement.textContent).toContain('John');\n  expect(dataElement.textContent).toContain('25');\n});\n"))))}H.isMDXComponent=!0;const V={sidebar_position:3,id:"angular-zero-hero",sidebar_label:"Angular Zero To Hero",title:"Angular Zero To Hero"},q="Angular Zero To Hero",L={unversionedId:"js/angular-interviews/angular-zero-hero",id:"js/angular-interviews/angular-zero-hero",title:"Angular Zero To Hero",description:"Rendering In Angular",source:"@site/docs/js/angular-interviews/1.intro.md",sourceDirName:"js/angular-interviews",slug:"/js/angular-interviews/angular-zero-hero",permalink:"/devviews/interviews/js/angular-interviews/angular-zero-hero",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/js/angular-interviews/1.intro.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,id:"angular-zero-hero",sidebar_label:"Angular Zero To Hero",title:"Angular Zero To Hero"},sidebar:"jsInterviewSidebar",previous:{title:"Angular Interviews",permalink:"/devviews/interviews/angular-interview-questions-answers"},next:{title:"Rxjs From Zero To Hero",permalink:"/devviews/interviews/js/angular-interviews/rxjs-from-zero-to-hero"}},B={},W=[{value:"Rendering In Angular",id:"rendering-in-angular",level:3},{value:"LifecycleHooks",id:"lifecyclehooks",level:3},{value:"DI Angular",id:"di-angular",level:3},{value:"Standalone Component",id:"standalone-component",level:3},{value:"Typed Form",id:"typed-form",level:3},{value:"Signals",id:"signals",level:3},{value:"Dynamic Component",id:"dynamic-component",level:3},{value:"Custom Element",id:"custom-element",level:3},{value:"Built-In Directives",id:"built-in-directives",level:3},{value:"Animation",id:"animation",level:3},{value:"Testing",id:"testing",level:3}],Z={toc:W},X="wrapper";function U(e){let{components:n,...t}=e;return(0,o.kt)(X,(0,a.Z)({},Z,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"angular-zero-to-hero"},"Angular Zero To Hero"),(0,o.kt)("h3",{id:"rendering-in-angular"},"Rendering In Angular"),(0,o.kt)(j,{mdxType:"Rendering"}),(0,o.kt)("h3",{id:"lifecyclehooks"},"LifecycleHooks"),(0,o.kt)(R,{mdxType:"LifecycleHooks"}),(0,o.kt)("h3",{id:"di-angular"},"DI Angular"),(0,o.kt)(A,{mdxType:"DIAngular"}),(0,o.kt)("h3",{id:"standalone-component"},"Standalone Component"),(0,o.kt)(l,{mdxType:"Standalone"}),(0,o.kt)("h3",{id:"typed-form"},"Typed Form"),(0,o.kt)(m,{mdxType:"TypedForm"}),(0,o.kt)("h3",{id:"signals"},"Signals"),(0,o.kt)(u,{mdxType:"Signals"}),(0,o.kt)("h3",{id:"dynamic-component"},"Dynamic Component"),(0,o.kt)(k,{mdxType:"DynamicComponent"}),(0,o.kt)("h3",{id:"custom-element"},"Custom Element"),(0,o.kt)(y,{mdxType:"CustomElement"}),(0,o.kt)("h3",{id:"built-in-directives"},"Built-In Directives"),(0,o.kt)(w,{mdxType:"BuiltInDirectives"}),(0,o.kt)("h3",{id:"animation"},"Animation"),(0,o.kt)(M,{mdxType:"Animation"}),(0,o.kt)("h3",{id:"testing"},"Testing"),(0,o.kt)(H,{mdxType:"Testing"}))}U.isMDXComponent=!0},7802:function(e,n,t){n.Z=t.p+"assets/images/DI-Angular-8f2e3d9099de7d29fa08264b47ae3474.png"},83053:function(e,n,t){n.Z=t.p+"assets/images/custom-element-a37bcec4efc16c4cdc22228391c8fb66.png"},72102:function(e,n,t){n.Z=t.p+"assets/images/lifcycle-hooks-3c99937d3b99aacd3d6ef33905aae682.png"}}]);