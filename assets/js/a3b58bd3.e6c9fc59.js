"use strict";(self.webpackChunkinterviewdev=self.webpackChunkinterviewdev||[]).push([[1649],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=p(n),h=r,d=m["".concat(s,".").concat(h)]||m[h]||c[h]||o;return n?a.createElement(d,i(i({ref:t},u),{},{components:n})):a.createElement(d,i({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},1032:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return i},default:function(){return c},frontMatter:function(){return o},metadata:function(){return l},toc:function(){return p}});var a=n(3117),r=(n(7294),n(3905));const o={sidebar_position:1e3,sidebar_label:"Functional Interface",title:"Functional Interface",tags:["Java Knowledge"]},i=void 0,l={unversionedId:"java/hero/funtional-interface",id:"java/hero/funtional-interface",title:"Functional Interface",description:"Functional Interface",source:"@site/docs/java/hero/funtional-interface.md",sourceDirName:"java/hero",slug:"/java/hero/funtional-interface",permalink:"/devviews/interviews/java/hero/funtional-interface",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/java/hero/funtional-interface.md",tags:[{label:"Java Knowledge",permalink:"/devviews/interviews/tags/java-knowledge"}],version:"current",sidebarPosition:1e3,frontMatter:{sidebar_position:1e3,sidebar_label:"Functional Interface",title:"Functional Interface",tags:["Java Knowledge"]},sidebar:"javaInterviewSidebar",previous:{title:"Data Structure",permalink:"/devviews/interviews/java/hero/data-structure"},next:{title:"How Java Works",permalink:"/devviews/interviews/java/hero/how-java-works"}},s={},p=[],u={toc:p},m="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Functional Interface")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"A functional interface")," can have any number of default or static methods, but only one abstract method. A functional interface can also declare methods of the Object class, such as equals or toString. A functional interface is also known as a ",(0,r.kt)("strong",{parentName:"p"},"Single Abstract Method (SAM) interface"),"."),(0,r.kt)("p",null,"A functional interface can be annotated with ",(0,r.kt)("inlineCode",{parentName:"p"},"@FunctionalInterface")," annotation. However, this annotation is not mandatory, and the compiler will treat any interface with one abstract method as a functional interface."),(0,r.kt)("p",null,"A functional interface ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"can be used as the target type of a lambda expression"))," or a method reference, which are concise ways of creating ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"anonymous"))," implementations of the interface. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// A functional interface with one abstract method\n@FunctionalInterface\ninterface Greeting {\n    void sayHello(String name);\n}\n\n// A lambda expression that implements the interface\nGreeting greeting = name -> System.out.println("Hello, " + name);\n\n// A method reference that implements the interface\nGreeting greeting2 = System.out::println;\n\n// Calling the abstract method using the lambda expression\ngreeting.sayHello("John");\n\n// Calling the abstract method using the method reference\ngreeting2.sayHello("Jane");\n')),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"Hello, John\nJane\n")),(0,r.kt)("p",null,"Some examples of functional interfaces in Java are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Runnable"),": Represents an action that can be run ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"without any argument")),"s and ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"returns no result")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Predicate<T>"),": Represents a ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"boolean-valued function"))," of ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"one argument")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Function<T,R>"),": Represents a function that accepts ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"one argumen")),"t and produces ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"a result."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Consumer<T>"),": Represents an operation that accepts ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"one argument"))," and returns ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"no result")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Supplier<T>"),": Represents a ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"supplier of results"))," that takes ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"no arguments")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Comparator<T>"),": Represents a comparison function that ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"compares two objects of the same type")),"."))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Predicate")),(0,r.kt)("p",null,"A Predicate in Java is a functional interface that represents a boolean-valued function of one argument. It is defined in the ",(0,r.kt)("inlineCode",{parentName:"p"},"java.util.function")," package."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'Predicate<String> isEmpty = s -> s.isEmpty(); // lambda expression\nPredicate<String> isNull = Objects::isNull; // method reference\nSystem.out.println(isEmpty.test("")); // true\nSystem.out.println(isNull.test(null)); // true\n')),(0,r.kt)("p",null,"A Predicate also has some default methods that can be used to compose more complex predicates from existing ones. These methods are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"and")," (Predicate other): returns a predicate that represents the logical AND of this predicate and another."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"or")," (Predicate other): returns a predicate that represents the logical OR of this predicate and another."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"negate"),": returns a predicate that represents the logical negation of this predicate.")),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'Predicate<String> isNotNull = isNull.negate(); // not null\nPredicate<String> isNotEmpty = isEmpty.negate(); // not empty\nPredicate<String> isNotNullOrEmpty = isNotNull.and(isNotEmpty); // not null and not empty\nSystem.out.println(isNotNullOrEmpty.test("Hello")); // true\nSystem.out.println(isNotNullOrEmpty.test(null)); // false\nSystem.out.println(isNotNullOrEmpty.test("")); // false\n')),(0,r.kt)("p",null,"A Predicate also has a static method ",(0,r.kt)("inlineCode",{parentName:"p"},"isEqual(Object targetRef)")," that returns a predicate that tests if two arguments are equal according to ",(0,r.kt)("inlineCode",{parentName:"p"},"Objects.equals(Object, Object)"),". For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'Predicate<String> isEqualToHello = Predicate.isEqual("Hello"); // equal to "Hello"\nSystem.out.println(isEqualToHello.test("Hello")); // true\nSystem.out.println(isEqualToHello.test("World")); // false\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Runnable")),(0,r.kt)("p",null,"Runnable is a functional interface that has a single abstract method run () that takes no arguments and returns no result. Runnable is ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"used to create a task that can run in parallel with the main thread or other threads")),"."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Create a Runnable object using a lambda expression\nRunnable task = () -> {\n    // Task logic\n    System.out.println("Hello from " + Thread.currentThread().getName());\n};\n\n// Create a Thread object and pass the Runnable object\nThread thread = new Thread(task);\n\n// Start the thread\nthread.start();\n\n// Output: Hello from Thread-0\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Function")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Function<T,R> "),"functional interface in Java is an interface that represents a function that accepts one argument of type T and produces a result of type R."),(0,r.kt)("p",null,"The functions of Function<T,R> interface are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"apply(T t)"),": This is the abstract method that takes an argument of type T and returns a value of type R. It defines the logic of the function."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"andThen(Function<? super R,? extends V> after)"),": This is a default method that returns a composed function that first applies this function to its input, and then applies the after function to the result. It can be used to chain multiple functions together."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"compose(Function<? super V,? extends T> before)"),": This is a default method that returns a composed function that first applies the before function to its input, and then applies this function to the result. It can be used to create a function from other functions."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"identity()"),": This is a static method that returns a function that always returns its input argument. It can be used as a no-op function.")),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Import the Function interface\nimport java.util.function.Function;\n\n// Create some Function objects using lambda expressions\nFunction<String, Integer> lengthFunction = s -> s.length(); // returns the length of a string\nFunction<Integer, Integer> squareFunction = x -> x * x; // returns the square of an integer\nFunction<String, String> upperFunction = s -> s.toUpperCase(); // returns the upper case of a string\n\n// Apply the functions to some arguments\nSystem.out.println(lengthFunction.apply("Hello")); // 5\nSystem.out.println(squareFunction.apply(4)); // 16\nSystem.out.println(upperFunction.apply("world")); // WORLD\n\n// Compose the functions using andThen and compose methods\nFunction<String, Integer> lengthSquareFunction = lengthFunction.andThen(squareFunction); // returns the square of the length of a string\nFunction<Integer, String> squareUpperFunction = squareFunction.andThen(upperFunction); // returns the upper case of the square of an integer\nFunction<String, String> upperLengthFunction = lengthFunction.compose(upperFunction); // returns the length of the upper case of a string\n\n// Apply the composed functions to some arguments\nSystem.out.println(lengthSquareFunction.apply("Hello")); // 25\nSystem.out.println(squareUpperFunction.apply(4)); // 16\nSystem.out.println(upperLengthFunction.apply("world")); // 5\n\n// Use the identity function\nFunction<String, String> identityFunction = Function.identity(); // returns the same string\nSystem.out.println(identityFunction.apply("Hello")); // Hello\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Consumer")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Consumer<T>")," is a functional interface that represents an operation that ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"accepts/comsumes"))," a single input argument of type T and returns no result."),(0,r.kt)("p",null,"The functions of ",(0,r.kt)("inlineCode",{parentName:"p"},"Consumer<T>")," interface are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"accept(T t)"),": This is the abstract method that takes an argument of type T and performs some action on it. It defines the logic of the operation."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"andThen(Consumer<? super T> after)"),": This is a default method that returns a composed consumer that performs this operation followed by the after operation. It can be used to ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"chain multiple consumers together")),"."),(0,r.kt)("li",{parentName:"ul"},"For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Import the Consumer interface\nimport java.util.function.Consumer;\n\n// Create some Consumer objects using lambda expressions\nConsumer<String> printConsumer = s -> System.out.println(s); // prints a string\nConsumer<String> lengthConsumer = s -> System.out.println(s.length()); // prints the length of a string\nConsumer<String> upperConsumer = s -> System.out.println(s.toUpperCase()); // prints the upper case of a string\n\n// Apply the consumers to an argument\nprintConsumer.accept("Hello"); // Hello\nlengthConsumer.accept("Hello"); // 5\nupperConsumer.accept("Hello"); // HELLO\n\n// Compose the consumers using andThen method\nConsumer<String> printLengthConsumer = printConsumer.andThen(lengthConsumer); // prints a string and its length\nConsumer<String> printUpperConsumer = printConsumer.andThen(upperConsumer); // prints a string and its upper case\nConsumer<String> printLengthUpperConsumer = printConsumer.andThen(lengthConsumer).andThen(upperConsumer); // prints a string, its length and its upper case\n\n// Apply the composed consumers to an argument\nprintLengthConsumer.accept("Hello"); // Hello 5\nprintUpperConsumer.accept("Hello"); // Hello HELLO\nprintLengthUpperConsumer.accept("Hello"); // Hello 5 HELLO\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Supplier")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Supplier<T>")," is a functional interface that represents ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"a supplier of results"))," (it produces/supplies result). It is a functional interface that ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"has a single abstract method ",(0,r.kt)("inlineCode",{parentName:"em"},"get()")))," that takes no arguments and returns a value of type T."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Import the Supplier interface\nimport java.util.function.Supplier;\n\n// Create a Supplier object using a lambda expression\nSupplier<String> helloSupplier = () -> "Hello";\n\n// Get the result from the supplier\nString result = helloSupplier.get();\n\n// Print the result\nSystem.out.println(result);\n\n// Output: Hello\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Comparator")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Comparator<T>")," is a functional interface that represents ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"a comparison function that compares two objects of the same type")),"."),(0,r.kt)("p",null,"The functions of ",(0,r.kt)("inlineCode",{parentName:"p"},"Comparator<T>")," interface are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"compare(T o1, T o2)"),": This is the abstract method that takes two arguments of type T and returns an int value that indicates their order. It ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"defines the logic of the comparison function")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"reversed()"),": This is a default method that returns a comparator that imposes the reverse order of this comparator. It can be used to sort a collection in descending order."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"thenComparing(Comparator<? super T> other)"),": This is a default method that returns a lexicographic-order comparator that compares two objects by first applying this comparator and then applying the other comparator if the first comparison is equal. It can be used to sort a collection by multiple criteria."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"naturalOrder()"),": This is a static method that returns a comparator that compares two objects according to their natural order. It can be used to sort a collection of objects that implement Comparable interface."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"nullsFirst(Comparator<? super T> comparator)"),": This is a static method that returns a comparator that considers null values to be less than any non-null values and compares non-null values using the specified comparator. It can be used to sort a collection that may contain null values.")),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Import the Comparator interface\nimport java.util.Comparator;\n\n// Create some Comparator objects using lambda expressions\nComparator<String> lengthComparator = (s1, s2) -> s1.length() - s2.length(); // compares two strings by their lengths\nComparator<String> alphaComparator = (s1, s2) -> s1.compareTo(s2); // compares two strings by their alphabetical order\nComparator<String> reverseComparator = lengthComparator.reversed(); // reverses the order of lengthComparator\nComparator<String> lengthAlphaComparator = lengthComparator.thenComparing(alphaComparator); // compares two strings by their lengths and then by their alphabetical order\nComparator<String> naturalComparator = Comparator.naturalOrder(); // compares two strings by their natural order\nComparator<String> nullsFirstComparator = Comparator.nullsFirst(lengthComparator); // compares two strings by their lengths and considers null values to be less than any non-null values\n\n// Compare some strings using the comparators\nSystem.out.println(lengthComparator.compare("Hello", "World")); // 0\nSystem.out.println(alphaComparator.compare("Hello", "World")); // -15\nSystem.out.println(reverseComparator.compare("Hello", "World")); // 0\nSystem.out.println(lengthAlphaComparator.compare("Hello", "World")); // -15\nSystem.out.println(naturalComparator.compare("Hello", "World")); // -15\nSystem.out.println(nullsFirstComparator.compare("Hello", null)); // 1\n'))))}c.isMDXComponent=!0}}]);