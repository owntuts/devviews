"use strict";(self.webpackChunkinterviewdev=self.webpackChunkinterviewdev||[]).push([[5161],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=u(n),h=r,m=p["".concat(s,".").concat(h)]||p[h]||c[h]||o;return n?a.createElement(m,i(i({ref:t},d),{},{components:n})):a.createElement(m,i({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:r,i[1]=l;for(var u=2;u<o;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},77544:function(e,t,n){n.r(t),n.d(t,{assets:function(){return y},contentTitle:function(){return f},default:function(){return w},frontMatter:function(){return m},metadata:function(){return k},toc:function(){return g}});var a=n(83117),r=(n(67294),n(3905));const o={toc:[{value:"Options of <code>client.refetchQueries</code>",id:"options-of-clientrefetchqueries",level:4},{value:"Here&#39;s the corresponding between <code>client.refetchQueries</code> and <code>useQuery</code> options:",id:"heres-the-corresponding-between-clientrefetchqueries-and-usequery-options",level:4},{value:"Here&#39;s the corresponding between <code>client.mutate</code> options and <code>client.refetchQueries</code> options:",id:"heres-the-corresponding-between-clientmutate-options-and-clientrefetchqueries-options",level:4}]},i="wrapper";function l(e){let{components:t,...n}=e;return(0,r.kt)(i,(0,a.Z)({},o,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"refetchQueries")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"client.refetchQueries")," method is ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"a way to update your data on the client side by refetching queries"))," asking the server for new data. You can use this method when you want to make sure your data is fresh and up-to-date. Usually, we'll call ",(0,r.kt)("inlineCode",{parentName:"p"},"client.refetchQueries")," to re-run some queries after a mutation."),(0,r.kt)("h4",{id:"options-of-clientrefetchqueries"},"Options of ",(0,r.kt)("inlineCode",{parentName:"h4"},"client.refetchQueries")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'\ninterface RefetchQueriesOptions<\n  TCache extends ApolloCache<any>,\n  TResult = Promise<ApolloQueryResult<any>>,\n> {\n  updateCache?: (cache: TCache) => void;\n  include?: Array<string | DocumentNode> | "all" | "active";\n  onQueryUpdated?: (\n    observableQuery: ObservableQuery<any>,\n    diff: Cache.DiffResult<any>,\n    lastDiff: Cache.DiffResult<any> | undefined,\n  ) => boolean | TResult;\n  optimistic?: boolean;\n}\n\n')),(0,r.kt)("p",null,"The method takes an options object that has some fields that you can use to control how the refetching works. These fields are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"updateCache"),": This is ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"a function that you can use to change some data in the cache")),". The cache is where Apollo Client stores the data that it gets from the server. ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"When you change some data in the cache, Apollo Client will refetch any queries that use that data")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"include"),": This is an array that you can use to list ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"the queries that you want to refetch")),". A query is a request for some data from the server. You can use the name or the document of the query to identify it. You can also use ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},'"active" or "all" to refetch all the queries that are active or all the queries'))," that Apollo Client knows about."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"onQueryUpdated"),": This is ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"a function that you can use to decide what to do with each query"))," that needs to be refetched. You can use this function to check if the query has changed or not, and if you want to refetch it or not. You can also use this function to do something else with the query, ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"like showing a loading indicator or an error message")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"optimistic"),": This is a boolean that you can use to tell Apollo Client ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"if you want to use optimistic updates or not")),". Optimistic updates are when you show some changes in the UI before they are confirmed by the server. This can make your app feel faster and more responsive, but it can also cause some problems if the server rejects your changes."))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Example of refetchQueries")),(0,r.kt)("p",null,"In this example, the addTodo function first calls the mutate function with the text variable, then calls the client.refetchQueries method with all the options. The updateCache option modifies the cache by appending the new todo to the existing todos. The include option specifies the GET_ALL_TODOS query by name. The onQueryUpdated option decides whether to refetch the query based on its name and diff. The optimistic option uses optimistic updates to show changes immediately."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'import { gql, useMutation } from "@apollo/client";\nimport * as AddTodoTypes from "./__generated__/AddTodo";\nimport { GET_ALL_TODOS } from "../queries/getAllTodos";\n\nexport const ADD_TODO = gql`\n  mutation AddTodo($text: String!) {\n    addTodo (text: $text) {\n      id\n      text\n    }\n  }\n`;\n\nexport function useAddTodo() {\n  const [mutate, { data, error }] = useMutation<\n    AddTodoTypes.AddTodo,\n    AddTodoTypes.AddTodoVariables\n  >(ADD_TODO);\n\n  const client = useApolloClient();\n\n  async function addTodo(text: string) {\n    await mutate({\n      variables: { text },\n    });\n\n    await client.refetchQueries({\n      updateCache(cache) {\n        // Update the cache to trigger refetching of GET_ALL_TODOS query\n        cache.modify({\n          fields: {\n            todos(existingTodos = []) {\n              // Append the new todo to the existing todos\n              const newTodoRef = cache.writeFragment({\n                data: data.addTodo,\n                fragment: gql`\n                  fragment NewTodo on Todo {\n                    id\n                    text\n                  }\n                `\n              });\n              return [...existingTodos, newTodoRef];\n            }\n          }\n        });\n      },\n      include: ["GET_ALL_TODOS"], // Specify the query to refetch by name\n      onQueryUpdated(observableQuery, diff) {\n        // Decide whether to refetch each query based on its name and diff\n        if (observableQuery.queryName === "GET_ALL_TODOS") {\n          // Only refetch if there are new todos added\n          return diff.result.todos.length > diff.previousResult.todos.length;\n        }\n        // Return false for other queries to prevent refetching\n        return false;\n      },\n      optimistic: true // Use optimistic updates to show changes immediately\n    });\n  }\n\n  return { addTodo, data, error };\n}\n\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"client.refetchQueries vs useQuery")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Method"),(0,r.kt)("th",{parentName:"tr",align:null},"Purpose"),(0,r.kt)("th",{parentName:"tr",align:null},"Behavior"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"client.refetchQueries"),(0,r.kt)("td",{parentName:"tr",align:null},"To update client-side GraphQL data by refetching queries from the server more selectively"),(0,r.kt)("td",{parentName:"tr",align:null},"Does not execute automatically on render, but can be called at any time. Does not create a subscription to the query key.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"useQuery"),(0,r.kt)("td",{parentName:"tr",align:null},"To fetch data from the server and display it in a component"),(0,r.kt)("td",{parentName:"tr",align:null},"Executes automatically on render, and can be controlled by some options. Creates a subscription to the query key.")))),(0,r.kt)("h4",{id:"heres-the-corresponding-between-clientrefetchqueries-and-usequery-options"},"Here's the corresponding between ",(0,r.kt)("inlineCode",{parentName:"h4"},"client.refetchQueries")," and ",(0,r.kt)("inlineCode",{parentName:"h4"},"useQuery")," options:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"client.refetchQueries(options)"),(0,r.kt)("th",{parentName:"tr",align:null},"useQuery(options)"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"updateCache"),(0,r.kt)("td",{parentName:"tr",align:null},"update")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"include"),(0,r.kt)("td",{parentName:"tr",align:null},"query")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"onQueryUpdated"),(0,r.kt)("td",{parentName:"tr",align:null},"onCompleted")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"optimistic"),(0,r.kt)("td",{parentName:"tr",align:null},"optimisticResponse"))))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"client.refetchQueries vs client.mutate")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"client.mutate")," is the same as ",(0,r.kt)("inlineCode",{parentName:"p"},"mutate")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"[mutate, { data, error }] = useMutation"),". It's used to modify server-side GraphQL data by sending a mutation request to the server. It's used ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"when we need to execute a mutation outside of a React component")),", for example in a custom hook or a utility function"),(0,r.kt)("h4",{id:"heres-the-corresponding-between-clientmutate-options-and-clientrefetchqueries-options"},"Here's the corresponding between ",(0,r.kt)("inlineCode",{parentName:"h4"},"client.mutate")," options and ",(0,r.kt)("inlineCode",{parentName:"h4"},"client.refetchQueries")," options:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"client.mutate(options)"),(0,r.kt)("th",{parentName:"tr",align:null},"client.refetchQueries(options)"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"update"),(0,r.kt)("td",{parentName:"tr",align:null},"updateCache")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"refetchQueries"),(0,r.kt)("td",{parentName:"tr",align:null},"include")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"onQueryUpdated"),(0,r.kt)("td",{parentName:"tr",align:null},"onQueryUpdated")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"optimisticResponse"),(0,r.kt)("td",{parentName:"tr",align:null},"optimistic"))))))}l.isMDXComponent=!0;const s={toc:[]},u="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"useQueries")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"useQuery")," hook accepts an optional second argument that is an object of configuration options. Some of the available options are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"variables"),": An object containing all of the variables your query needs to execute"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"pollingInterval"),": Specifies the interval in milliseconds at which you want your component to poll for data. Defaults to 0 (no polling). This can be useful for scenarios where you want to display ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"near-real-time information"))," from your server, such as chat messages, notifications, or live updates."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"notifyOnNetworkStatusChange"),": Whether updates to the network status or network error should re-render your component. Defaults to ",(0,r.kt)("inlineCode",{parentName:"li"},"false"),". (The network status is an enum that indicates the current state of your query, such as ",(0,r.kt)("inlineCode",{parentName:"li"},"loading"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"ready"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"refetching"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"polling"),", etc.)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"fetchPolicy"),": How you want your component to ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"interact with the Apollo cache")),".",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"cache-first"),": This is the default policy. Apollo Client checks the cache to see if the result is present before making a network request. If the result is present, no network request occurs."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"cache-and-network"),": Apollo Client returns a result from the cache if available, and always makes a network request regardless. The query updates with the network result when it arrives."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"network-only"),": Apollo Client makes a network request and ignores any cached data. but ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"it does write the data to the cache after the query completes")),". This means that subsequent queries for the same data can use the cache if they have a different fetch policy (such as cache-first or cache-and-network). This fetch policy ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"cannot be used with subscriptions")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"cache-only"),": Apollo Client returns a result from the cache if available, and does not make any network requests. This fetch policy cannot be used with subscriptions."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"no-cache"),": Apollo Client makes a network request and ignores any cached data, but it ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"does not write any data to the cache after the query completes")),". This means that subsequent queries for the same data will always make a network request regardless of their fetch policy."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"standby"),": is a special policy that is used for queries that are not actively watched, but should be available for refetching. This policy is useful for scenarios where you want to ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"execute a query only under certain conditions")),", such as user input or network status."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"errorPolicy"),": The errorPolicy option determines how your component handles GraphQL errors that occur during the execution of your query.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The default errorPolicy is ",(0,r.kt)("inlineCode",{parentName:"li"},"none"),", which means that if any GraphQL errors occur, they are returned on the ",(0,r.kt)("inlineCode",{parentName:"li"},"error.graphQLErrors")," array of your ",(0,r.kt)("inlineCode",{parentName:"li"},"useQuery")," hook and the data field is set to ",(0,r.kt)("inlineCode",{parentName:"li"},"undefined")," (even if the server returns some data in its response)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"all")," to ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"populate both the data and ",(0,r.kt)("inlineCode",{parentName:"em"},"graphQLErrors")," fields"))," with the partial data and errors returned by the server."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ignore")," to ignore the ",(0,r.kt)("inlineCode",{parentName:"li"},"graphQLErrors")," field and ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"only return the data field")),"."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"context"),": Shared context between your component and your network interface (Apollo Link)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"skip"),": If skip is true, the query will be skipped entirely."))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import { gql, useQuery } from '@apollo/client';\n\nconst GET_BOOKS = gql`\n  query GetBooks($author: String) {\n    books(author: $author) {\n      id\n      title\n      genre\n    }\n  }\n`;\n\nfunction Books({ author }) {\n  const { loading, error, data, networkStatus, refetch } = useQuery(GET_BOOKS, {\n    variables: { author }, // pass the author name variable to the query\n    pollInterval: 5000, // poll the server every 5 seconds (i.e, refetch every 1 second)\n    notifyOnNetworkStatusChange: true, // re-render every time the query starts and stops polling\n    fetchPolicy: 'cache-and-network', // use both cache and network for the query\n    errorPolicy: 'all', // return both data and errors from the query\n    context: { headers: { 'X-Auth-Token': 'some-token' } }, // pass some custom headers to the query\n    skip: !author, // skip the query if author is falsy\n  });\n\n  if (loading) return 'Loading...';\n  if (error) return `Error! ${error.message}`;\n\n  return (\n    <div>\n      <h2>Books by {author}</h2>\n      <ul>\n        {data.books.map((book) => (\n          <li key={book.id}>\n            {book.title} ({book.genre})\n          </li>\n        ))}\n      </ul>\n      {networkStatus === 4 && <p>Refetching...</p>}\n      <button onClick={() => refetch()}>Refresh</button>\n    </div>\n  );\n}\n\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"standby fetchPolicy vs cache-only fetchPolicy")),(0,r.kt)("p",null,"When you use the ",(0,r.kt)("inlineCode",{parentName:"p"},"standby")," fetch policy, Apollo Client ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"returns a result from the cache if available, and does not make any network requests")),". However, unlike the ",(0,r.kt)("inlineCode",{parentName:"p"},"cache-only")," policy, the standby policy ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"allows you to refetch the query manually"))," or ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"with a different fetch policy when needed")),"."),(0,r.kt)("p",null,"For example, You can set the initial fetch policy to ",(0,r.kt)("inlineCode",{parentName:"p"},"standby")," and then use the ",(0,r.kt)("inlineCode",{parentName:"p"},"refetch")," function with a different fetch policy (such as ",(0,r.kt)("inlineCode",{parentName:"p"},"network-only"),") when the user clicks a button to apply the filters. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'function Chart({ filters }) {\n  const { loading, error, data, refetch } = useQuery(GET_DATA, {\n    variables: filters,\n    fetchPolicy: "standby" // do not execute the query until refetched\n  });\n\n  function handleApplyFilters() {\n    refetch({ fetchPolicy: "network-only" }); // execute the query with the current filters\n  }\n\n  return (\n    <div>\n      <button onClick={handleApplyFilters}>Apply filters</button>\n      {loading && <p>Loading...</p>}\n      {error && <p>Error :(</p>}\n      {data && <Chart data={data} />}\n    </div>\n  );\n}\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"useQuery vs useLazyQuery")),(0,r.kt)("p",null,"The main difference between ",(0,r.kt)("inlineCode",{parentName:"p"},"useQuery")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"useLazyQuery")," is whether the hook executes the query immediately or not."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"useQuery"),(0,r.kt)("th",{parentName:"tr",align:null},"useLazyQuery"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Executes the query immediately when the component renders"),(0,r.kt)("td",{parentName:"tr",align:null},"Does not execute the query until the returned function is called")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Returns an object with loading, error, data, and other properties"),(0,r.kt)("td",{parentName:"tr",align:null},"Returns a tuple with a function and an object with loading, error, data, and other properties")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Can refetch the query manually or with a different fetch policy"),(0,r.kt)("td",{parentName:"tr",align:null},"Can execute the query with variables and options")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Useful for fetching data that is needed for rendering the component"),(0,r.kt)("td",{parentName:"tr",align:null},"Useful for fetching data that depends on user input or other conditions")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// useQuery example\nfunction Dogs({ onDogSelected }) {\n  const { loading, error, data } = useQuery(GET_DOGS); // execute the query when the component renders\n\n  if (loading) return "Loading...";\n  if (error) return `Error! ${error.message}`;\n\n  return (\n    <select name="dog" onChange={onDogSelected}>\n      {data.dogs.map((dog) => (\n        <option key={dog.id} value={dog.breed}>\n          {dog.breed}\n        </option>\n      ))}\n    </select>\n  );\n}\n\n// useLazyQuery example\nfunction Chart({ filters }) {\n  const [getChart, { loading, error, data }] = useLazyQuery(GET_CHART); // do not execute the query until getChart is called\n\n  function handleApplyFilters() {\n    getChart({ variables: filters }); // execute the query with the current filters\n  }\n\n  return (\n    <div>\n      <button onClick={handleApplyFilters}>Apply filters</button>\n      {loading && <p>Loading...</p>}\n      {error && <p>Error :(</p>}\n      {data && <Chart data={data} />}\n    </div>\n  );\n}\n'))))}d.isMDXComponent=!0;const p={toc:[]},c="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"useMutation")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"useMutation")," hook is the primary API for executing mutations in an Apollo application. It returns a tuple that includes a ",(0,r.kt)("inlineCode",{parentName:"p"},"mutate")," function and an object with fields that represent the current status of the mutation's execution. You can pass options to ",(0,r.kt)("inlineCode",{parentName:"p"},"useMutation")," as the second parameter or to the mutate function itself. Some of the options are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"variables"),": An object containing all of the variables your mutation needs to execute"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"context"),": Shared context between your Apollo Client instance and your GraphQL server (for example, headers)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"fetchPolicy"),": How you want your client to interact with the Apollo cache for this mutation"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"refetchQueries"),": An array of query names or query documents that will be refetched after your mutation completes"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"awaitRefetchQueries"),":  is a boolean that specifies whether you want your mutation to await the completion of any ",(0,r.kt)("inlineCode",{parentName:"li"},"refetchQueries")," before it can be marked as ",(0,r.kt)("inlineCode",{parentName:"li"},"resolved"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"update"),": A function that lets you update the cache based on the result of your mutation"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"onCompleted"),": A function that will be called when your mutation successfully completes"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"onError"),": A function that will be called if your mutation encounters an error"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"onQueryUpdated"),": is a way to tell Apollo Client ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"what to do with other queries after you make a change"))," with a mutation."))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import { gql, useMutation } from '@apollo/client';\n\nconst ADD_TODO = gql`\n  mutation AddTodo($type: String!) {\n    addTodo(type: $type) {\n      id\n      type\n    }\n  }\n`;\n\nfunction AddTodo() {\n  let input;\n  const [addTodo, { data, loading, error }] = useMutation(ADD_TODO, {\n    // variables: { type: input.value }, // you can pass variables here or to the mutate function\n    context: { headers: { authorization: 'Bearer token' } }, // shared context between client and server\n    fetchPolicy: 'no-cache', // how to interact with the cache\n    refetchQueries: ['GetTodos'], // queries to refetch after mutation\n    awaitRefetchQueries: true, // whether to wait for refetchQueries\n    update: (cache, { data: { addTodo } }) => {\n      // function to update the cache based on mutation result\n      const data = cache.readQuery({ query: GET_TODOS });\n      cache.writeQuery({\n        query: GET_TODOS,\n        data: { todos: [addTodo].concat(data.todos) },\n      });\n    },\n    onCompleted: (data) => {\n      // function to run when mutation completes successfully\n      console.log('Mutation completed:', data);\n    },\n    onError: (error) => {\n      // function to run if mutation encounters an error\n      console.error('Mutation error:', error);\n    },\n  });\n\n  if (loading) return 'Submitting...';\n  if (error) return `Submission error! ${error.message}`;\n\n  return (\n    <div>\n      <form\n        onSubmit={(e) => {\n          e.preventDefault();\n          addTodo({ variables: { type: input.value } }); // you can pass variables here or to the useMutation hook\n          input.value = '';\n        }}\n      >\n        <input\n          ref={(node) => {\n            input = node;\n          }}\n        />\n        <button type=\"submit\">Add Todo</button>\n      </form>\n    </div>\n  );\n}\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"onQueryUpdated")),(0,r.kt)("p",null,"The onQueryUpdated option gives you more control over ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"how your app reacts to changes made by mutations")),"."),(0,r.kt)("p",null,"For example, if you add a new item to a list with a mutation, you might want to update other queries that show the same list. The ",(0,r.kt)("inlineCode",{parentName:"p"},"onQueryUpdated")," option ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"lets you check each query and decide if you want to refetch it or not")),". You can also do other things before refetching, like showing a message or loading indicator. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import { gql, useMutation } from '@apollo/client';\n\nconst ADD_TODO = gql`\n  mutation AddTodo($type: String!) {\n    addTodo(type: $type) {\n      id\n      type\n    }\n  }\n`;\n\nfunction AddTodo() {\n  let input;\n  const [addTodo, { data, loading, error }] = useMutation(ADD_TODO);\n\n  if (loading) return 'Submitting...';\n  if (error) return `Submission error! ${error.message}`;\n\n  return (\n    <div>\n      <form\n        onSubmit={(e) => {\n          e.preventDefault();\n          addTodo({\n            variables: { type: input.value },\n            // Update the cache directly with the new todo\n            update(cache, { data: { addTodo } }) {\n              cache.modify({\n                fields: {\n                  todos(existingTodos = []) {\n                    const newTodoRef = cache.writeFragment({\n                      data: addTodo,\n                      fragment: gql`\n                        fragment NewTodo on Todo {\n                          id\n                          type\n                        }\n                      `\n                    });\n                    return [...existingTodos, newTodoRef];\n                  }\n                }\n              });\n            },\n            // Use onQueryUpdated to refetch any queries that depend on the todos field\n            onQueryUpdated(observableQuery, diff) {\n              // If the query includes a todos field, refetch it\n              if (diff.wasInvalidated && diff.result.todos) {\n                return observableQuery.refetch();\n              }\n              // Otherwise, do nothing\n              return false;\n            }\n          });\n          input.value = '';\n        }}\n      >\n        <input\n          ref={(node) => {\n            input = node;\n          }}\n        />\n        <button type=\"submit\">Add Todo</button>\n      </form>\n    </div>\n  );\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"observableQuery")," is the current query that is being checked by the onQueryUpdated callback."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"diff")," tells the ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"difference between the cache and the query result")),". The ",(0,r.kt)("strong",{parentName:"li"},"query result")," is what Apollo Client reads from the cache to show in the UI. The ",(0,r.kt)("strong",{parentName:"li"},"cache")," is where Apollo Client stores the data it gets from the server. Sometimes, the cache changes because of a mutation or an update function, and the query result becomes outdated. The ",(0,r.kt)("inlineCode",{parentName:"li"},"diff")," helps you detect when that happens and refetch the query to get the latest data from the server.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"diff.wasInvalidated")," is a way to tell if something has changed in the cache that affects the related query result."))))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Option precedence")),(0,r.kt)("p",null,"If you provide the same option to both ",(0,r.kt)("inlineCode",{parentName:"p"},"useMutation")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"mutate"),", the option passed to ",(0,r.kt)("inlineCode",{parentName:"p"},"mutate")," will take precedence over the one passed to ",(0,r.kt)("inlineCode",{parentName:"p"},"useMutation"),". This allows you to override some options for a specific mutation execution."),(0,r.kt)("p",null,"Here is an example of using option precedence with ",(0,r.kt)("inlineCode",{parentName:"p"},"useMutation"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import { gql, useMutation } from '@apollo/client';\n\nconst ADD_TODO = gql`\n  mutation AddTodo($type: String!) {\n    addTodo(type: $type) {\n      id\n      type\n    }\n  }\n`;\n\nfunction AddTodo() {\n  let input;\n  const [addTodo, { data, loading, error }] = useMutation(ADD_TODO, {\n    // Provide some options to useMutation\n    variables: { type: 'default' },\n    context: { headers: { authorization: 'Bearer token' } },\n    refetchQueries: ['GetTodos'],\n    awaitRefetchQueries: true,\n    onCompleted: (data) => {\n      console.log('Mutation completed:', data);\n    },\n    onError: (error) => {\n      console.error('Mutation error:', error);\n    },\n  });\n\n  if (loading) return 'Submitting...';\n  if (error) return `Submission error! ${error.message}`;\n\n  return (\n    <div>\n      <form\n        onSubmit={(e) => {\n          e.preventDefault();\n          addTodo({\n            // Override some options for this mutation execution\n            variables: { type: input.value },\n            refetchQueries: ['GetTodos', 'GetDoneTodos'],\n            onCompleted: (data) => {\n              console.log('New todo added:', data);\n            },\n          });\n          input.value = '';\n        }}\n      >\n        <input\n          ref={(node) => {\n            input = node;\n          }}\n        />\n        <button type=\"submit\">Add Todo</button>\n      </form>\n    </div>\n  );\n}\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"reset the mutation state")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"reset")," function in ",(0,r.kt)("inlineCode",{parentName:"p"},"useMutation")," is a way to reset the mutation state to its initial values. This can be useful if you ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"want to reuse the same mutation hook for multiple executions and don't want to keep the previous state")),"."),(0,r.kt)("p",null,"In the example below, after clicking the Clear button, the data property of the mutation result object will be set to undefined, and the UI that depends on it will disappear"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import { useMutation } from 'react-query';\n\nfunction AddTodo() {\n  let input;\n  const [addTodo, { data, loading, error, reset }] = useMutation(addTodoToServer);\n\n  if (loading) return 'Submitting...';\n  if (error) return `Submission error! ${error.message}`;\n\n  return (\n    <div>\n      <form\n        onSubmit={(e) => {\n          e.preventDefault();\n          addTodo(input.value);\n          input.value = '';\n        }}\n      >\n        <input\n          ref={(node) => {\n            input = node;\n          }}\n        />\n        <button type=\"submit\">Add Todo</button>\n      </form>\n      {data && (\n        <div>\n          <p>New todo added: {data}</p>\n          <button onClick={() => reset()}>Clear</button>\n        </div>\n      )}\n    </div>\n  );\n}\n"))))}h.isMDXComponent=!0;const m={sidebar_position:3,id:"apollojs-client-zero-hero",sidebar_label:"Apollo GraphQL Client From Zero To Hero",title:"Apollo GraphQL Client From Zero To Hero"},f=void 0,k={unversionedId:"apollographql/apollojs-client-zero-hero",id:"apollographql/apollojs-client-zero-hero",title:"Apollo GraphQL Client From Zero To Hero",description:"useQuery",source:"@site/docs/apollographql/intro.md",sourceDirName:"apollographql",slug:"/apollographql/apollojs-client-zero-hero",permalink:"/devviews/interviews/apollographql/apollojs-client-zero-hero",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/apollographql/intro.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,id:"apollojs-client-zero-hero",sidebar_label:"Apollo GraphQL Client From Zero To Hero",title:"Apollo GraphQL Client From Zero To Hero"},sidebar:"apolloInterviewSidebar",previous:{title:"Apollo Graphql Interviews",permalink:"/devviews/interviews/apollographql/apollographql-interview-questions-answers-junior"}},y={},g=[{value:"useQuery",id:"usequery",level:3},{value:"useMutation",id:"usemutation",level:3},{value:"Refetch Client",id:"refetch-client",level:3}],N={toc:g},b="wrapper";function w(e){let{components:t,...n}=e;return(0,r.kt)(b,(0,a.Z)({},N,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h3",{id:"usequery"},"useQuery"),(0,r.kt)(d,{mdxType:"UseQuery"}),(0,r.kt)("h3",{id:"usemutation"},"useMutation"),(0,r.kt)(h,{mdxType:"UseMutation"}),(0,r.kt)("h3",{id:"refetch-client"},"Refetch Client"),(0,r.kt)(l,{mdxType:"Refetch"}))}w.isMDXComponent=!0}}]);