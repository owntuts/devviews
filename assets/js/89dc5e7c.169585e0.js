"use strict";(self.webpackChunkinterviewdev=self.webpackChunkinterviewdev||[]).push([[2357],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return N}});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var i=n.createContext({}),u=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=u(e.components);return n.createElement(i.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,i=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=u(a),c=r,N=m["".concat(i,".").concat(c)]||m[c]||d[c]||l;return a?n.createElement(N,o(o({ref:t},p),{},{components:a})):n.createElement(N,o({ref:t},p))}));function N(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,o=new Array(l);o[0]=c;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[m]="string"==typeof e?e:r,o[1]=s;for(var u=2;u<l;u++)o[u]=a[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},54312:function(e,t,a){a.d(t,{ZP:function(){return s}});var n=a(83117),r=(a(67294),a(3905));const l={toc:[]},o="wrapper";function s(e){let{components:t,...a}=e;return(0,r.kt)(o,(0,n.Z)({},l,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("div",{className:"interview"},a.level&&(0,r.kt)("span",{className:"level"},a.level),a.children))}s.isMDXComponent=!0},748:function(e,t,a){a.r(t),a.d(t,{assets:function(){return P},contentTitle:function(){return C},default:function(){return U},frontMatter:function(){return I},metadata:function(){return S},toc:function(){return D}});var n=a(83117),r=(a(67294),a(3905));a(54312);const l={toc:[]},o="wrapper";function s(e){let{components:t,...a}=e;return(0,r.kt)(o,(0,n.Z)({},l,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Types of Replications in postgresql")),(0,r.kt)("p",null,"PostgreSQL supports two main types of replication:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Pros"),(0,r.kt)("th",{parentName:"tr",align:null},"Cons"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Synchronous replication"),(0,r.kt)("td",{parentName:"tr",align:null},"Data is written to both the primary and secondary servers at the same time."),(0,r.kt)("td",{parentName:"tr",align:null},"Highest level of data consistency."),(0,r.kt)("td",{parentName:"tr",align:null},"Performance overhead.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Asynchronous replication"),(0,r.kt)("td",{parentName:"tr",align:null},"Data is written to the primary server first, and then the secondary server applies the changes."),(0,r.kt)("td",{parentName:"tr",align:null},"Less performance overhead than synchronous replication."),(0,r.kt)("td",{parentName:"tr",align:null},"Window of time where data may be out of sync.")))),(0,r.kt)("p",null,"PostgreSQL also supports two other types of replication:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Pros"),(0,r.kt)("th",{parentName:"tr",align:null},"Cons"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Streaming (physical) replication"),(0,r.kt)("td",{parentName:"tr",align:null},"WAL records are sent from the primary server to the standby server as they are generated. Entire database (tables, indexes, and data) cluster is replicated."),(0,r.kt)("td",{parentName:"tr",align:null},"Efficient."),(0,r.kt)("td",{parentName:"tr",align:null},"Scalable.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Logical replication"),(0,r.kt)("td",{parentName:"tr",align:null},"Data is replicated on a per-table basis."),(0,r.kt)("td",{parentName:"tr",align:null},"Flexibility to replicate only a subset of data."),(0,r.kt)("td",{parentName:"tr",align:null},"More complex to set up than streaming replication.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"File-based replication"),(0,r.kt)("td",{parentName:"tr",align:null},"WAL files are copied from the primary server to the secondary server."),(0,r.kt)("td",{parentName:"tr",align:null},"Simple to set up."),(0,r.kt)("td",{parentName:"tr",align:null},"Less scalable than streaming replication."))))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Streaming Replication")),(0,r.kt)("p",null,"In streaming replication, the ",(0,r.kt)("strong",{parentName:"p"},"primary server")," sends ",(0,r.kt)("inlineCode",{parentName:"p"},"WAL")," (Write-Ahead Log) records to the ",(0,r.kt)("strong",{parentName:"p"},"standby server (Slave Server)")," as they are generated. The standby server then applies these changes to its own database cluster. This ensures that the standby server is always up-to-date with the primary server."),(0,r.kt)("p",null,"Here are the steps to configure streaming replication in PostgreSQL 13, as outlined in the article you linked:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Prepare the environment.")," Make sure that both the primary and standby servers are running PostgreSQL 13 or later. You will also need to create a user account on both servers that has the ",(0,r.kt)("inlineCode",{parentName:"li"},"replication")," privilege."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Configure the primary server.")," On the primary server, set the ",(0,r.kt)("inlineCode",{parentName:"li"},"wal_level")," parameter to ",(0,r.kt)("inlineCode",{parentName:"li"},"replica"),". This will tell PostgreSQL to generate WAL (Write-Ahead Log) records for all changes to the database."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Enable archive mode.")," In order to stream WAL files to the standby server, you need to enable archive mode on the primary server. You can do this by running the following command:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"pg_ctl archive on\n")),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Configure the standby server.")," On the standby server, create a directory to store the WAL files. You can then configure the standby server to connect to the primary server and start streaming WAL files. You can do this by running the following commands:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"pg_createcluster postgres standby\npg_ctl start -D /path/to/standby/data\n")),(0,r.kt)("ol",{start:5},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Check the status of replication.")," Once you have configured streaming replication, you can check the status of replication by running the following command on the standby server:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"pg_stat_replication\n")),(0,r.kt)("p",null,"This command will show you the status of replication, including the number of WAL files that have been received and the number of WAL files that are still pending.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Logical Replication")),(0,r.kt)("p",null,"Logical replication is a method of replicating (synchronization) data at the logical level. Here are two terms that you need to understand:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Data synchronization"),' can be understood as a mechanism that helps a table (or more broadly, an object) "mimic" changes from another table. For example, when data is inserted into table A, the correct data is also inserted into table B.'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},'The term "logical"'),' here is in contrast to the term "physical". In simple terms, logic is the top-level objects that users can interact with, such as tables and views. Physics refers to the actual objects on the disk that users cannot see (such as databases, tablespaces, and datafiles). A physical synchronization solution can be streaming replication.')),(0,r.kt)("p",null,"Here are the steps to configure logical replication in PostgreSQL, as outlined in the article you linked:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Prepare the environment.")," Make sure that both the primary and standby servers are running PostgreSQL 11 or later. You will also need to create a user account on both servers that has the ",(0,r.kt)("inlineCode",{parentName:"li"},"replication")," privilege."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Configure the primary server.")," On the primary server, create a ",(0,r.kt)("strong",{parentName:"li"},"replication slot"),". A replication slot is a logical channel that is used to ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"send replication data to a standby server")),". You can create a replication slot by running the following command:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"CREATE REPLICATION SLOT myslot;\n")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Enable logical replication on the tables you want to replicate.")," You can enable logical replication on a table by running the following command:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ALTER TABLE mytable REPLICATE;\n")),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Configure the standby server.")," On the standby server, create a publication. A ",(0,r.kt)("strong",{parentName:"li"},"publication")," is a logical ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"grouping of tables that are being replicated")),". You can create a publication by running the following command:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"CREATE PUBLICATION mypublication FOR TABLE mytable;\n")),(0,r.kt)("ol",{start:5},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Start replication.")," Once you have configured logical replication, you can start replication by running the following command on the standby server:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"pg_start_replication myslot;\n")),(0,r.kt)("p",null,"This command will start the replication process and begin sending replication data from the primary server to the standby server.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"File-based Replication")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"File-based replication")," is a method of replicating data by copying WAL (Write-Ahead Log) files from the primary server to the standby server. WAL files contain a record of all changes that have been made to the database, so by copying these files, the standby server can be kept up-to-date with the primary server."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Steps to configure file-based replication in PostgreSQL:")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Prepare the environment.")," Make sure that both the primary and standby servers are running PostgreSQL 10 or later. You will also need to create a user account on both servers that has the ",(0,r.kt)("inlineCode",{parentName:"li"},"replication")," privilege."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Configure the primary server.")," On the primary server, set the ",(0,r.kt)("inlineCode",{parentName:"li"},"wal_level")," parameter to ",(0,r.kt)("inlineCode",{parentName:"li"},"replica"),". This will tell PostgreSQL to generate WAL (Write-Ahead Log) records for all changes to the database."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Enable archive mode.")," In order to copy WAL files to the standby server, you need to enable archive mode on the primary server. You can do this by running the following command:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"pg_ctl archive on\n")),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Configure the standby server.")," On the standby server, create a directory to store the WAL files. You can then configure the standby server to connect to the primary server and start copying WAL files. You can do this by running the following commands:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"pg_createcluster postgres standby\npg_ctl start -D /path/to/standby/data\n")),(0,r.kt)("ol",{start:5},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Check the status of replication.")," Once you have configured file-based replication, you can check the status of replication by running the following command on the standby server:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"pg_stat_replication\n")),(0,r.kt)("p",null,"This command will show you the status of replication, including the number of WAL files that have been received and the number of WAL files that are still pending."),(0,r.kt)("p",null,"Here are some of the pros and cons of file-based replication:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"File-based replication")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Pros:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Simple to set up and manage."),(0,r.kt)("li",{parentName:"ul"},"Can be used to replicate any type of data."))),(0,r.kt)("li",{parentName:"ul"},"Cons:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Can be inefficient and not scalable."),(0,r.kt)("li",{parentName:"ul"},"Can be difficult to troubleshoot.")))),(0,r.kt)("p",null,"The best type of replication for you will depend on your specific needs. If you need a simple and easy-to-manage solution, then file-based replication may be a good option. If you need a more efficient and scalable solution, then streaming replication may be a better choice.")))}s.isMDXComponent=!0;const i={toc:[]},u="wrapper";function p(e){let{components:t,...a}=e;return(0,r.kt)(u,(0,n.Z)({},i,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Types of Sharding in postgresql")),(0,r.kt)("p",null,"There are two main types of sharding in PostgreSQL:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Horizontal sharding")," divides the data into multiple partitions, each of which is stored on a separate server. This is the most common type of sharding, and it is well-suited for applications that need to scale out horizontally."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Vertical sharding")," divides the data into multiple tables, each of which is stored on a separate server. This type of sharding is less common, but it can be useful for applications that need to scale up vertically.")),(0,r.kt)("p",null,"In addition to these two main types, there are also a few other types of sharding that can be used with PostgreSQL:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Function-based sharding")," divides the data based on the values of a particular function. This type of sharding can be useful for applications that need to distribute data based on some specific criteria."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Data-based sharding")," divides the data based on the values of a particular column. This type of sharding can be useful for applications that need to distribute data based on the distribution of the data values.")),(0,r.kt)("p",null,"The best type of sharding for you will depend on your specific needs. If you need to scale out horizontally, then horizontal sharding is a good option. If you need to scale up vertically, then vertical sharding is a good option. And if you need to distribute data based on some specific criteria, then function-based or data-based sharding may be a good option."),(0,r.kt)("p",null,"Here is a table summarizing the different types of sharding in PostgreSQL:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Pros"),(0,r.kt)("th",{parentName:"tr",align:null},"Cons"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Horizontal sharding"),(0,r.kt)("td",{parentName:"tr",align:null},"Divides the data into multiple partitions, each of which is stored on a separate server."),(0,r.kt)("td",{parentName:"tr",align:null},"Scalable."),(0,r.kt)("td",{parentName:"tr",align:null},"Complex to implement and manage.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Vertical sharding"),(0,r.kt)("td",{parentName:"tr",align:null},"Divides the data into multiple tables, each of which is stored on a separate server."),(0,r.kt)("td",{parentName:"tr",align:null},"Efficient."),(0,r.kt)("td",{parentName:"tr",align:null},"Less scalable than horizontal sharding.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Function-based sharding"),(0,r.kt)("td",{parentName:"tr",align:null},"Divides the data based on the values of a particular function."),(0,r.kt)("td",{parentName:"tr",align:null},"Flexible."),(0,r.kt)("td",{parentName:"tr",align:null},"Complex to implement and manage.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Data-based sharding"),(0,r.kt)("td",{parentName:"tr",align:null},"Divides the data based on the values of a particular column."),(0,r.kt)("td",{parentName:"tr",align:null},"Efficient."),(0,r.kt)("td",{parentName:"tr",align:null},"Less flexible than function-based sharding."))))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Example of Vertical Sharding in postgresql")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Suppose you have a table called ",(0,r.kt)("inlineCode",{parentName:"li"},"customers")," with the following schema and data:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE customers (\n  id SERIAL PRIMARY KEY,\n  name VARCHAR(50) NOT NULL,\n  email VARCHAR(50) NOT NULL,\n  phone VARCHAR(20) NOT NULL,\n  address VARCHAR(100) NOT NULL\n);\n\nINSERT INTO customers (name, email, phone, address) VALUES\n('Alice', 'alice@example.com', '123-456-7890', '123 Main Street'),\n('Bob', 'bob@example.com', '234-567-8901', '456 Second Avenue'),\n('Charlie', 'charlie@example.com', '345-678-9012', '789 Third Boulevard'),\n('David', 'david@example.com', '456-789-0123', '012 Fourth Circle');\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"You can vertically shard this table into two smaller tables, one with the ",(0,r.kt)("inlineCode",{parentName:"li"},"id"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"name"),", and ",(0,r.kt)("inlineCode",{parentName:"li"},"email")," columns, and another with the ",(0,r.kt)("inlineCode",{parentName:"li"},"id"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"phone"),", and ",(0,r.kt)("inlineCode",{parentName:"li"},"address")," columns. You can use foreign data wrappers (FDWs) to create foreign tables on different servers that point to the shards. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- On server 1\n-- Load the postgres_fdw extension\nCREATE EXTENSION postgres_fdw;\n\n-- Create a foreign server object named shard1 that represents an external PostgreSQL server\n-- Specify the host name and database name of the external server as options\nCREATE SERVER shard1 FOREIGN DATA WRAPPER postgres_fdw OPTIONS (host 'server1', dbname 'shard1_db');\n\n-- Create a user mapping for the current user that specifies the remote user name and password to use when connecting to shard1\nCREATE USER MAPPING FOR current_user SERVER shard1 OPTIONS (user 'shard1_user', password 'shard1_pass');\n\n\nCREATE TABLE customers_1 (\n  id SERIAL PRIMARY KEY,\n  name VARCHAR(50) NOT NULL,\n  email VARCHAR(50) NOT NULL\n);\n\nINSERT INTO customers_1 (id, name, email) SELECT id, name, email FROM customers;\n\n-- On server 2\nCREATE EXTENSION postgres_fdw;\nCREATE SERVER shard2 FOREIGN DATA WRAPPER postgres_fdw OPTIONS (host 'server2', dbname 'shard2_db');\nCREATE USER MAPPING FOR current_user SERVER shard2 OPTIONS (user 'shard2_user', password 'shard2_pass');\n\nCREATE TABLE customers_2 (\n  id INT PRIMARY KEY,\n  phone VARCHAR(20) NOT NULL,\n  address VARCHAR(100) NOT NULL\n);\n\nINSERT INTO customers_2 (id, phone, address) SELECT id, phone, address FROM customers;\n\n-- On the original server\nDROP TABLE customers;\nCREATE FOREIGN TABLE customers_1 (\n  id INT PRIMARY KEY,\n  name VARCHAR(50) NOT NULL,\n  email VARCHAR(50) NOT NULL\n) SERVER shard1;\n\nCREATE FOREIGN TABLE customers_2 (\n  id INT PRIMARY KEY,\n  phone VARCHAR(20) NOT NULL,\n  address VARCHAR(100) NOT NULL\n) SERVER shard2;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Now you have vertically sharded your ",(0,r.kt)("inlineCode",{parentName:"li"},"customers")," table into two foreign tables on different servers. You can query them separately or join them using the ",(0,r.kt)("inlineCode",{parentName:"li"},"id")," column."))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Example of Horizontal Sharding in postgresql")),(0,r.kt)("p",null,"Hello, this is Bing. I'm happy to help you with your query. \ud83d\ude0a"),(0,r.kt)("p",null,"According to the search results, an example of horizontal sharding in PostgreSQL could be:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Suppose you have a table called ",(0,r.kt)("inlineCode",{parentName:"li"},"orders")," with the following schema and data:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE orders (\n  id SERIAL PRIMARY KEY,\n  customer_id INT NOT NULL,\n  product_id INT NOT NULL,\n  quantity INT NOT NULL,\n  order_date DATE NOT NULL\n);\n\nINSERT INTO orders (customer_id, product_id, quantity, order_date) VALUES\n(1, 10, 2, '2021-01-01'),\n(2, 20, 1, '2021-01-02'),\n(3, 30, 3, '2021-01-03'),\n(4, 40, 4, '2021-01-04'),\n(5, 50, 5, '2021-01-05');\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"You can horizontally shard this table into smaller tables based on the order_date column. For example, ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"you can create one table for each month"))," of the year and use range partitioning to distribute the rows. You can use foreign data wrappers (FDWs) to create foreign tables on different servers that point to the shards. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- On the original server\nCREATE EXTENSION postgres_fdw;\n\n-- Create foreign server objects for each shard server\nCREATE SERVER shard1 FOREIGN DATA WRAPPER postgres_fdw OPTIONS (host 'server1', dbname 'shard1_db');\nCREATE SERVER shard2 FOREIGN DATA WRAPPER postgres_fdw OPTIONS (host 'server2', dbname 'shard2_db');\n-- and so on for other servers\n\n-- Create user mappings for each shard server\nCREATE USER MAPPING FOR current_user SERVER shard1 OPTIONS (user 'shard1_user', password 'shard1_pass');\nCREATE USER MAPPING FOR current_user SERVER shard2 OPTIONS (user 'shard2_user', password 'shard2_pass');\n-- and so on for other servers\n\n-- Create a parent table for partitioning\nCREATE TABLE orders (\n  id SERIAL PRIMARY KEY,\n  customer_id INT NOT NULL,\n  product_id INT NOT NULL,\n  quantity INT NOT NULL,\n  order_date DATE NOT NULL\n) PARTITION BY RANGE (order_date);\n\n-- Create foreign tables as partitions on different servers\nCREATE FOREIGN TABLE orders_202101 (\n  id INT PRIMARY KEY,\n  customer_id INT NOT NULL,\n  product_id INT NOT NULL,\n  quantity INT NOT NULL,\n  order_date DATE NOT NULL\n) SERVER shard1 PARTITION OF orders FOR VALUES FROM ('2021-01-01') TO ('2021-02-01');\n\nCREATE FOREIGN TABLE orders_202102 (\n  id INT PRIMARY KEY,\n  customer_id INT NOT NULL,\n  product_id INT NOT NULL,\n  quantity INT NOT NULL,\n  order_date DATE NOT NULL\n) SERVER shard2 PARTITION OF orders FOR VALUES FROM ('2021-02-01') TO ('2021-03-01');\n\n-- and so on for other partitions\n\n-- On each shard server\nCREATE TABLE orders_202101 (\n  id SERIAL PRIMARY KEY,\n  customer_id INT NOT NULL,\n  product_id INT NOT NULL,\n  quantity INT NOT NULL,\n  order_date DATE NOT NULL CHECK (order_date >= '2021-01-01' AND order_date < '2021-02-01')\n);\n\nCREATE TABLE orders_202102 (\n  id SERIAL PRIMARY KEY,\n  customer_id INT NOT NULL,\n  product_id INT NOT NULL,\n  quantity INT NOT NULL,\n  order_date DATE NOT NULL CHECK (order_date >= '2021-02-01' AND order_date < '2021-03-01')\n);\n\n-- and so on for other tables\n\n-- Insert data into the partitions\nINSERT INTO orders_202101 (customer_id, product_id, quantity, order_date) VALUES\n(1, 10, 2, '2021-01-01'),\n(2, 20, 1, '2021-01-02'),\n(3, 30, 3, '2021-01-03'),\n(4, 40, 4, '2021-01-04'),\n(5, 50, 5, '2021-01-05');\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Now you have horizontally sharded your ",(0,r.kt)("inlineCode",{parentName:"li"},"orders")," table into smaller tables on different servers. You can query them separately or through the parent table."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"orders")," table is a parent table that does not store any data itself, but only acts as a proxy for the partitions. When you insert data into the ",(0,r.kt)("inlineCode",{parentName:"li"},"orders")," table, PostgreSQL will automatically route the insert to the correct partition based on the ",(0,r.kt)("inlineCode",{parentName:"li"},"order_date")," value."))))}p.isMDXComponent=!0;const m={toc:[]},d="wrapper";function c(e){let{components:t,...l}=e;return(0,r.kt)(d,(0,n.Z)({},m,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Clustered index vs Non clustered index")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'A clustered index determine the physical order of rows in a table (when create primary key -> it\u2019s created automatically). Like "dictionary" No need of any other Index, its already Index according to words. Access directly => Faster, no need more disk space.'),(0,r.kt)("li",{parentName:"ul"},"A non clustered index is an index that does not affect the physical order of the rows, but stores a pointer to the location of each row. It is analogous to an index in a Book.The data is stored in one place. The index is storing in another place.")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"design-system",src:a(11383).Z,width:"868",height:"801"})),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"PostgreSQL does not support clustered indexes")),", but it has a ",(0,r.kt)("strong",{parentName:"p"},"CLUSTER")," command that can reorganize a table based on an existing index. However, this command does not maintain the order of the table after subsequent inserts, updates or deletes."),(0,r.kt)("p",null,"Here is a table that compares some of the features of clustered and non-clustered indexes:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Feature"),(0,r.kt)("th",{parentName:"tr",align:null},"Clustered Index"),(0,r.kt)("th",{parentName:"tr",align:null},"Non-Clustered Index"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Definition"),(0,r.kt)("td",{parentName:"tr",align:null},"An index that determines the physical order of the rows in a table"),(0,r.kt)("td",{parentName:"tr",align:null},"An index that does not affect the physical order of the rows, but stores a pointer to the data location")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Example"),(0,r.kt)("td",{parentName:"tr",align:null},"A phone book sorted by last name"),(0,r.kt)("td",{parentName:"tr",align:null},"An index at the end of a book that lists keywords and page numbers")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Creation"),(0,r.kt)("td",{parentName:"tr",align:null},"Automatically created by some database systems when defining a primary key, or manually created using a specific command"),(0,r.kt)("td",{parentName:"tr",align:null},"Manually created using a generic command")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Number"),(0,r.kt)("td",{parentName:"tr",align:null},"Only one per table"),(0,r.kt)("td",{parentName:"tr",align:null},"Multiple per table")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Disk space"),(0,r.kt)("td",{parentName:"tr",align:null},"No additional disk space required"),(0,r.kt)("td",{parentName:"tr",align:null},"Additional disk space required")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Performance"),(0,r.kt)("td",{parentName:"tr",align:null},"Faster for queries that access a range of rows or the entire table"),(0,r.kt)("td",{parentName:"tr",align:null},"Faster for queries that access a specific row or a subset of columns")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Maintenance"),(0,r.kt)("td",{parentName:"tr",align:null},"More costly to maintain when inserting, updating or deleting rows, as the physical order of the table may change"),(0,r.kt)("td",{parentName:"tr",align:null},"Less costly to maintain when inserting, updating or deleting rows, as only the pointers need to be updated"))))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Types of None_cluster Indexes in postgresql")),(0,r.kt)("p",null,"PostgreSQL supports several types of indexes, each with different storage structures and algorithms to handle different kinds of queries. According to the official documentation, the index types are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"B-tree"),": This is the default index type that can handle equality and range queries on data that can be sorted into some ordering. It can also be used to retrieve data in sorted order. B-tree indexes are suitable for most common situations."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Hash"),": This index type can only handle simple equality comparisons using the equal operator (=). Hash indexes are ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"faster than B-tree indexes"))," for simple equality queries, but they ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"do not support range queries or ordering")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"GiST"),": This stands for ",(0,r.kt)("strong",{parentName:"li"},"Generalized Search Tree"),", and it is an infrastructure that allows implementing many different indexing strategies. GiST indexes are useful for indexing ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"geometric data types and full-text searches")),", as well as other complex data types."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"SP-GiST"),": This stands for ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"Space-Partitioned GiST")),", and it is a variant of GiST that supports partitioned search trees. SP-GiST indexes are useful for data that has a natural clustering element and is not equally balanced, such as ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"geographic locations, phone numbers, IP addresses")),", etc."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"GIN"),": This stands for ",(0,r.kt)("strong",{parentName:"li"},"Generalized Inverted Index"),", and it is designed for ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"indexing multiple values stored in a single column, such as arrays, jsonb, hstore, and range types")),". GIN indexes are good for queries that test for the presence of a value or a set of values in a column."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"BRIN"),": This stands for ",(0,r.kt)("strong",{parentName:"li"},"Block Range Index"),", and it is a very compact index that stores only summary information about each block of data in a table. BRIN indexes are useful for very large tables that have a linear sort order on some column, such as timestamps or numeric identifiers. BRIN indexes can provide significant performance benefits with minimal storage costs.")),(0,r.kt)("p",null,"You can create an index of a specific type by using the USING clause in the CREATE INDEX statement. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE INDEX name ON table USING GIN (column);\n")),(0,r.kt)("p",null,"This creates a GIN index on the column of the table."),(0,r.kt)("p",null,"You can also use the extension bloom to create Bloom filter indexes, which are another type of compact index that can handle queries with multiple columns and operators.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Example of index in PostgreSQL")),(0,r.kt)("p",null,"To create an index on a table, you can use the CREATE INDEX command, which has the following syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ [ IF NOT EXISTS ] name ] ON [ ONLY ] table_name [ USING method ]\n( { column_name | ( expression ) } [ COLLATE collation ] [ opclass [ ( opclass_parameter = value [, ... ] ) ] ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )\n[ INCLUDE ( column_name [, ...] ) ]\n[ NULLS [ NOT ] DISTINCT ]\n[ WITH ( storage_parameter [= value] [, ... ] ) ]\n[ TABLESPACE tablespace_name ]\n[ WHERE predicate ]\n")),(0,r.kt)("p",null,"Example of an index in PostgreSQL:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE INDEX my_index ON my_table (column1, column2);\n")),(0,r.kt)("p",null,"This statement creates an index on the ",(0,r.kt)("inlineCode",{parentName:"p"},"column1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"column2")," columns of the ",(0,r.kt)("inlineCode",{parentName:"p"},"my_table")," table. The index will be sorted by the values of ",(0,r.kt)("inlineCode",{parentName:"p"},"column1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"column2")," in ascending order."),(0,r.kt)("p",null,"Here is another example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE UNIQUE INDEX my_unique_index ON my_table (column1);\n")),(0,r.kt)("p",null,"This statement creates a unique index on the ",(0,r.kt)("inlineCode",{parentName:"p"},"column1")," column of the ",(0,r.kt)("inlineCode",{parentName:"p"},"my_table")," table. This means that no two rows in the table can have the same value for ",(0,r.kt)("inlineCode",{parentName:"p"},"column1"),"."),(0,r.kt)("p",null,"To see how indexes are used by the database, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"EXPLAIN")," statement. For example, the following statement will show you how the ",(0,r.kt)("inlineCode",{parentName:"p"},"my_index")," index is used by the following query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"EXPLAIN SELECT * FROM my_table WHERE column1 = 'value1' AND column2 = 'value2';\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"EXPLAIN")," statement will show you the query plan, which is a diagram of how the database will execute the query. The query plan will show you how the index is used, if it is used at all.")))}c.isMDXComponent=!0;const N={toc:[]},h="wrapper";function k(e){let{components:t,...a}=e;return(0,r.kt)(h,(0,n.Z)({},N,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Programmable Objects")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Programmable objects")," are objects that can contain logic and perform operations on the data, such as functions, triggers, views, etc. ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Data objects")," are objects that store or organize the data itself, such as tables, indexes, sequences, etc. "))),(0,r.kt)("p",null,"Programmable objects and data objects can interact with each other, for example, a function can query a table, a trigger can update an index, a view can reference a sequence, etc."),(0,r.kt)("p",null,"Here are ",(0,r.kt)("strong",{parentName:"p"},"main programmable objects")," in PostgreSQL::"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"A stored procedure")," is ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"a block of code"))," that can be executed on demand by using the ",(0,r.kt)("strong",{parentName:"li"},"CALL")," statement. A stored procedure ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"can perform any action")),", such as ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"inserting, updating, deleting or selecting data, and can have input and output parameters")),". A stored procedure can also start and commit transactions within its body."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"A function")," is ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"a block of code that returns a single value or a table")),". A function can be used in queries, expressions or other functions, and can have input parameters. A function ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"cannot perform any action that modifies the database state")),", such as ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"inserting, updating or deleting data, and cannot start or commit transactions")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"A view")," is ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"a virtual table that represents the result of a query")),". A view can be used to simplify complex queries, provide data abstraction or implement security policies. A view ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"can be queried like a regular table")),", and ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"can also be updated, inserted or deleted"))," from if certain conditions are met."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"A trigger")," (or ",(0,r.kt)("strong",{parentName:"li"},"call back function"),") is ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"a block of code that is executed automatically whenever an event occurs on a table or a view")),", such as insert, update, delete or truncate. A trigger can be used to enforce business rules, maintain audit logs, replicate data or perform other actions. A trigger can be defined to ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"fire before, after or instead of the event")),", and for each row or statement affected by the event.")),(0,r.kt)("p",null,"There are ",(0,r.kt)("strong",{parentName:"p"},"other programmable objects")," in PostgreSQL, such as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Operators"),": symbolic functions that can be used in expressions, such as +, -, *, etc. PostgreSQL allows you to define custom operators using the ",(0,r.kt)("strong",{parentName:"li"},"CREATE OPERATOR")," command."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Casts"),": conversions between different data types, such as integer to text, text to date, etc. PostgreSQL allows you to define custom casts using the ",(0,r.kt)("strong",{parentName:"li"},"CREATE CAST")," command."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Sequences"),": objects that generate sequential numbers, such as for auto-increment columns. PostgreSQL allows you to create and manipulate sequences using the ",(0,r.kt)("strong",{parentName:"li"},"CREATE SEQUENCE"),", ",(0,r.kt)("strong",{parentName:"li"},"ALTER SEQUENCE")," and ",(0,r.kt)("strong",{parentName:"li"},"DROP SEQUENCE")," commands."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Extensions"),": packages of other objects, such as types, functions, operators, casts, indexes, etc., that can be installed and uninstalled as a unit. PostgreSQL allows you to create and manage extensions using the ",(0,r.kt)("strong",{parentName:"li"},"CREATE EXTENSION"),", ",(0,r.kt)("strong",{parentName:"li"},"ALTER EXTENSION")," and ",(0,r.kt)("strong",{parentName:"li"},"DROP EXTENSION")," commands."))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Stored Procedure")),(0,r.kt)("p",null,"A stored procedure is a block of code that can be executed on demand by using the ",(0,r.kt)("strong",{parentName:"p"},"CALL")," statement. A stored procedure can perform any action, such as inserting, updating, deleting or selecting data, and can have input and output parameters. A stored procedure can also start and commit transactions within its body."),(0,r.kt)("p",null,"The general form of a stored procedure in PostgreSQL is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE [ OR REPLACE ] PROCEDURE name ( [ [ argmode ] [ argname ] argtype [ { DEFAULT | = } default_expr ] [, ...] ] )\nLANGUAGE lang_name\nAS 'definition'\n")),(0,r.kt)("p",null,"In this syntax:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"CREATE PROCEDURE")," statement defines a new procedure with the given name and parameters."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"OR REPLACE")," option allows you to replace an existing procedure with the same name and parameters."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"argmode")," specifies the mode of an argument: IN, OUT, or INOUT. The default is IN."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"argname")," specifies the name of an argument."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"argtype")," specifies the data type of an argument."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"default_expr")," specifies an expression to be used as the default value for an argument if it is not specified."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"LANGUAGE")," clause specifies the language in which the procedure is written, such as SQL, PL/pgSQL, C, etc."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"AS 'definition'")," clause specifies the body of the procedure as a string constant.")),(0,r.kt)("p",null,"For example, the following statement creates a stored procedure named transfer that transfers a specified amount of money from one account to another:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE OR REPLACE PROCEDURE transfer (\n  sender INT,\n  receiver INT,\n  amount DEC\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n  -- subtracting the amount from the sender's account\n  UPDATE accounts SET balance = balance - amount WHERE id = sender;\n  -- adding the amount to the receiver's account\n  UPDATE accounts SET balance = balance + amount WHERE id = receiver;\n  COMMIT;\nEND;\n$$\n")),(0,r.kt)("p",null,"To execute this stored procedure, you use the ",(0,r.kt)("strong",{parentName:"p"},"CALL")," statement:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CALL transfer(1, 2, 1000);\n")),(0,r.kt)("p",null,"This will transfer 1000 from the account with id 1 to the account with id 2.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Function")),(0,r.kt)("p",null,"A function is a block of code that returns a single value or a table. A function can be used in queries, expressions or other functions, and can have input parameters. A function cannot perform any action that modifies the database state, such as inserting, updating or deleting data, and cannot start or commit transactions."),(0,r.kt)("p",null,"The general form of a function in PostgreSQL is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE [ OR REPLACE ] FUNCTION name ( [ [ argmode ] [ argname ] argtype [ { DEFAULT | = } default_expr ] [, ...] ] )\nRETURNS rettype\nLANGUAGE lang_name\nAS 'definition'\n")),(0,r.kt)("p",null,"In this syntax:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"CREATE FUNCTION")," statement defines a new function with the given name and parameters."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"OR REPLACE")," option allows you to replace an existing function with the same name and parameters."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"argmode")," specifies the mode of an argument: IN, OUT, INOUT, or VARIADIC. The default is IN."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"argname")," specifies the name of an argument."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"argtype")," specifies the data type of an argument."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"default_expr")," specifies an expression to be used as the default value for an argument if it is not specified."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"RETURNS")," clause specifies the return type of the function, which can be a single value or a table."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"LANGUAGE")," clause specifies the language in which the function is written, such as SQL, PL/pgSQL, C, etc."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"AS 'definition'")," clause specifies the body of the function as a string constant.")),(0,r.kt)("p",null,"For example, the following statement creates a function named get_balance that returns the balance of a given account:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE OR REPLACE FUNCTION get_balance(account_id INT)\nRETURNS DEC\nLANGUAGE plpgsql\nAS $$\nDECLARE\n  balance DEC;\nBEGIN\n  SELECT balance INTO balance FROM accounts WHERE id = account_id;\n  RETURN balance;\nEND;\n$$\n")),(0,r.kt)("p",null,"To execute this function, you can use it in a query like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT get_balance(1);\n")),(0,r.kt)("p",null,"This will return the balance of the account with id 1.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"View")),(0,r.kt)("p",null,"A view is a virtual table that represents the result of a query. A view can be used to simplify complex queries, provide data abstraction or implement security policies. A view can be queried like a regular table, and can also be updated, inserted or deleted from if certain conditions are met."),(0,r.kt)("p",null,"The general form of a view in PostgreSQL is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] VIEW name [ ( column_name [, ...] ) ]\nAS query\n")),(0,r.kt)("p",null,"In this syntax:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"CREATE VIEW")," statement defines a new view with the given name and columns."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"OR REPLACE")," option allows you to replace an existing view with the same name and columns."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"TEMP")," or ",(0,r.kt)("strong",{parentName:"li"},"TEMPORARY")," option allows you to create a temporary view that is automatically dropped at the end of the current session."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"column_name")," list specifies the names of the columns of the view. If not given, the column names are deduced from the query."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"AS query")," clause specifies the query that defines the view.")),(0,r.kt)("p",null,"For example, the following statement creates a view named customers_info that shows the name, email and phone number of each customer:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE VIEW customers_info AS\nSELECT name, email, phone FROM customers;\n")),(0,r.kt)("p",null,"To query this view, you can use it like a table:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM customers_info;\n")),(0,r.kt)("p",null,"This will return the same result as the query that defines the view.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Trigger")),(0,r.kt)("p",null,"A trigger is a block of code that is executed automatically whenever an event occurs on a table or a view, such as insert, update, delete or truncate. A trigger can be used to enforce business rules, maintain audit logs, replicate data or perform other actions. A trigger can be defined to fire before, after or instead of the event, and for each row or statement affected by the event."),(0,r.kt)("p",null,"The general form of a trigger in PostgreSQL is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE [ OR REPLACE ] [ CONSTRAINT ] TRIGGER name\n{ BEFORE | AFTER | INSTEAD OF } { event [ OR ... ] }\nON table_name [ FROM referenced_table_name ]\n[ NOT DEFERRABLE | [ DEFERRABLE ] [ INITIALLY IMMEDIATE | INITIALLY DEFERRED ] ]\n[ REFERENCING { { OLD | NEW } TABLE [ AS ] transition_relation_name } [ ... ] ]\n[ FOR [ EACH ] { ROW | STATEMENT } ]\n[ WHEN ( condition ) ]\nEXECUTE { FUNCTION | PROCEDURE } function_name ( arguments )\n")),(0,r.kt)("p",null,"In this syntax:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"CREATE TRIGGER")," statement defines a new trigger with the given name and event."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"OR REPLACE")," option allows you to replace an existing trigger with the same name and event."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"CONSTRAINT")," option indicates that the trigger is a constraint trigger, which means it can be deferred or made deferrable."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"BEFORE"),", ",(0,r.kt)("strong",{parentName:"li"},"AFTER")," or ",(0,r.kt)("strong",{parentName:"li"},"INSTEAD OF")," clause specifies the timing of the trigger, which determines when the trigger function is executed relative to the event."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"event")," specifies one or more events that activate the trigger, such as INSERT, UPDATE, DELETE or TRUNCATE."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"ON table_name")," clause specifies the table or view that the trigger is associated with."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"FROM referenced_table_name")," clause specifies an additional table that must be referenced by foreign-key constraint for the trigger to fire."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"NOT DEFERRABLE"),", ",(0,r.kt)("strong",{parentName:"li"},"DEFERRABLE"),", ",(0,r.kt)("strong",{parentName:"li"},"INITIALLY IMMEDIATE")," or ",(0,r.kt)("strong",{parentName:"li"},"INITIALLY DEFERRED")," clause specifies whether the trigger can be deferred until the end of the transaction and what is its default behavior."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"REFERENCING")," clause specifies transition tables that allow access to the old and new rows within the trigger function."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"FOR EACH ROW")," or ",(0,r.kt)("strong",{parentName:"li"},"FOR EACH STATEMENT")," clause specifies the granularity of the trigger, which determines whether the trigger function is executed once for each row affected by the event or once for each statement that causes the event."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"WHEN (condition)")," clause specifies an optional Boolean expression that must be satisfied for the trigger to fire."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"EXECUTE FUNCTION")," or ",(0,r.kt)("strong",{parentName:"li"},"EXECUTE PROCEDURE")," clause specifies the name and arguments of the trigger function to be executed when the trigger fires.")),(0,r.kt)("p",null,"For example, the following statement creates a trigger named customers_audit_trigger that logs every insert operation on the customers table into a customers_audit table:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- create a table for audit log\nCREATE TABLE customers_audit (\n    operation CHAR(1) NOT NULL,\n    stamp TIMESTAMP NOT NULL,\n    userid TEXT NOT NULL,\n    customer_id INT NOT NULL,\n    customer_name TEXT NOT NULL\n);\n\n-- create a trigger function\nCREATE FUNCTION log_customers_changes() RETURNS TRIGGER AS $$\nBEGIN\n    IF (TG_OP = 'INSERT') THEN\n        INSERT INTO customers_audit SELECT 'I', now(), user, NEW.*;\n        RETURN NEW;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- create a trigger\nCREATE TRIGGER customers_audit_trigger\nAFTER INSERT ON customers\nFOR EACH ROW EXECUTE FUNCTION log_customers_changes();\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Materialized Views")),(0,r.kt)("p",null,"A materialized view is a virtual table that represents the result of a query, but stores data physically and periodically refreshes data from the base tables. A materialized view can be used to improve the performance of queries that involve complex calculations or remote data sources."),(0,r.kt)("p",null,"The general form of a materialized view in PostgreSQL is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] MATERIALIZED VIEW name [ ( column_name [, ...] ) ]\nAS query\n[ WITH [ NO ] DATA ]\n")),(0,r.kt)("p",null,"In this syntax:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"CREATE MATERIALIZED VIEW")," statement defines a new materialized view with the given name and columns."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"OR REPLACE")," option allows you to replace an existing materialized view with the same name and columns."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"TEMP")," or ",(0,r.kt)("strong",{parentName:"li"},"TEMPORARY")," option allows you to create a temporary materialized view that is automatically dropped at the end of the current session."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"column_name")," list specifies the names of the columns of the materialized view. If not given, the column names are deduced from the query."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"AS query")," clause specifies the query that defines the materialized view."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"WITH ","[NO]"," DATA")," clause indicates whether the materialized view should be populated with data at creation time or not.")),(0,r.kt)("p",null,"For example, the following statement creates a materialized view named customers_info that shows the name, email and phone number of each customer:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE MATERIALIZED VIEW customers_info\nAS\nSELECT name, email, phone FROM customers\nWITH NO DATA;\n")),(0,r.kt)("p",null,"This will create a materialized view, but without populating it with data. To populate the materialized view with data, you need to use the ",(0,r.kt)("strong",{parentName:"p"},"REFRESH MATERIALIZED VIEW")," command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"REFRESH MATERIALIZED VIEW customers_info;\n")),(0,r.kt)("p",null,"This will refresh the data in the materialized view from the base table. You can also use various options to control how the refresh is performed, such as ",(0,r.kt)("strong",{parentName:"p"},"CONCURRENTLY"),", ",(0,r.kt)("strong",{parentName:"p"},"WITH ","[NO]"," DATA"),", etc.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Materialized Views vs Views")),(0,r.kt)("p",null,"Here is a table that compares some of the features of materialized views and views:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Feature"),(0,r.kt)("th",{parentName:"tr",align:null},"Materialized View"),(0,r.kt)("th",{parentName:"tr",align:null},"View"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Data storage"),(0,r.kt)("td",{parentName:"tr",align:null},"Stores data physically"),(0,r.kt)("td",{parentName:"tr",align:null},"Does not store data")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Data population"),(0,r.kt)("td",{parentName:"tr",align:null},"Populated at creation time or when refreshed"),(0,r.kt)("td",{parentName:"tr",align:null},"Populated every time queried")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Performance"),(0,r.kt)("td",{parentName:"tr",align:null},"Faster for queries that involve complex calculations or remote data sources"),(0,r.kt)("td",{parentName:"tr",align:null},"Faster for queries that access the base tables directly")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Data freshness"),(0,r.kt)("td",{parentName:"tr",align:null},"Needs to be refreshed periodically to reflect the changes in the base tables"),(0,r.kt)("td",{parentName:"tr",align:null},"Always shows the latest data from the base tables")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Indexes, constraints and triggers"),(0,r.kt)("td",{parentName:"tr",align:null},"Can have indexes, constraints and triggers defined on it"),(0,r.kt)("td",{parentName:"tr",align:null},"Cannot have indexes, constraints and triggers defined on it"))))))}k.isMDXComponent=!0;const g={toc:[]},E="wrapper";function f(e){let{components:t,...a}=e;return(0,r.kt)(E,(0,n.Z)({},g,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Gouping and managing multiple operations")),(0,r.kt)("p",null,"Grouping and managing multiple operations on the data in a database in PostgreSQL can be done in various ways, depending on the purpose and complexity of the operations. Some of the ways are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Using the ",(0,r.kt)("strong",{parentName:"li"},"GROUP BY")," clause: The ",(0,r.kt)("strong",{parentName:"li"},"GROUP BY")," clause allows you to group rows that have the same values in one or more columns and apply aggregate functions to each group. For example, you can use the ",(0,r.kt)("strong",{parentName:"li"},"GROUP BY")," clause to calculate the total sales by product category or by month\xb9."),(0,r.kt)("li",{parentName:"ul"},"Using the ",(0,r.kt)("strong",{parentName:"li"},"GROUPING SETS")," clause: The ",(0,r.kt)("strong",{parentName:"li"},"GROUPING SETS")," clause is a subclause of the ",(0,r.kt)("strong",{parentName:"li"},"GROUP BY")," clause that allows you to generate multiple grouping sets in one query. For example, you can use the ",(0,r.kt)("strong",{parentName:"li"},"GROUPING SETS")," clause to get a sales report with rows for sales per year and rows for sales per department."),(0,r.kt)("li",{parentName:"ul"},"Using the ",(0,r.kt)("strong",{parentName:"li"},"UNION ALL")," operator: The ",(0,r.kt)("strong",{parentName:"li"},"UNION ALL")," operator allows you to combine multiple queries into one result set. For example, you can use the ",(0,r.kt)("strong",{parentName:"li"},"UNION ALL")," operator to get a sales report with rows for sales per year, rows for sales per department, and rows for total sales\xb3."),(0,r.kt)("li",{parentName:"ul"},"Using recursive queries: Recursive queries are queries that refer to themselves or to another query of the same name. Recursive queries can be useful for performing hierarchical or tree-structured data operations, such as finding all descendants of a parent node or finding the shortest path between two nodes."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Transactions"),": are a way of bundling multiple steps into a single, all-or-nothing operation. Transactions can be started and ended by using the BEGIN, COMMIT, and ROLLBACK commands. Transactions can also be nested using savepoints or prepared for commit in another session. Transactions ensure that the operations are atomic, consistent, isolated, and durable (ACID)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Batch processing"),": Batch processing is a technique of executing a series of SQL commands or scripts as a single unit, typically in a non-interactive mode. Batch processing can be useful for performing data loading, data transformation, data analysis, or data backup tasks. You can use tools such as psql or pgAdmin to run batch processing in PostgreSQL."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Using stored procedures or functions"),": Stored procedures or functions are blocks of code that can be executed on demand by using the ",(0,r.kt)("strong",{parentName:"li"},"CALL")," or ",(0,r.kt)("strong",{parentName:"li"},"SELECT")," statement. Stored procedures or functions can perform any action, such as inserting, updating, deleting or selecting data, and can have input and output parameters. Stored procedures or functions can also start and commit transactions within their body ."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Using triggers"),": Triggers are blocks of code that are executed automatically whenever an event occurs on a table or a view, such as insert, update, delete or truncate. Triggers can be used to enforce business rules, maintain audit logs, replicate data or perform other actions. Triggers can be defined to fire before, after or instead of the event, and for each row or statement affected by the event."))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Transactions")),(0,r.kt)("p",null,"Transactions are a fundamental concept of all database systems. They allow you to perform multiple operations as a single, atomic unit of work that either succeeds or fails as a whole. PostgreSQL supports transactions using the ",(0,r.kt)("strong",{parentName:"p"},"BEGIN"),", ",(0,r.kt)("strong",{parentName:"p"},"COMMIT"),", and ",(0,r.kt)("strong",{parentName:"p"},"ROLLBACK")," statements."),(0,r.kt)("p",null,"Here are some examples of how to use transactions in PostgreSQL:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To start a transaction, you can use any of these statements: ",(0,r.kt)("inlineCode",{parentName:"li"},"BEGIN TRANSACTION;"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"BEGIN WORK;"),", or ",(0,r.kt)("inlineCode",{parentName:"li"},"BEGIN;"),". For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"BEGIN;\nINSERT INTO accounts (name, balance) VALUES ('Alice', 10000);\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To end a transaction and make the changes permanent, you can use any of these statements: ",(0,r.kt)("inlineCode",{parentName:"li"},"COMMIT TRANSACTION;"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"COMMIT WORK;"),", or ",(0,r.kt)("inlineCode",{parentName:"li"},"COMMIT;"),". For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"COMMIT;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To cancel a transaction and undo the changes, you can use any of these statements: ",(0,r.kt)("inlineCode",{parentName:"li"},"ROLLBACK TRANSACTION;"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"ROLLBACK WORK;"),", or ",(0,r.kt)("inlineCode",{parentName:"li"},"ROLLBACK;"),". For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"ROLLBACK;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To specify the transaction mode, you can use the ",(0,r.kt)("inlineCode",{parentName:"li"},"SET TRANSACTION")," statement before the first command in the transaction. The transaction mode determines how the transaction interacts with other concurrent transactions. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"BEGIN;\nSET TRANSACTION READ ONLY;\nSELECT * FROM accounts;\nCOMMIT;\n")),(0,r.kt)("p",null,"This transaction will only perform read operations and will not see any changes made by other transactions after it starts.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Batch Processing")),(0,r.kt)("p",null,"Batch processing is a technique to perform multiple operations in a single database connection, which can improve the performance and efficiency of data loading or manipulation. PostgreSQL supports several ways to do batch processing, such as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Using the ",(0,r.kt)("strong",{parentName:"li"},"COPY")," command to load data from a file or standard input into a table. This is the fastest way to insert large amounts of data into PostgreSQL, but it requires access to the file system of the server or client. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"COPY table_name FROM '/path/to/file.csv' WITH (FORMAT csv);\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Using the ",(0,r.kt)("strong",{parentName:"li"},"multirow values")," syntax to insert multiple rows with a single ",(0,r.kt)("strong",{parentName:"li"},"INSERT")," statement. This can reduce the network overhead and parsing cost of sending many individual statements. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO table_name (col1, col2, col3) VALUES\n(row1_val1, row1_val2, row1_val3),\n(row2_val1, row2_val2, row2_val3),\n...\n(rowN_val1, rowN_val2, rowN_val3);\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Using the ",(0,r.kt)("strong",{parentName:"li"},"pgloader")," tool to load data from various sources (such as CSV, JSON, XML, MySQL, SQLite, etc.) into PostgreSQL. This tool can handle errors, data transformations, schema changes, and other options. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"pgloader mysql://user@host/dbname postgresql:///dbname\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Using a ",(0,r.kt)("strong",{parentName:"li"},"batch file")," to execute a series of SQL commands or scripts from the command line. This can be useful for automation or scheduling tasks. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-batch"},"@echo off\npsql -h localhost -U postgres -d dbname -f script.sql\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"GROUP BY")),(0,r.kt)("p",null,"The GROUP BY clause in PostgreSQL is used to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"group rows that have the same values"))," in one or more columns ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"and apply an aggregate function"))," to each group. The GROUP BY clause is often used with aggregate functions such as SUM, COUNT, AVG, MIN, MAX, etc. to calculate summary statistics for each group. Here is an example of using the GROUP BY clause in PostgreSQL:"),(0,r.kt)("p",null,"Suppose you have a table called employees that stores the information of employees in a company, such as id, name, gender, department, salary, etc. The table looks like this:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"id"),(0,r.kt)("th",{parentName:"tr",align:null},"name"),(0,r.kt)("th",{parentName:"tr",align:null},"gender"),(0,r.kt)("th",{parentName:"tr",align:null},"department"),(0,r.kt)("th",{parentName:"tr",align:null},"salary"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Alice"),(0,r.kt)("td",{parentName:"tr",align:null},"F"),(0,r.kt)("td",{parentName:"tr",align:null},"IT"),(0,r.kt)("td",{parentName:"tr",align:null},"5000")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"Bob"),(0,r.kt)("td",{parentName:"tr",align:null},"M"),(0,r.kt)("td",{parentName:"tr",align:null},"HR"),(0,r.kt)("td",{parentName:"tr",align:null},"4000")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},"Carol"),(0,r.kt)("td",{parentName:"tr",align:null},"F"),(0,r.kt)("td",{parentName:"tr",align:null},"Sales"),(0,r.kt)("td",{parentName:"tr",align:null},"6000")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"David"),(0,r.kt)("td",{parentName:"tr",align:null},"M"),(0,r.kt)("td",{parentName:"tr",align:null},"IT"),(0,r.kt)("td",{parentName:"tr",align:null},"7000")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"Eve"),(0,r.kt)("td",{parentName:"tr",align:null},"F"),(0,r.kt)("td",{parentName:"tr",align:null},"Marketing"),(0,r.kt)("td",{parentName:"tr",align:null},"4500")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},"Frank"),(0,r.kt)("td",{parentName:"tr",align:null},"M"),(0,r.kt)("td",{parentName:"tr",align:null},"Sales"),(0,r.kt)("td",{parentName:"tr",align:null},"5500")))),(0,r.kt)("p",null,"If you want to find out the total salary of each department, you can use the GROUP BY clause to group the rows by the department column and apply the SUM function to the salary column. The query looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT department, SUM(salary) AS total_salary\nFROM employees\nGROUP BY department;\n")),(0,r.kt)("p",null,"The output of the query is:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"department"),(0,r.kt)("th",{parentName:"tr",align:null},"total_salary"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"IT"),(0,r.kt)("td",{parentName:"tr",align:null},"12000")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"HR"),(0,r.kt)("td",{parentName:"tr",align:null},"4000")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Sales"),(0,r.kt)("td",{parentName:"tr",align:null},"11500")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Marketing"),(0,r.kt)("td",{parentName:"tr",align:null},"4500")))),(0,r.kt)("p",null,"The query divides the rows in the employees table into four groups based on the values in the department column: IT, HR, Sales, and Marketing. For each group, it calculates the sum of the salary column and returns it as total_salary."),(0,r.kt)("p",null,"You can also use multiple columns in the GROUP BY clause to create more specific groups. For example, if you want to find out the number of male and female employees in each department, you can use the GROUP BY clause with both gender and department columns. The query looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT gender, department, COUNT(*) AS employee_count\nFROM employees\nGROUP BY gender, department;\n")),(0,r.kt)("p",null,"The output of the query is:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"gender"),(0,r.kt)("th",{parentName:"tr",align:null},"department"),(0,r.kt)("th",{parentName:"tr",align:null},"employee_count"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"F"),(0,r.kt)("td",{parentName:"tr",align:null},"IT"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"M"),(0,r.kt)("td",{parentName:"tr",align:null},"HR"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"F"),(0,r.kt)("td",{parentName:"tr",align:null},"Sales"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"M"),(0,r.kt)("td",{parentName:"tr",align:null},"IT"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"F"),(0,r.kt)("td",{parentName:"tr",align:null},"Marketing"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"M"),(0,r.kt)("td",{parentName:"tr",align:null},"Sales"),(0,r.kt)("td",{parentName:"tr",align:null},"1")))),(0,r.kt)("p",null,"The query ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"divides the rows in the employees table into six groups"))," based on the values in both gender and department columns: ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"(F, IT), (M, HR), (F, Sales), (M, IT), (F, Marketing), and (M, Sales)")),". For each group, it counts the number of rows and returns it as employee_count.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"GROUPING SETS")),(0,r.kt)("p",null,"The GROUPING SETS clause in PostgreSQL is used to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"specify multiple grouping sets in a single GROUP BY clause")),". A grouping set is a set of columns or expressions by which you group the rows. The result of the GROUPING SETS clause is equivalent to the union of the results of each individual grouping set. The GROUPING SETS clause is ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"often used with aggregate functions"))," to calculate summary statistics for different levels of granularity. Here is an example of using the GROUPING SETS clause in PostgreSQL:"),(0,r.kt)("p",null,"Suppose you have a table called sales that stores the information of sales transactions in a company, such as date, product, quantity, price, etc. The table looks like this:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"date"),(0,r.kt)("th",{parentName:"tr",align:null},"product"),(0,r.kt)("th",{parentName:"tr",align:null},"quantity"),(0,r.kt)("th",{parentName:"tr",align:null},"price"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2021-01-01"),(0,r.kt)("td",{parentName:"tr",align:null},"A"),(0,r.kt)("td",{parentName:"tr",align:null},"10"),(0,r.kt)("td",{parentName:"tr",align:null},"100")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2021-01-01"),(0,r.kt)("td",{parentName:"tr",align:null},"B"),(0,r.kt)("td",{parentName:"tr",align:null},"20"),(0,r.kt)("td",{parentName:"tr",align:null},"50")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2021-01-02"),(0,r.kt)("td",{parentName:"tr",align:null},"A"),(0,r.kt)("td",{parentName:"tr",align:null},"15"),(0,r.kt)("td",{parentName:"tr",align:null},"100")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2021-01-02"),(0,r.kt)("td",{parentName:"tr",align:null},"C"),(0,r.kt)("td",{parentName:"tr",align:null},"30"),(0,r.kt)("td",{parentName:"tr",align:null},"80")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2021-01-03"),(0,r.kt)("td",{parentName:"tr",align:null},"B"),(0,r.kt)("td",{parentName:"tr",align:null},"25"),(0,r.kt)("td",{parentName:"tr",align:null},"50")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2021-01-03"),(0,r.kt)("td",{parentName:"tr",align:null},"C"),(0,r.kt)("td",{parentName:"tr",align:null},"35"),(0,r.kt)("td",{parentName:"tr",align:null},"80")))),(0,r.kt)("p",null,"If you want to find out the total sales amount by date, by product, and overall, you can use the GROUPING SETS clause to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"specify three grouping sets: ",(0,r.kt)("inlineCode",{parentName:"em"},"(date)"),", ",(0,r.kt)("inlineCode",{parentName:"em"},"(product)"),", and ",(0,r.kt)("inlineCode",{parentName:"em"},"()"))),". The query looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT date, product, SUM(quantity * price) AS total_sales\nFROM sales\nGROUP BY GROUPING SETS ( (date), (product), () );\n")),(0,r.kt)("p",null,"The output of the query is:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"date"),(0,r.kt)("th",{parentName:"tr",align:null},"product"),(0,r.kt)("th",{parentName:"tr",align:null},"total_sales"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2021-01-01"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"2000")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2021-01-02"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"3900")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2021-01-03"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"4300")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"A"),(0,r.kt)("td",{parentName:"tr",align:null},"2500")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"B"),(0,r.kt)("td",{parentName:"tr",align:null},"2250")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"C"),(0,r.kt)("td",{parentName:"tr",align:null},"5200")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"10200")))),(0,r.kt)("p",null,"The query ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"divides the rows in the sales table into six groups"))," based on the values in the date and product columns: ",(0,r.kt)("inlineCode",{parentName:"p"},"(2021-01-01), (2021-01-02), (2021-01-03), (A), (B), (C), and ()"),". For each group, it calculates the sum of the ",(0,r.kt)("inlineCode",{parentName:"p"},"quantity * price")," expression and returns it as total_sales."),(0,r.kt)("p",null,"You can also ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"use the GROUPING() function in conjunction with the GROUPING SETS clause to distinguish the result rows")),". ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"The GROUPING() function takes one or more arguments that must match the expressions in the GROUP BY clause. It returns 0 if the argument is a member of the current grouping set, or 1 if it is not")),". For example, you can use the GROUPING() function to add a column that indicates which level of granularity each row belongs to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT date, product, SUM(quantity * price) AS total_sales,\nCASE\n    WHEN GROUPING(date) = 0 AND GROUPING(product) = 0 THEN 'Date and Product'\n    WHEN GROUPING(date) = 0 AND GROUPING(product) = 1 THEN 'Date'\n    WHEN GROUPING(date) = 1 AND GROUPING(product) = 0 THEN 'Product'\n    WHEN GROUPING(date) = 1 AND GROUPING(product) = 1 THEN 'Overall'\nEND AS level\nFROM sales\nGROUP BY GROUPING SETS ( (date, product), (date), (product), () );\n")),(0,r.kt)("p",null,"The output of the query is:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"date"),(0,r.kt)("th",{parentName:"tr",align:null},"product"),(0,r.kt)("th",{parentName:"tr",align:null},"total_sales"),(0,r.kt)("th",{parentName:"tr",align:null},"level"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2021-01-01"),(0,r.kt)("td",{parentName:"tr",align:null},"A"),(0,r.kt)("td",{parentName:"tr",align:null},"1000"),(0,r.kt)("td",{parentName:"tr",align:null},"Date and Product")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2021-01-01"),(0,r.kt)("td",{parentName:"tr",align:null},"B"),(0,r.kt)("td",{parentName:"tr",align:null},"1000"),(0,r.kt)("td",{parentName:"tr",align:null},"Date and Product")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2021-01-02"),(0,r.kt)("td",{parentName:"tr",align:null},"A"),(0,r.kt)("td",{parentName:"tr",align:null},"1500"),(0,r.kt)("td",{parentName:"tr",align:null},"Date and Product")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2021-01-02"),(0,r.kt)("td",{parentName:"tr",align:null},"C"),(0,r.kt)("td",{parentName:"tr",align:null},"2400"),(0,r.kt)("td",{parentName:"tr",align:null},"Date and Product")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2021-01-03"),(0,r.kt)("td",{parentName:"tr",align:null},"B"),(0,r.kt)("td",{parentName:"tr",align:null},"1250"),(0,r.kt)("td",{parentName:"tr",align:null},"Date and Product")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2021-01-03"),(0,r.kt)("td",{parentName:"tr",align:null},"C"),(0,r.kt)("td",{parentName:"tr",align:null},"2800"),(0,r.kt)("td",{parentName:"tr",align:null},"Date and Product")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"A"),(0,r.kt)("td",{parentName:"tr",align:null},"2500"),(0,r.kt)("td",{parentName:"tr",align:null},"Product")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"B"),(0,r.kt)("td",{parentName:"tr",align:null},"2250"),(0,r.kt)("td",{parentName:"tr",align:null},"Product")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"C"),(0,r.kt)("td",{parentName:"tr",align:null},"5200"),(0,r.kt)("td",{parentName:"tr",align:null},"Product")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null}))))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"UNION ALL")),(0,r.kt)("p",null,"The UNION ALL clause in PostgreSQL is used to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"combine the results of two or more SELECT statements into a single result set"))," that includes all the rows from both queries, including duplicates. The UNION ALL clause is ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"similar to the UNION clause, except that it does not remove duplicate rows from the result set")),". The UNION ALL clause is often ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"used when you want to preserve the original data without any modification or when you want to improve the performance of the query by avoiding the overhead of duplicate elimination")),". Here is an example of using the UNION ALL clause in PostgreSQL:"),(0,r.kt)("p",null,"Suppose you have two tables called products and services that store the information of products and services offered by a company, such as name, price, category, etc. The tables look like this:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"name"),(0,r.kt)("th",{parentName:"tr",align:null},"price"),(0,r.kt)("th",{parentName:"tr",align:null},"category"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"A"),(0,r.kt)("td",{parentName:"tr",align:null},"100"),(0,r.kt)("td",{parentName:"tr",align:null},"IT")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"B"),(0,r.kt)("td",{parentName:"tr",align:null},"50"),(0,r.kt)("td",{parentName:"tr",align:null},"HR")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"C"),(0,r.kt)("td",{parentName:"tr",align:null},"80"),(0,r.kt)("td",{parentName:"tr",align:null},"Sales")))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"name"),(0,r.kt)("th",{parentName:"tr",align:null},"price"),(0,r.kt)("th",{parentName:"tr",align:null},"category"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"D"),(0,r.kt)("td",{parentName:"tr",align:null},"120"),(0,r.kt)("td",{parentName:"tr",align:null},"IT")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"E"),(0,r.kt)("td",{parentName:"tr",align:null},"40"),(0,r.kt)("td",{parentName:"tr",align:null},"Marketing")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"F"),(0,r.kt)("td",{parentName:"tr",align:null},"60"),(0,r.kt)("td",{parentName:"tr",align:null},"Sales")))),(0,r.kt)("p",null,"If you want to find out the names and prices of all products and services, you can use the UNION ALL clause to combine the results of two SELECT statements. The query looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT name, price FROM products\nUNION ALL\nSELECT name, price FROM services;\n")),(0,r.kt)("p",null,"The output of the query is:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"name"),(0,r.kt)("th",{parentName:"tr",align:null},"price"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"A"),(0,r.kt)("td",{parentName:"tr",align:null},"100")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"B"),(0,r.kt)("td",{parentName:"tr",align:null},"50")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"C"),(0,r.kt)("td",{parentName:"tr",align:null},"80")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"D"),(0,r.kt)("td",{parentName:"tr",align:null},"120")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"E"),(0,r.kt)("td",{parentName:"tr",align:null},"40")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"F"),(0,r.kt)("td",{parentName:"tr",align:null},"60")))),(0,r.kt)("p",null,"The query returns all rows from both tables, without removing any duplicates. Note that if there are any duplicate rows in either table, they will also be included in the result set."),(0,r.kt)("p",null,"To use the UNION ALL clause, you need to follow these rules:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The number and order of columns in each SELECT statement must be the same."),(0,r.kt)("li",{parentName:"ul"},"The data types of corresponding columns in each SELECT statement must be compatible or convertible."),(0,r.kt)("li",{parentName:"ul"},"You can use other clauses such as ORDER BY or LIMIT with the UNION ALL clause, but they must be applied to the final result set, not to each individual query."))))}f.isMDXComponent=!0;const b={toc:[]},y="wrapper";function T(e){let{components:t,...a}=e;return(0,r.kt)(y,(0,n.Z)({},b,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"DDL vs DML")),(0,r.kt)("p",null,"DDL and DML are two types of SQL statements that have different purposes and effects on the database."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"DDL stands for Data Definition Language"),". DDL is used to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"define the structure and schema of the database, such as tables, columns, indexes, constraints")),", etc. DDL statements include ",(0,r.kt)("strong",{parentName:"p"},"CREATE"),", ",(0,r.kt)("strong",{parentName:"p"},"ALTER"),", ",(0,r.kt)("strong",{parentName:"p"},"DROP"),", ",(0,r.kt)("strong",{parentName:"p"},"TRUNCATE"),", ",(0,r.kt)("strong",{parentName:"p"},"COMMENT"),", and ",(0,r.kt)("strong",{parentName:"p"},"RENAME"),". DDL statements operate on the entire table or object and ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"do not have a ",(0,r.kt)("inlineCode",{parentName:"em"},"WHERE")," clause"))," to filter the data. DDL statements are usually ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"executed by database administrators or developer")),"s who need to create or modify the database schema."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"DML stands for Data Manipulation Language"),". DML is used to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"manipulate and retrieve data within the database, such as inserting, updating, deleting, or selecting"))," records. DML statements include ",(0,r.kt)("strong",{parentName:"p"},"SELECT"),", ",(0,r.kt)("strong",{parentName:"p"},"INSERT"),", ",(0,r.kt)("strong",{parentName:"p"},"UPDATE"),", ",(0,r.kt)("strong",{parentName:"p"},"DELETE"),", ",(0,r.kt)("strong",{parentName:"p"},"MERGE"),", ",(0,r.kt)("strong",{parentName:"p"},"CALL"),", ",(0,r.kt)("strong",{parentName:"p"},"EXPLAIN PLAN"),", and ",(0,r.kt)("strong",{parentName:"p"},"LOCK TABLE"),". DML statements operate on individual rows or groups of rows and ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"use a ",(0,r.kt)("inlineCode",{parentName:"em"},"WHERE")," clause"))," to filter the data. DML statements are usually ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"executed by end-users or applications"))," who need to perform data operations on the database."),(0,r.kt)("p",null,"Here are some examples of DDL and DML statements in PostgreSQL:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To create a table named customers with three columns: id, name, and email, you can use this DDL statement:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE customers (\n  id SERIAL PRIMARY KEY,\n  name VARCHAR(100) NOT NULL,\n  email VARCHAR(100) UNIQUE\n);\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To insert a new record into the customers table, you can use this DML statement:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO customers (name, email) VALUES ('John Doe', 'john.doe@example.com');\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To add a new column named phone to the customers table, you can use this DDL statement:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"ALTER TABLE customers ADD COLUMN phone VARCHAR(20);\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To update the phone number of a customer with id 1, you can use this DML statement:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"UPDATE customers SET phone = '123-456-7890' WHERE id = 1;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To delete the customer with id 1 from the customers table, you can use this DML statement:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"DELETE FROM customers WHERE id = 1;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To drop the customers table from the database, you can use this DDL statement:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"DROP TABLE customers;\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"DDL Examples")),(0,r.kt)("p",null,"CREATE, ALTER, DROP, TRUNCATE, COMMENT, and RENAME are some of the DDL (Data Definition Language) statements in PostgreSQL. They are used to define or modify the structure and schema of the database objects, such as tables, columns, indexes, constraints, etc. Here are some examples of how to use them in PostgreSQL:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To create a table named products with four columns: id, name, price, and category_id, you can use this DDL statement:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE products (\n  id SERIAL PRIMARY KEY,\n  name VARCHAR(100) NOT NULL,\n  price NUMERIC(10,2) CHECK (price >= 0),\n  category_id INTEGER REFERENCES categories(id)\n);\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To alter the table products by adding a new column named description and changing the data type of the price column to DECIMAL(12,2), you can use this DDL statement:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"ALTER TABLE products\nADD COLUMN description TEXT,\nALTER COLUMN price TYPE DECIMAL(12,2);\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To drop the table products from the database, you can use this DDL statement:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"DROP TABLE products;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To truncate the table products by deleting all the data and resetting the serial column values, you can use this DDL statement:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"TRUNCATE TABLE products RESTART IDENTITY;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To add comments to the table products and its columns, you can use these DDL statements:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"COMMENT ON TABLE products IS 'This table stores the product information';\nCOMMENT ON COLUMN products.id IS 'This is the primary key of the table';\nCOMMENT ON COLUMN products.name IS 'This is the name of the product';\nCOMMENT ON COLUMN products.price IS 'This is the price of the product';\nCOMMENT ON COLUMN products.category_id IS 'This is the foreign key to the categories table';\nCOMMENT ON COLUMN products.description IS 'This is the description of the product';\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To rename the table products to items and the column category_id to cat_id, you can use these DDL statements:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"ALTER TABLE products RENAME TO items;\nALTER TABLE items RENAME COLUMN category_id TO cat_id;\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"DML Examples")),(0,r.kt)("p",null,"SELECT, INSERT, UPDATE, DELETE, MERGE, CALL, EXPLAIN PLAN, and LOCK TABLE are some of the DML (Data Manipulation Language) statements in PostgreSQL. They are used to manipulate and retrieve data within the database tables. Here are some examples of how to use them in PostgreSQL:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To select all the columns and rows from the products table, you can use this DML statement:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM products;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To insert a new row into the products table with values for name, price, and category_id columns, you can use this DML statement:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO products (name, price, category_id) VALUES ('Laptop', 999.99, 1);\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To update the price of the product with id 1 to 899.99, you can use this DML statement:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"UPDATE products SET price = 899.99 WHERE id = 1;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To delete the product with id 1 from the products table, you can use this DML statement:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"DELETE FROM products WHERE id = 1;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To merge the data from the categories table into the products table based on the matching category_id values, you can use this DML statement:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"MERGE INTO products AS p\nUSING categories AS c\nON p.category_id = c.id\nWHEN MATCHED THEN\nUPDATE SET p.category_name = c.name\nWHEN NOT MATCHED THEN\nINSERT (name, price, category_id, category_name)\nVALUES ('Unknown', 0.00, c.id, c.name);\n")),(0,r.kt)("p",null,"To illustrate how this statement works, let's assume that we have the following input tables:"),(0,r.kt)("p",null,"products:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"id"),(0,r.kt)("th",{parentName:"tr",align:null},"name"),(0,r.kt)("th",{parentName:"tr",align:null},"price"),(0,r.kt)("th",{parentName:"tr",align:null},"category_id"),(0,r.kt)("th",{parentName:"tr",align:null},"category_name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Laptop"),(0,r.kt)("td",{parentName:"tr",align:null},"999.99"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Electronics")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"Book"),(0,r.kt)("td",{parentName:"tr",align:null},"19.99"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"Books")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},"Pen"),(0,r.kt)("td",{parentName:"tr",align:null},"0.99"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"Books")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"Keyboard"),(0,r.kt)("td",{parentName:"tr",align:null},"49.99"),(0,r.kt)("td",{parentName:"tr",align:null},"NULL"),(0,r.kt)("td",{parentName:"tr",align:null},"NULL")))),(0,r.kt)("p",null,"categories:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"id"),(0,r.kt)("th",{parentName:"tr",align:null},"name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Electronics")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"Books")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},"Stationery")))),(0,r.kt)("p",null,"After executing the MERGE statement, the output table would look like this:"),(0,r.kt)("p",null,"products:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"id"),(0,r.kt)("th",{parentName:"tr",align:null},"name"),(0,r.kt)("th",{parentName:"tr",align:null},"price"),(0,r.kt)("th",{parentName:"tr",align:null},"category_id"),(0,r.kt)("th",{parentName:"tr",align:null},"category_name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Laptop"),(0,r.kt)("td",{parentName:"tr",align:null},"999.99"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Electronics")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"Book"),(0,r.kt)("td",{parentName:"tr",align:null},"19.99"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"Books")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},"Pen"),(0,r.kt)("td",{parentName:"tr",align:null},"0.99"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"Books")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"Keyboard"),(0,r.kt)("td",{parentName:"tr",align:null},"49.99"),(0,r.kt)("td",{parentName:"tr",align:null},"NULL"),(0,r.kt)("td",{parentName:"tr",align:null},"NULL")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"Unknown"),(0,r.kt)("td",{parentName:"tr",align:null},"0.00"),(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},"Stationery")))),(0,r.kt)("p",null,"As you can see, the product with id = 4 was not updated because it had a NULL value for category_id, which did not match any value in the categories table. The product with id = 5 was inserted because there was no product with category_id = 3 in the products table. The other products were updated with their corresponding category names from the categories table."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To call a stored procedure named get_product_info that takes an input parameter of product id and returns the name and price of the product, you can use this DML statement:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CALL get_product_info(1);\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To explain the execution plan of a query that selects all the products with price greater than 500, you can use this DML statement:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"EXPLAIN SELECT * FROM products WHERE price > 500;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To lock the products table in exclusive mode to prevent other transactions from modifying it until the current transaction ends, you can use this DML statement:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"LOCK TABLE products IN EXCLUSIVE MODE;\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"TRUNCATE TABLE vs. DELETE vs. DROP TABLE")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Command"),(0,r.kt)("th",{parentName:"tr",align:null},"Effect on data"),(0,r.kt)("th",{parentName:"tr",align:null},"Effect on structure"),(0,r.kt)("th",{parentName:"tr",align:null},"Effect on auto-increment"),(0,r.kt)("th",{parentName:"tr",align:null},"Effect on references"),(0,r.kt)("th",{parentName:"tr",align:null},"Speed"),(0,r.kt)("th",{parentName:"tr",align:null},"Rollback"),(0,r.kt)("th",{parentName:"tr",align:null},"WHERE clause"),(0,r.kt)("th",{parentName:"tr",align:null},"Privilege required"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TRUNCATE TABLE"),(0,r.kt)("td",{parentName:"tr",align:null},"Removes all rows"),(0,r.kt)("td",{parentName:"tr",align:null},"Keeps the structure (DDL)"),(0,r.kt)("td",{parentName:"tr",align:null},"Resets to initial value"),(0,r.kt)("td",{parentName:"tr",align:null},"Keeps the references"),(0,r.kt)("td",{parentName:"tr",align:null},"Fast"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"DROP")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DELETE"),(0,r.kt)("td",{parentName:"tr",align:null},"Removes some or all rows"),(0,r.kt)("td",{parentName:"tr",align:null},"Keeps the structure (DML)"),(0,r.kt)("td",{parentName:"tr",align:null},"Does not reset"),(0,r.kt)("td",{parentName:"tr",align:null},"Keeps the references"),(0,r.kt)("td",{parentName:"tr",align:null},"Slow"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"DELETE")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DROP TABLE"),(0,r.kt)("td",{parentName:"tr",align:null},"Removes all rows"),(0,r.kt)("td",{parentName:"tr",align:null},"Removes the structure (DDL)"),(0,r.kt)("td",{parentName:"tr",align:null},"Removes the column"),(0,r.kt)("td",{parentName:"tr",align:null},"Removes the references"),(0,r.kt)("td",{parentName:"tr",align:null},"Fast"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"DROP")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"TRUNCATE TABLE products;\nDELETE FROM products WHERE price < 10;\nDROP TABLE products;\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Where vs Having")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Clause"),(0,r.kt)("th",{parentName:"tr",align:null},"Purpose"),(0,r.kt)("th",{parentName:"tr",align:null},"Usage"),(0,r.kt)("th",{parentName:"tr",align:null},"Scope"),(0,r.kt)("th",{parentName:"tr",align:null},"Aggregation"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"WHERE"),(0,r.kt)("td",{parentName:"tr",align:null},"Filters rows before grouping"),(0,r.kt)("td",{parentName:"tr",align:null},"Can be used with any SQL statement involving tables"),(0,r.kt)("td",{parentName:"tr",align:null},"Can use any column or expression in the table"),(0,r.kt)("td",{parentName:"tr",align:null},"Cannot use aggregation functions")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"HAVING"),(0,r.kt)("td",{parentName:"tr",align:null},"Filters groups after grouping"),(0,r.kt)("td",{parentName:"tr",align:null},"Can only be used with ",(0,r.kt)("inlineCode",{parentName:"td"},"SELECT")," statement involving aggregation functions"),(0,r.kt)("td",{parentName:"tr",align:null},"Can only use columns or expressions that are in the ",(0,r.kt)("inlineCode",{parentName:"td"},"GROUP BY")," clause or in an aggregation function"),(0,r.kt)("td",{parentName:"tr",align:null},"Can use aggregation functions")))),(0,r.kt)("p",null,"WHERE and HAVING are two clauses that can be used to filter data in SQL queries. They have some similarities and differences that you should be aware of. Here are some of the main points to remember:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"WHERE clause is used to filter rows before they are grouped by the GROUP BY clause. HAVING clause is used to filter groups after they are aggregated by the GROUP BY clause."),(0,r.kt)("li",{parentName:"ul"},"WHERE clause can be used with any SQL statement that involves tables, such as SELECT, INSERT, UPDATE, or DELETE. HAVING clause can only be used with SELECT statement that involves aggregation functions, such as SUM, COUNT, AVG, etc."),(0,r.kt)("li",{parentName:"ul"},"WHERE clause can use any column or expression in the table. HAVING clause can only use columns or expressions that are either in the GROUP BY clause or in an aggregation function."),(0,r.kt)("li",{parentName:"ul"},"WHERE clause cannot use aggregation functions. HAVING clause can use aggregation functions (such as ",(0,r.kt)("inlineCode",{parentName:"li"},"count"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"average"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"min"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"max"),", or ",(0,r.kt)("inlineCode",{parentName:"li"},"sum"),").")),(0,r.kt)("p",null,"Here are some examples of how to use WHERE and HAVING clauses in SQL:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To select the names and prices of products that have a price lower than 100, you can use a WHERE clause:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT name, price FROM products WHERE price < 100;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To select the categories and average prices of products that have an average price higher than 200, you can use a GROUP BY and a HAVING clause:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT category, AVG(price) AS avg_price FROM products GROUP BY category HAVING AVG(price) > 200;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To select the names and prices of products that have a price lower than 100 and belong to a category that has an average price higher than 200, you can use a subquery with a WHERE and a HAVING clause:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT name, price FROM products\nWHERE price < 100 AND category IN (\n  SELECT category FROM products GROUP BY category HAVING AVG(price) > 200\n);\n"))))}T.isMDXComponent=!0;const R={toc:[]},L="wrapper";function O(e){let{components:t,...a}=e;return(0,r.kt)(L,(0,n.Z)({},R,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Variables")),(0,r.kt)("p",null,"Variables are names that represent values stored in memory. Variables can have different data types, such as numeric, character, boolean, date/time, array, composite, etc. Variables can be declared in the declaration section of a block using the following syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"name [ CONSTANT ] type [ COLLATE collation_name ] [ NOT NULL ] [ { DEFAULT | := | = } expression ];\n")),(0,r.kt)("p",null,"Some examples of variable declarations are:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"user_id integer; -- declare an integer variable\nquantity numeric (5); -- declare a numeric variable with precision 5\nurl varchar; -- declare a variable-length character variable\nmyrow tablename%ROWTYPE; -- declare a variable of the same type as a table row\nmyfield tablename.columnname%TYPE; -- declare a variable of the same type as a table column\narow RECORD; -- declare a record variable that can hold any row type\n")),(0,r.kt)("p",null,"Variables can be assigned values using the assignment operator (:=) or the equal sign (=). For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"user_id := 123; -- assign 123 to user_id\nquantity = quantity + 1; -- increment quantity by 1\nurl := 'https://www.postgresql.org/'; -- assign a string to url\n")),(0,r.kt)("p",null,"Variables can be used in expressions, conditions, queries, etc. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"IF user_id > 0 THEN -- check if user_id is positive\n  RAISE NOTICE 'User ID: %', user_id; -- display user_id\nEND IF;\n\nSELECT * FROM products WHERE price > quantity; -- use quantity variable in a query\n\narow := ROW(1, 'foo', true); -- assign a row value to a record variable\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Basic Control Structures")),(0,r.kt)("p",null,"PostgreSQL supports various types of control structures that you can use to write complex logic in stored procedures. Control structures are blocks of code that can alter the flow of execution based on some conditions or loops."),(0,r.kt)("p",null,"The main types of control structures in PostgreSQL are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"IF"),": This allows you to execute a block of code only if a certain condition is true. You can also use ELSE or ELSIF clauses to handle alternative cases. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"IF amount > 1000 THEN\n  RAISE NOTICE 'The amount is large: %', amount;\nELSIF amount < 0 THEN\n  RAISE EXCEPTION 'The amount cannot be negative';\nELSE\n  RAISE NOTICE 'The amount is normal: %', amount;\nEND IF;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"CASE"),": This allows you to execute different blocks of code based on the value of an expression. You can use WHEN clauses to specify the possible values and the corresponding actions. You can also use ELSE clause to handle the default case. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CASE grade\n  WHEN 'A' THEN\n    RAISE NOTICE 'Excellent!';\n  WHEN 'B' THEN\n    RAISE NOTICE 'Good!';\n  WHEN 'C' THEN\n    RAISE NOTICE 'Fair!';\n  WHEN 'D' THEN\n    RAISE NOTICE 'Poor!';\n  ELSE\n    RAISE NOTICE 'Invalid grade';\nEND CASE;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"LOOP"),": This allows you to repeat a block of code until a certain condition is met. You can use different types of loops, such as WHILE, FOR, and FOREACH, to iterate over different kinds of data. You can also use EXIT or CONTINUE statements to control the loop execution. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- loop from 1 to 10 and print odd numbers\nFOR i IN 1..10 LOOP\n  IF i % 2 = 0 THEN -- if i is even\n    CONTINUE; -- skip the current iteration\n  END IF;\n  RAISE NOTICE 'Odd number: %', i;\nEND LOOP;\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Cursor")),(0,r.kt)("p",null,"A cursor in PostgreSQL is a ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"special type of variable"))," that allows you to encapsulate a query and process its result set one row at a time. Cursors are useful when you want to divide a large result set into smaller chunks and process each chunk individually, or when you want to return a reference to a cursor from a function and let the caller fetch the rows."),(0,r.kt)("p",null,"To use a cursor in PostgreSQL, you need to follow these steps:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Declare a cursor variable of type REFCURSOR, or use the cursor declaration syntax to bind a query to a cursor variable."),(0,r.kt)("li",{parentName:"ul"},"Open the cursor using the OPEN statement, and optionally pass some parameters to the query if it is parameterized."),(0,r.kt)("li",{parentName:"ul"},"Fetch rows from the cursor using the FETCH statement, and assign them to variables or records for processing. You can also use a loop to fetch all rows from the cursor until no more rows are available."),(0,r.kt)("li",{parentName:"ul"},"Close the cursor using the CLOSE statement when you are done with it.")),(0,r.kt)("p",null,"Here are some examples of how to use cursors in PostgreSQL:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To declare an unbound cursor variable that can be used with any query, you can use this syntax:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE my_cursor REFCURSOR;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To declare a bound cursor variable that is associated with a specific query, you can use this syntax:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE my_cursor CURSOR FOR SELECT * FROM products;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To declare a bound cursor variable that is associated with a parameterized query, you can use this syntax:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE my_cursor CURSOR (p_price NUMERIC) FOR SELECT * FROM products WHERE price > p_price;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To open an unbound cursor variable and associate it with a query, you can use this syntax:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"OPEN my_cursor FOR SELECT * FROM products WHERE price > 100;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To open a bound cursor variable and optionally pass some parameters to the query, you can use this syntax:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"OPEN my_cursor; -- for non-parameterized query\nOPEN my_cursor (200); -- for parameterized query with p_price = 200\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To fetch one row from the cursor and assign it to variables, you can use this syntax:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"FETCH my_cursor INTO name, price;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To fetch all rows from the cursor and process them in a loop, you can use this syntax:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"LOOP\n  FETCH my_cursor INTO name, price;\n  EXIT WHEN NOT FOUND; -- exit loop when no more rows\n  -- do something with name and price\nEND LOOP;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To close the cursor when you are done with it, you can use this syntax:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CLOSE my_cursor;\n"))))}O.isMDXComponent=!0;const A={toc:[]},w="wrapper";function v(e){let{components:t,...l}=e;return(0,r.kt)(w,(0,n.Z)({},A,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Multiple Tables Manipulation")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"JOIN is used to add additional tables to a query for the purpose of adding selection criteria and possibly ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"additional columns")),". JOIN requires a join condition that specifies how the tables are related to each other. There are different types of joins, such as ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"inner join, left join, right join, full join")),", etc., that determine which rows from each table are included in the result set. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT p.name, p.price, c.name AS category\nFROM products p\nJOIN categories c ON p.category_id = c.id;\n")),(0,r.kt)("p",null,"This query joins the products and categories tables using the category_id column and returns the name, price, and category name of each product."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"UNION is used to combine the results of two or more queries into a single result set that ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"includes all the rows"))," that belong to all queries in the union. UNION requires that the queries have the same number and type of columns, and it eliminates any duplicate rows from the result set. There is also a variant called ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},(0,r.kt)("inlineCode",{parentName:"em"},"UNION ALL")," that does not remove duplicates")),". For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT name, price FROM products\nUNION\nSELECT name, price FROM services;\n")),(0,r.kt)("p",null,"This query combines the name and price columns from the products and services tables and returns a single result set with no duplicates."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Subqueries: A subquery is a query that is nested inside another query, such as a SELECT, INSERT, UPDATE, or DELETE statement. A subquery can return a single value, a row, a column, or a table that can be used in the outer query. Subqueries can be used to filter, aggregate, or join data from multiple tables. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT name, price FROM products\nWHERE category_id = (SELECT id FROM categories WHERE name = 'Books');\n")),(0,r.kt)("p",null,"This query uses a subquery to select the products that belong to the category with the name 'Books'."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Common Table Expressions (CTEs): A CTE is a temporary named result set that can be referenced within another SQL statement. A CTE can be used to simplify complex queries, perform recursive queries, or join data from multiple tables. A CTE is defined using the WITH clause before the main query. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"WITH books AS (\n  SELECT * FROM products WHERE category_id = 2\n)\nSELECT b.name, b.price, c.name AS category FROM books b\nJOIN categories c ON b.category_id = c.id;\n")),(0,r.kt)("p",null,"This query uses a CTE named books to select the products that belong to the category with the id 2, and then joins them with the categories table."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Set Operations: Set operations are used to combine the results of two or more queries into a single result set based on set theory. The queries must have the same number and type of columns. The set operations are:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"INTERSECT: returns the rows that are common to both queries."),(0,r.kt)("li",{parentName:"ul"},"EXCEPT: returns the rows that are in the first query but not in the second query."),(0,r.kt)("li",{parentName:"ul"},"UNION: returns all the rows from both queries, eliminating duplicates."),(0,r.kt)("li",{parentName:"ul"},"UNION ALL: returns all the rows from both queries, including duplicates.")))),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT name FROM products WHERE price > 100\nINTERSECT\nSELECT name FROM products WHERE category_id = 1;\n")),(0,r.kt)("p",null,"This query uses the INTERSECT operation to select the names of the products that have a price greater than 100 and belong to the category with the id 1.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"JOIN vs UNION")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Operation"),(0,r.kt)("th",{parentName:"tr",align:null},"Purpose"),(0,r.kt)("th",{parentName:"tr",align:null},"Syntax"),(0,r.kt)("th",{parentName:"tr",align:null},"Effect"),(0,r.kt)("th",{parentName:"tr",align:null},"Requirements"),(0,r.kt)("th",{parentName:"tr",align:null},"Performance"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"JOIN"),(0,r.kt)("td",{parentName:"tr",align:null},"To add additional tables to a query based on a join condition"),(0,r.kt)("td",{parentName:"tr",align:null},"SELECT ... FROM table1 JOIN table2 ON condition"),(0,r.kt)("td",{parentName:"tr",align:null},"Combines data into new columns based on the join condition"),(0,r.kt)("td",{parentName:"tr",align:null},"The tables must have a common column or expression to join on"),(0,r.kt)("td",{parentName:"tr",align:null},"Usually faster than UNION because it does not require sorting and duplicate elimination")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UNION"),(0,r.kt)("td",{parentName:"tr",align:null},"To combine the results of two or more queries into a single result set"),(0,r.kt)("td",{parentName:"tr",align:null},"SELECT ... FROM table1 UNION SELECT ... FROM table2"),(0,r.kt)("td",{parentName:"tr",align:null},"Combines data into new rows and eliminates duplicates"),(0,r.kt)("td",{parentName:"tr",align:null},"The queries must have the same number and type of columns"),(0,r.kt)("td",{parentName:"tr",align:null},"Usually slower than JOIN because it requires sorting and duplicate elimination")))),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"JOINvsUNION",src:a(31249).Z,width:"3079",height:"1049"}))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Where vs Inner join")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Clause"),(0,r.kt)("th",{parentName:"tr",align:null},"Purpose"),(0,r.kt)("th",{parentName:"tr",align:null},"Syntax"),(0,r.kt)("th",{parentName:"tr",align:null},"Condition"),(0,r.kt)("th",{parentName:"tr",align:null},"Usage"),(0,r.kt)("th",{parentName:"tr",align:null},"Scope"),(0,r.kt)("th",{parentName:"tr",align:null},"Performance"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"WHERE"),(0,r.kt)("td",{parentName:"tr",align:null},"Filters rows based on a condition that can involve any column or expression in the tables"),(0,r.kt)("td",{parentName:"tr",align:null},"SELECT ... FROM table1, table2 WHERE condition"),(0,r.kt)("td",{parentName:"tr",align:null},"Can use any operator or function that returns a boolean value"),(0,r.kt)("td",{parentName:"tr",align:null},"Can be used with any SQL statement that involves tables"),(0,r.kt)("td",{parentName:"tr",align:null},"Filters data after joining the tables"),(0,r.kt)("td",{parentName:"tr",align:null},"Depends on various factors, such as the size of the tables, the indexes available, the filter condition used, etc.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"INNER JOIN"),(0,r.kt)("td",{parentName:"tr",align:null},"Filters rows based on a condition that involves only the columns that are joined by the clause"),(0,r.kt)("td",{parentName:"tr",align:null},"SELECT ... FROM table1 INNER JOIN table2 ON condition"),(0,r.kt)("td",{parentName:"tr",align:null},"Can only use the equality operator ",(0,r.kt)("inlineCode",{parentName:"td"},"(=)")," to compare the joining columns"),(0,r.kt)("td",{parentName:"tr",align:null},"Can only be used with SELECT statement that involves two or more tables"),(0,r.kt)("td",{parentName:"tr",align:null},"Filters data while joining the tables"),(0,r.kt)("td",{parentName:"tr",align:null},"Depends on various factors, such as the size of the tables, the indexes available, the join condition used, etc.")))),(0,r.kt)("p",null,"WHERE and INNER JOIN are two different ways to filter data in SQL queries. They have some similarities and differences that you should be aware of. Here are some of the main points to remember:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"WHERE clause is used to filter rows based on a ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"condition that can involve any column or expression"))," in the tables. INNER JOIN clause is used to filter rows based on a ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"condition that involves only the columns that are joined by the clause")),"."),(0,r.kt)("li",{parentName:"ul"},"WHERE clause can be used with ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"any SQL statement that involves tables")),", such as SELECT, INSERT, UPDATE, or DELETE. INNER JOIN clause can only be used with ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"SELECT statement that involves two or more tables")),"."),(0,r.kt)("li",{parentName:"ul"},"WHERE clause can use any operator or function that returns a boolean value, such as ",(0,r.kt)("inlineCode",{parentName:"li"},"=, <>, >, <, BETWEEN, LIKE, IN, IS NULL"),", etc. INNER JOIN clause can only use the equality operator ",(0,r.kt)("inlineCode",{parentName:"li"},"(=)")," to compare the joining columns."),(0,r.kt)("li",{parentName:"ul"},"WHERE clause can be combined with other clauses such as GROUP BY, HAVING, ORDER BY, LIMIT, etc. INNER JOIN clause can be combined with other types of joins, such as LEFT JOIN, RIGHT JOIN, FULL JOIN, CROSS JOIN, etc.")),(0,r.kt)("p",null,"Here are some examples of how to use WHERE and INNER JOIN clauses in SQL:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To select the names and prices of products that have a price lower than 100, you can use a WHERE clause:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT name, price FROM products WHERE price < 100;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To select the names and prices of products and their categories that have a matching category_id, you can use an INNER JOIN clause:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT p.name, p.price, c.name AS category FROM products p\nINNER JOIN categories c ON p.category_id = c.id;\n")),(0,r.kt)("p",null,"The difference lies in how the data is filtered. In simple terms, WHERE clause filters data after joining the tables. INNER JOIN clause filters data while joining the tables. However, this may not always be true depending on the query optimizer and the execution plan."),(0,r.kt)("p",null,"The performance of WHERE and INNER JOIN clauses depends on various factors, such as the size of the tables, the indexes available, the join or filter condition used, etc. In general, there is no significant difference between them if they produce the same result set. However, this may not always be true depending on the specific situation and query optimization.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Types of JOIN")),(0,r.kt)("p",null,"A join is a SQL operation that allows you to combine data from two or more tables based on a common column or expression. PostgreSQL supports various types of joins, each with its own syntax and effect. Here is a list of all join commands in PostgreSQL:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"PostgreSQL-Joins.png",src:a(7681).Z,width:"872",height:"528"})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"INNER JOIN: returns the rows that match in both tables based on the join condition. Syntax:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT ... FROM table1 INNER JOIN table2 ON condition;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"LEFT JOIN: returns all rows from the left table and the matching rows from the right table, or NULL if there is no match. Syntax:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT ... FROM table1 LEFT JOIN table2 ON condition;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"RIGHT JOIN: returns all rows from the right table and the matching rows from the left table, or NULL if there is no match. Syntax:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT ... FROM table1 RIGHT JOIN table2 ON condition;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"FULL JOIN: returns all rows from both tables, and matches them if possible, or NULL if there is no match. Syntax:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT ... FROM table1 FULL JOIN table2 ON condition;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"CROSS JOIN: returns the Cartesian product of the rows from both tables, i.e., every combination of rows. Syntax:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT ... FROM table1 CROSS JOIN table2;\n")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"cross-join",src:a(53500).Z,width:"704",height:"543"})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"NATURAL JOIN: returns the rows that have equal values in the common columns of both tables. The common columns are determined by the column names. Syntax:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT ... FROM table1 NATURAL JOIN table2;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"SELF JOIN: returns the rows that match between two instances of the same table. Syntax:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT ... FROM table1 t1 JOIN table1 t2 ON condition;\n"))))}v.isMDXComponent=!0;const I={sidebar_position:3,id:"postgresql-from-zero-to-hero",sidebar_label:"PostgresQL From Zero To Hero",title:"PostgresQL From Zero To Hero"},C="PostgresQL From Zero To Hero",S={unversionedId:"postgresql/postgresql-from-zero-to-hero",id:"postgresql/postgresql-from-zero-to-hero",title:"PostgresQL From Zero To Hero",description:"DML vs DDL",source:"@site/docs/postgresql/1.intro.md",sourceDirName:"postgresql",slug:"/postgresql/postgresql-from-zero-to-hero",permalink:"/devviews/interviews/postgresql/postgresql-from-zero-to-hero",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/postgresql/1.intro.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,id:"postgresql-from-zero-to-hero",sidebar_label:"PostgresQL From Zero To Hero",title:"PostgresQL From Zero To Hero"},sidebar:"postgresInterviewSidebar"},P={},D=[{value:"DML vs DDL",id:"dml-vs-ddl",level:3},{value:"Variables",id:"variables",level:3},{value:"Multiple Tables",id:"multiple-tables",level:3},{value:"Programmable Objects",id:"programmable-objects",level:3},{value:"Multiple Operations",id:"multiple-operations",level:3},{value:"Index",id:"index",level:3},{value:"Replication",id:"replication",level:3},{value:"Sharding",id:"sharding",level:3}],q={toc:D},x="wrapper";function U(e){let{components:t,...a}=e;return(0,r.kt)(x,(0,n.Z)({},q,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"postgresql-from-zero-to-hero"},"PostgresQL From Zero To Hero"),(0,r.kt)("h3",{id:"dml-vs-ddl"},"DML vs DDL"),(0,r.kt)(T,{mdxType:"DMLvsDDL"}),(0,r.kt)("h3",{id:"variables"},"Variables"),(0,r.kt)(O,{mdxType:"Variables"}),(0,r.kt)("h3",{id:"multiple-tables"},"Multiple Tables"),(0,r.kt)(v,{mdxType:"MultipleTables"}),(0,r.kt)("h3",{id:"programmable-objects"},"Programmable Objects"),(0,r.kt)(k,{mdxType:"ProgrammableObjects"}),(0,r.kt)("h3",{id:"multiple-operations"},"Multiple Operations"),(0,r.kt)(f,{mdxType:"MultipleOperations"}),(0,r.kt)("h3",{id:"index"},"Index"),(0,r.kt)(c,{mdxType:"Index"}),(0,r.kt)("h3",{id:"replication"},"Replication"),(0,r.kt)(s,{mdxType:"Replication"}),(0,r.kt)("h3",{id:"sharding"},"Sharding"),(0,r.kt)(p,{mdxType:"Sharding"}))}U.isMDXComponent=!0},31249:function(e,t,a){t.Z=a.p+"assets/images/JOINvsUNION-aa9615744ece97b4118adbebe992c8f2.png"},7681:function(e,t,a){t.Z=a.p+"assets/images/PostgreSQL-Joins-1096dd06b96bf22799b5c88e3c177368.png"},11383:function(e,t,a){t.Z=a.p+"assets/images/clustered-and-non-clustered-index_thumbnail-f23893f686eb3b350aad2bc3fce8d08a.webp"},53500:function(e,t,a){t.Z=a.p+"assets/images/cross-join-64354a197fce5626811c30919f490913.png"}}]);