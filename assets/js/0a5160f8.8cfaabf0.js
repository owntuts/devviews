"use strict";(self.webpackChunkinterviewdev=self.webpackChunkinterviewdev||[]).push([[7383],{3905:function(e,t,a){a.d(t,{Zo:function(){return d},kt:function(){return h}});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),m=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},d=function(e){var t=m(e.components);return n.createElement(l.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),p=m(a),u=r,h=p["".concat(l,".").concat(u)]||p[u]||c[u]||s;return a?n.createElement(h,o(o({ref:t},d),{},{components:a})):n.createElement(h,o({ref:t},d))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,o=new Array(s);o[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[p]="string"==typeof e?e:r,o[1]=i;for(var m=2;m<s;m++)o[m]=a[m];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},54312:function(e,t,a){a.d(t,{ZP:function(){return i}});var n=a(83117),r=(a(67294),a(3905));const s={toc:[]},o="wrapper";function i(e){let{components:t,...a}=e;return(0,r.kt)(o,(0,n.Z)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("div",{className:"interview"},a.level&&(0,r.kt)("span",{className:"level"},a.level),a.children))}i.isMDXComponent=!0},768:function(e,t,a){a.r(t),a.d(t,{assets:function(){return h},contentTitle:function(){return c},default:function(){return b},frontMatter:function(){return p},metadata:function(){return u},toc:function(){return y}});var n=a(83117),r=(a(67294),a(3905));a(54312);const s={toc:[]},o="wrapper";function i(e){let{components:t,...a}=e;return(0,r.kt)(o,(0,n.Z)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Database Types")),(0,r.kt)("p",null,"There are many types of databases available, some of which include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Relational databases (RDBMS)")," - These databases store data in tables with predefined relationships between them. Examples include MySQL, Oracle, and PostgreSQL.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"NoSQL databases")," - These databases do not use the traditional table structure and are designed to handle unstructured data. Examples include MongoDB, Cassandra, and Couchbase.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Object-oriented databases")," - These databases are designed to handle complex data types and relationships using object-oriented programming concepts. Examples include db4o and ObjectDB.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Key-value (KV) databases")," - These databases store data in key-value pairs and are primarily used for quick lookups. Examples include Redis, Riak, and Memcached.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Graph databases")," - These databases store data in nodes and edges, making them useful for complex and connected data. Examples include Neo4j, AllegroGraph, and OrientDB.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Columnar databases")," - These databases store data in columns rather than rows, which can be more efficient for certain types of data analysis. Examples include Apache Cassandra, HBase, and Vertica.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Cloud databases")," - These databases are delivered through cloud computing platforms and are designed to handle massive amounts of data storage and processing. Examples include Amazon Web Services (AWS) DynamoDB, Google Bigtable, and Microsoft Azure SQL Database.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Time-series databases")," - These databases are designed to handle large volumes of time-stamped data, making them ideal for IoT devices and sensor data. Examples include InfluxDB, TimescaleDB, and OpenTSDB."))),(0,r.kt)("p",null,"These are just a few examples of the many types of databases available. Each has its own strengths and weaknesses, and the choice of database type typically depends on the specific needs and requirements of the application or project at hand.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"SQL vs NoSQL")),(0,r.kt)("p",null,"SQL and NoSQL are two broad categories of databases that differ in many aspects. Here are some of the main differences between SQL versus NoSQL databases:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Aspect"),(0,r.kt)("th",{parentName:"tr",align:null},"SQL"),(0,r.kt)("th",{parentName:"tr",align:null},"NoSQL"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Structure"),(0,r.kt)("td",{parentName:"tr",align:null},"Table based (have a fixed schema - predefined columns and types)"),(0,r.kt)("td",{parentName:"tr",align:null},"Document, key-value, graph, or column based")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Scalability"),(0,r.kt)("td",{parentName:"tr",align:null},"Vertical"),(0,r.kt)("td",{parentName:"tr",align:null},"Horizontal")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Relationships"),(0,r.kt)("td",{parentName:"tr",align:null},"Foreign keys"),(0,r.kt)("td",{parentName:"tr",align:null},"Embedded or referenced data")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Language"),(0,r.kt)("td",{parentName:"tr",align:null},"SQL"),(0,r.kt)("td",{parentName:"tr",align:null},"Various query languages or APIs")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Use Cases"),(0,r.kt)("td",{parentName:"tr",align:null},"Complex queries, transactions, consistency, reliability"),(0,r.kt)("td",{parentName:"tr",align:null},"Fast performance, scalability, flexibility, unstructured or semi-structured data")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Use Cases Ex"),(0,r.kt)("td",{parentName:"tr",align:null},"used for online transaction processing, data warehousing, business intelligence, and analytics"),(0,r.kt)("td",{parentName:"tr",align:null},"used for web applications, social media platforms, real-time processing, and big data analyticsa")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"NoSQL (Not only SQL)")," databases do not rely on SQL as the main query language (Some NoSQL databases support a subset or a variation of SQL)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Scale vertically"),", meaning that they can handle more load by adding more resources to a single server."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Scale horizontally"),", meaning that they can handle more load by adding more servers to a cluster."))))}i.isMDXComponent=!0;const l={toc:[{value:"Some examples of distributed systems that follow the CAP theorem are:",id:"some-examples-of-distributed-systems-that-follow-the-cap-theorem-are",level:4},{value:"More Details",id:"more-details",level:4}]},m="wrapper";function d(e){let{components:t,...s}=e;return(0,r.kt)(m,(0,n.Z)({},l,s,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Trade-off Theorems")),(0,r.kt)("p",null,"Here are some common trade-off theorems in database design:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The CAP Theorem"),": This theorem states that it is impossible for a ",(0,r.kt)("strong",{parentName:"p"},"distributed computer system")," to simultaneously provide all three guarantees of consistency, availabilty , and partition tolerance. Database designers must therefore make trade-offs between these three attributes.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The ACID Properties Theorem"),": This theorem states that ",(0,r.kt)("strong",{parentName:"p"},"transactions")," in a database must satisfy four properties: Atomicity, Consistency, Isolation, and Durability. While these properties ensure data integrity, they can come at the cost of performance and scalability.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The Normalization vs"),". Performance Trade-Off: Normalization is used in database design to eliminate data redundancy and improve data consistency. However, normalized databases can result in complex queries and lower performance. Database designers must therefore make trade-offs between normalization and performance.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The Denormalization Trade-Off"),": Denormalization involves adding redundant data to a database to improve performance. However, this can result in data inconsistencies and higher storage requirements. Database designers must therefore trade-off between denormalization and data consistency.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The Indexing Trade-Off"),": Indexing improves query performance, but it comes at the cost of increased storage and slower write times. Database designers must therefore make trade-offs between query speed and write performance.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The Sharding Trade-Off"),": Sharding is used to distribute data across multiple nodes to improve scalability, but it comes at the cost of increased complexity and higher latency due to network communication. Database designers must therefore trade-off between scalability and complexity.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The Security vs. Performance Trade-Off"),": The addition of security measures such as encryption can negatively impact database performance. However, insufficient security measures can result in data breaches and compromise data integrity. Database designers must therefore make trade-offs between security and performance."))),(0,r.kt)("p",null,"These are just a few examples of trade-off theorems in database design. Understanding these trade-offs is important in making informed decisions about database design and in optimizing database performance and scalability without compromising data integrity.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"ACID")),(0,r.kt)("p",null,"The ACID properties theorem is a set of principles that ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"ensure the reliability and correctness of database transactions")),". ACID stands for Atomicity, Consistency, Isolation, and Durability. These properties are explained below:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Atomicity")," means that a transaction is ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"either completed in full or not"))," executed at all. This ensures that the database is not left in an inconsistent state due to partial updates or failures. For example, if you transfer money from one account to another, either both accounts are updated or none of them are. In SQL, you can use the ",(0,r.kt)("inlineCode",{parentName:"li"},"BEGIN TRANSACTION"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"COMMIT"),", and ",(0,r.kt)("inlineCode",{parentName:"li"},"ROLLBACK")," statements to control the atomicity of a transaction. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- Start a transaction\nBEGIN TRANSACTION;\n\n-- Transfer 100 from account A to account B\nUPDATE Accounts SET balance = balance - 100 WHERE id = 'A';\nUPDATE Accounts SET balance = balance + 100 WHERE id = 'B';\n\n-- Check if any error occurred\nIF @@ERROR <> 0\n    -- Rollback the transaction if there is an error\n    ROLLBACK;\nELSE\n    -- Commit the transaction if there is no error\n    COMMIT;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Consistency")," means that a transaction preserves the ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"integrity and validity of the data according to the defined rules and constraints")),". This ensures that the database is always in a consistent state before and after the transaction. For example, if you have a rule that the balance of an account cannot be negative, a transaction that violates this rule will not be allowed. In SQL, you can use the ",(0,r.kt)("inlineCode",{parentName:"li"},"CHECK")," constraint to enforce consistency rules on the data. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- Create a table with a CHECK constraint\nCREATE TABLE Accounts (\n    id VARCHAR(10) PRIMARY KEY,\n    balance INT CHECK (balance >= 0) -- Balance cannot be negative\n);\n\n-- Insert some valid data\nINSERT INTO Accounts VALUES ('A', 500);\nINSERT INTO Accounts VALUES ('B', 300);\n\n-- Try to insert some invalid data\nINSERT INTO Accounts VALUES ('C', -100); -- This will fail\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Isolation")," means that a ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"transaction is executed independently"))," from other concurrent transactions and does not interfere with them. This ensures that the database is not affected by the intermediate states of other transactions. For example, if two transactions are reading and writing to the same data, ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"they will not see each other's changes until they are committed")),". In SQL, you can use the ",(0,r.kt)("inlineCode",{parentName:"li"},"SET TRANSACTION ISOLATION LEVEL")," statement to specify how isolated a transaction is from other transactions. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- Set the isolation level to serializable\nSET TRANSACTION ISOLATION LEVEL SERIALIZABLE;\n\n-- Start a transaction\nBEGIN TRANSACTION;\n\n-- Read some data\nSELECT * FROM Accounts WHERE id = 'A';\n\n-- Update some data\nUPDATE Accounts SET balance = balance + 50 WHERE id = 'A';\n\n-- Commit the transaction\nCOMMIT;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Durability")," means that a transaction's changes are ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"permanent and persistent even in the event of system failures or crashes")),". This ensures that the database does not lose any data due to power outages, errors, or other mishaps. For example, if you update your profile information, it will not be lost even if your computer shuts down unexpectedly. In SQL, durability is ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"achieved by writing the changes to disk or other non-volatile storage devices after committing the transaction")),". The database system also ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"maintains a log of all transactions"))," and their states, so that it can recover from any failures by replaying or undoing the transactions."))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"CAP")),(0,r.kt)("p",null,"The CAP theorem is a concept that describes the trade-offs between three properties of distributed systems: Consistency, Availability, and Partition tolerance. It states that it is ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"impossible for a distributed system to guarantee all three properties at the same time")),", and that only two of them can be achieved simultaneously."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Consistency")," means that ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"all nodes in the system see the same data at the same time")),", no matter which node they connect to. "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Availability")," means that ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"every request to the system receives a response")),", even if one or more nodes are down. "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Partition")," tolerance means that the ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"system can continue to operate even if some nodes are isolated by network failures")),".")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"When a network partition occurs, the system has to choose between consistency or availability")),". If it chooses consistency, it will return an error or a timeout if some data cannot be guaranteed to be up-to-date. If it chooses availability, it will return a response with possibly stale data."),(0,r.kt)("h4",{id:"some-examples-of-distributed-systems-that-follow-the-cap-theorem-are"},"Some examples of distributed systems that follow the CAP theorem are:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"CAP",src:a(10962).Z,width:"964",height:"457"})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"CP systems"),": These systems prioritize consistency and partition tolerance over availability. They ensure that all nodes have the same data, but they may become unavailable during network partitions. Examples of CP systems are MongoDB, HBase, Redis, and ZooKeeper."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"AP systems"),": These systems prioritize availability and partition tolerance over consistency. They ensure that all nodes are always reachable, but they may return outdated data. Examples of AP systems are Cassandra, CouchDB, DynamoDB, and Riak."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"CA systems"),": These systems prioritize consistency and availability over partition tolerance. They ensure that all nodes have the same data and are always reachable, but they cannot handle network partitions. Examples of CA systems are MySQL, PostgreSQL, Oracle, and SQL Server.")),(0,r.kt)("h4",{id:"more-details"},"More Details"),(0,r.kt)("p",null,"When something happens => DB system decide what to do"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"MySQL"),": MySQL can be CP or CA depending on the configurations. By default, it is CA because it follows a master slave paradigm which data is replicated to the slaves."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"CA: To make sure C and A => must have enough live nodes to serve all the data => but if not, cluster will shutdown => not P."),(0,r.kt)("li",{parentName:"ul"},"CP: network fails => slaves loses the connection to the master => decides to elect a new master => system becomes unavailable."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"MongoDB"),": Respect to CP over A so it's CP:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Primary node goes down: system becomes unavailable while a new primary is selected."),(0,r.kt)("li",{parentName:"ul"},"Primary node is disconnected from too many Secondary nodes: system becomes unavailable. Other secondaries likely elect a new Primary while the primary steps down."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Cassandra"),": is a good example of an AP system. If a network partition occurs, Cassandra will ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"continue to operate even if some of the nodes in the system are partitioned from the rest")),". However, this also means that there may be times when the data in Cassandra is not consistent, some clients may see the new record, while others may not.")))))}d.isMDXComponent=!0;const p={sidebar_position:3,id:"database",sidebar_label:"Database",title:"Database"},c="Database",u={unversionedId:"system-design/database",id:"system-design/database",title:"Database",description:"Database Types",source:"@site/docs/system-design/20.database.md",sourceDirName:"system-design",slug:"/system-design/database",permalink:"/devviews/interviews/system-design/database",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/system-design/20.database.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,id:"database",sidebar_label:"Database",title:"Database"},sidebar:"designSystemInterviewSidebar",previous:{title:"Design Patterns",permalink:"/devviews/interviews/system-design/design-patterns"},next:{title:"System Design Principles",permalink:"/devviews/interviews/system-design/system-design-principles"}},h={},y=[{value:"Database Types",id:"database-types",level:3},{value:"Trade-off Theorems",id:"trade-off-theorems",level:3}],f={toc:y},k="wrapper";function b(e){let{components:t,...a}=e;return(0,r.kt)(k,(0,n.Z)({},f,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"database"},"Database"),(0,r.kt)("h3",{id:"database-types"},"Database Types"),(0,r.kt)(i,{mdxType:"DatabaseTypes"}),(0,r.kt)("h3",{id:"trade-off-theorems"},"Trade-off Theorems"),(0,r.kt)(d,{mdxType:"TradeoffTheorems"}))}b.isMDXComponent=!0},10962:function(e,t,a){t.Z=a.p+"assets/images/CAP-3569efede0332cdb8edb7059cb5ba9d9.png"}}]);