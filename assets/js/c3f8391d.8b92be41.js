"use strict";(self.webpackChunkinterviewdev=self.webpackChunkinterviewdev||[]).push([[8505],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),c=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(i.Provider,{value:t},e.children)},p="mdxType",b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,i=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),m=r,h=p["".concat(i,".").concat(m)]||p[m]||b[m]||s;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=m;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l[p]="string"==typeof e?e:r,o[1]=l;for(var c=2;c<s;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},21362:function(e,t,n){n.r(t),n.d(t,{assets:function(){return h},contentTitle:function(){return b},default:function(){return g},frontMatter:function(){return p},metadata:function(){return m},toc:function(){return d}});var a=n(83117),r=(n(67294),n(3905));const s={toc:[{value:"To summarize:",id:"to-summarize",level:4},{value:"Example",id:"example",level:4}]},o="wrapper";function l(e){let{components:t,...n}=e;return(0,r.kt)(o,(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Observer, Observable, subject, Subscriber")),(0,r.kt)("p",null,"Imagine you are a ",(0,r.kt)("strong",{parentName:"p"},"Subscriber")," to a newspaper. The newspaper is an ",(0,r.kt)("strong",{parentName:"p"},"Observable"),", which produces news articles every day. You are also an ",(0,r.kt)("strong",{parentName:"p"},"Observer"),", which means you can read the articles and react to them. You can also unsubscribe from the newspaper if you don't want to receive it anymore."),(0,r.kt)("p",null,"Now imagine there is a ",(0,r.kt)("strong",{parentName:"p"},"Subject")," that acts like a news aggregator. It can subscribe to multiple newspapers (Observables) and collect their articles. It can also publish its own articles based on the aggregated news. You can subscribe to the Subject and receive all the articles from the newspapers and the Subject itself. You are still an Observer, but now you have more sources of information. The Subject is also an Observer, because it can react to the articles from the newspapers. The Subject is also an Observable, because it can produce its own articles."),(0,r.kt)("h4",{id:"to-summarize"},"To summarize:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"An ",(0,r.kt)("strong",{parentName:"li"},"Observable")," is like a newspaper that produces values over time."),(0,r.kt)("li",{parentName:"ul"},"An ",(0,r.kt)("strong",{parentName:"li"},"Observer")," is like a reader that consumes values and reacts to them."),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("strong",{parentName:"li"},"Subject")," is like a news aggregator that can consume values from multiple Observables and produce its own values."),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("strong",{parentName:"li"},"Subscriber")," is like a subscription that connects an Observer to an Observable.")),(0,r.kt)("h4",{id:"example"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Import RxJS library\nconst Rx = require('rxjs');\n\n// Create two Observables that produce news articles\nconst newspaper1 = Rx.Observable.of('Article 1 from newspaper 1', 'Article 2 from newspaper 1', 'Article 3 from newspaper 1');\nconst newspaper2 = Rx.Observable.of('Article 1 from newspaper 2', 'Article 2 from newspaper 2', 'Article 3 from newspaper 2');\n\n// Create a Subject that acts as a news aggregator\nconst subject = new Rx.Subject();\n\n// Subscribe the Subject to the two Observables\nnewspaper1.subscribe(subject);\nnewspaper2.subscribe(subject);\n\n// Publish an article from the Subject itself\nsubject.next('Article from subject');\n\n// Create an Observer that acts as a reader\nconst reader = {\n  next: article => console.log('Reader received: ' + article),\n  error: err => console.error('Reader got an error: ' + err),\n  complete: () => console.log('Reader got a complete notification')\n};\n\n// Create a Subscriber that connects the Observer to the Subject\nconst subscriber = subject.subscribe(reader);\n\n// Output:\n// Reader received: Article 1 from newspaper 1\n// Reader received: Article 1 from newspaper 2\n// Reader received: Article 2 from newspaper 1\n// Reader received: Article 2 from newspaper 2\n// Reader received: Article 3 from newspaper 1\n// Reader received: Article 3 from newspaper 2\n// Reader received: Article from subject\n\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"RxJS Observables vs Promises")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Promises are like a delivery truck"),". You order something online, and the delivery truck shows up at your door with your order. The delivery truck only comes once, and it only delivers one thing."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Observables are like a stream of water"),". You turn on the faucet, and water starts flowing out. The water keeps flowing until you turn off the faucet. You can collect the water in a bucket, or you can use it to water your plants.")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Observables"),(0,r.kt)("th",{parentName:"tr",align:null},"Promises"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"A stream of events that can be processed with operators"),(0,r.kt)("td",{parentName:"tr",align:null},"A single event that happens when an async operation completes or fails")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Can be either synchronous or asynchronous"),(0,r.kt)("td",{parentName:"tr",align:null},"Always asynchronous")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Can provide zero or more values"),(0,r.kt)("td",{parentName:"tr",align:null},"Can provide a single value because they can only be resolved or rejected once")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Only start when subscribed to"),(0,r.kt)("td",{parentName:"tr",align:null},"Start immediately when created")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Can be cancelled by unsubscribing"),(0,r.kt)("td",{parentName:"tr",align:null},"Cannot be cancelled"))))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Subject vs BehaviorSubject")),(0,r.kt)("p",null,"An event ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"stream of birthdays"))," is a ",(0,r.kt)("inlineCode",{parentName:"p"},"Subject"),", because it does not have an initial value and does not emit anything until a birthday occurs. "),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"stream of a person's age (current value)"))," would be a ",(0,r.kt)("inlineCode",{parentName:"p"},"BehaviorSubject"),", because it always has an initial value (the person's age) and emits the current value to new subscribers."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// Create a Subject that represents an event stream of birthdays\nbirthday$ = new Subject<Date>();\n\n// Subscribe to the birthday stream and log the dates\nbirthday$.subscribe(date => console.log(date));\n\n// Output: nothing\n\n// A birthday occurs\nbirthday$.next(new Date(2023, 5, 8));\n\n// Output: 2023-06-08\n\n// Another birthday occurs\nbirthday$.next(new Date(2024, 5, 8));\n\n// Output: 2024-06-08\n\n// Create a BehaviorSubject that represents the stream of a person's age\nage$ = new BehaviorSubject<number>(25);\n\n// Subscribe to the age stream and log the numbers\nage$.subscribe(age => console.log(age));\n\n// Output: 25\n\n// The person's age changes\nage$.next(26);\n\n// Output: 26\n\n// The person's age changes again\nage$.next(27);\n\n// Output: 27\n")),(0,r.kt)("p",null,"You can see that the Subject does not emit anything until ",(0,r.kt)("inlineCode",{parentName:"p"},"next()")," is called, and then emits the value to the subscriber. The BehaviorSubject emits the initial value to the subscriber, and then emits the updated value when ",(0,r.kt)("inlineCode",{parentName:"p"},"next()")," is called.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"ReplaySubject")),(0,r.kt)("p",null,"A ",(0,r.kt)("strong",{parentName:"p"},"ReplaySubject")," is a type of ",(0,r.kt)("strong",{parentName:"p"},"Subject")," that ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"replays old values to new subscribers when they first subscribe")),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"ReplaySubject")," will store every value it emits in a buffer and emit them to the new subscribers in the order it received them. You can configure the buffer using the arguments ",(0,r.kt)("inlineCode",{parentName:"p"},"bufferSize")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"windowTime"),"."),(0,r.kt)("p",null,"For example, let's say you have a service that keeps track of the user's actions. You can use a ReplaySubject to store the last 5 actions and emit them to any component that subscribes to it. You can also update the actions by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"next()")," on the ReplaySubject."),(0,r.kt)("p",null,"Here is some pseudocode to illustrate this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'// Create a ReplaySubject with a buffer size of 5\nactions$ = new ReplaySubject<string>(5);\n\n// Emit some actions\nactions$.next("click");\nactions$.next("scroll");\nactions$.next("hover");\nactions$.next("drag");\nactions$.next("drop");\n\n// Subscribe to the actions and log them\nactions$.subscribe(action => console.log(action));\n\n// Output: click, scroll, hover, drag, drop\n\n// Emit another action\nactions$.next("zoom");\n\n// Subscribe to the actions and log them\nactions$.subscribe(action => console.log(action));\n\n// Output: scroll, hover, drag, drop, zoom\n')),(0,r.kt)("p",null,"You can see that the ReplaySubject emits all the values in the buffer to the first subscriber, and then emits only the last 5 values to the second subscriber.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"AsyncSubject")),(0,r.kt)("p",null,"An ",(0,r.kt)("strong",{parentName:"p"},"AsyncSubject")," is a type of ",(0,r.kt)("strong",{parentName:"p"},"Subject")," that only emits the last value of the observable execution and only when the execution completes. It is ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"useful when you only want the final result"))," of an asynchronous operation."),(0,r.kt)("p",null,"For example, let's say you have a service that performs a calculation. You can use an AsyncSubject to store the result of the calculation and emit it to any component that subscribes to it when the calculation is done. You can also update the result by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"next()")," on the AsyncSubject."),(0,r.kt)("p",null,"Here is some pseudocode to illustrate this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// Create an AsyncSubject\nresult$ = new AsyncSubject<number>();\n\n// Subscribe to the result and log it\nresult$.subscribe(result => console.log(result));\n\n// Output: nothing\n\n// Update the result\nresult$.next(10);\n\n// Output: nothing\n\n// Update the result again\nresult$.next(20);\n\n// Output: nothing\n\n// Complete the calculation\nresult$.complete();\n\n// Output: 20\n")),(0,r.kt)("p",null,"You can see that the AsyncSubject does not emit anything until ",(0,r.kt)("inlineCode",{parentName:"p"},"complete()")," is called, and then emits only the last value to the subscriber.")))}l.isMDXComponent=!0;const i={toc:[{value:"Here is an example of a cold observable in RxJS:",id:"here-is-an-example-of-a-cold-observable-in-rxjs",level:4},{value:"Here is an example of a hot observable in RxJS:",id:"here-is-an-example-of-a-hot-observable-in-rxjs",level:4}]},c="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},i,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Cold vs Hot Observables in RxJS")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Cold observables"),(0,r.kt)("th",{parentName:"tr",align:null},"Hot observables"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Create a new data producer for each subscriber"),(0,r.kt)("td",{parentName:"tr",align:null},"Share the same data producer among multiple subscribers")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Data producer is created inside the observable"),(0,r.kt)("td",{parentName:"tr",align:null},"Data producer is created outside the observable")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Start to emit values only when someone subscribes"),(0,r.kt)("td",{parentName:"tr",align:null},"Emit values regardless of subscriptions")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Unicast: each subscriber gets its own stream of data"),(0,r.kt)("td",{parentName:"tr",align:null},"Multicast: each subscriber gets the same stream of data")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Examples: HTTP requests, timers"),(0,r.kt)("td",{parentName:"tr",align:null},"Examples: mouse clicks, keyboard events")))),(0,r.kt)("p",null,"To illustrate the difference, imagine a ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"cold observable as a YouTube video"))," and a ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"hot observable as a live stream")),". When you watch a YouTube video, you can start, pause, rewind or fast-forward it at your own pace. You have your own copy of the video. When you watch a live stream, you can only see what is happening at the moment. You share the same stream with other viewers."),(0,r.kt)("p",null,"There are operators in RxJS that can ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"convert cold observables into hot observables")),", such as ",(0,r.kt)("inlineCode",{parentName:"p"},"publish()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"share()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"shareReplay()")," and others. These operators use ",(0,r.kt)("strong",{parentName:"p"},"subjects")," under the hood, which are special types of observables that can act as both observers and observables. Subjects can multicast values to multiple subscribers by relaying them from a source observable."),(0,r.kt)("h4",{id:"here-is-an-example-of-a-cold-observable-in-rxjs"},"Here is an example of a cold observable in RxJS:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// A cold observable that emits a random number when subscribed\nconst cold$ = new rxjs.Observable(subscriber => {\n  subscriber.next(Math.random());\n  subscriber.complete();\n});\n\n// Two subscribers will get different values\ncold$.subscribe(value => console.log('Subscriber A:', value));\ncold$.subscribe(value => console.log('Subscriber B:', value));\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Subscriber A: 0.123456789\nSubscriber B: 0.987654321\n")),(0,r.kt)("h4",{id:"here-is-an-example-of-a-hot-observable-in-rxjs"},"Here is an example of a hot observable in RxJS:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// A hot observable that emits mouse clicks\nconst hot$ = rxjs.fromEvent(document, 'click');\n\n// Two subscribers will get the same values\nhot$.subscribe(event => console.log('Subscriber A:', event.clientX, event.clientY));\nhot$.subscribe(event => console.log('Subscriber B:', event.clientX, event.clientY));\n")),(0,r.kt)("p",null,"Output (after clicking on the document):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Subscriber A: 100 200\nSubscriber B: 100 200\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Multicasting in RxJS")),(0,r.kt)("p",null,"An observable is ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"unicast"))," by default, which means each observer has its own instance of the data producer and receives a unique set of values. "),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Multicasting")," in RxJS is the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"process of sharing a single subscription to an Observable with multiple subscribers")),". This can be useful for scenarios where you want to ensure that all subscribers receive the same data, such as when you are ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"broadcasting a live event or streaming data from a server")),"."),(0,r.kt)("p",null,"There are two main ways to multicast in RxJS:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Using a Subject:")," A Subject is an Observable that can emit values and also subscribe to other Observables. This makes it a natural choice for multicasting, as it can act as a central hub for data distribution."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const subject = new Subject(); // create a subject\n\n// subscribe two observers to the subject\nsubject.subscribe(val => console.log(`Observer 1: ${val}`));\nsubject.subscribe(val => console.log(`Observer 2: ${val}`));\n\n// emit values to the observers using next\nsubject.next('Hello');\nsubject.next('World');\n\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Using ConnectableObservable:")," "),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A ",(0,r.kt)("strong",{parentName:"p"},"ConnectableObservable")," is a type of ",(0,r.kt)("strong",{parentName:"p"},"hot observable")," so that it can have multiple subscribers sharing the same subscription")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"It ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"can be connected and disconnected"))," from its source by calling the ",(0,r.kt)("strong",{parentName:"p"},"connect")," and ",(0,r.kt)("strong",{parentName:"p"},"disconnect")," methods. ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A ",(0,r.kt)("strong",{parentName:"p"},"ConnectableObservable")," ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"does not start emitting values until it is connected")),". "),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// import { interval, Subject } from 'rxjs';\n// import { multicast } from 'rxjs/operators';\n\nconst source = interval(1000); // a cold observable that emits a value every second\nconst subject = new Subject(); // a subject that will multicast the values to the observers\nconst multicasted = source.pipe(multicast(subject)); // a connectable observable that uses the subject to share the subscription\n\n// subscribe to the connectable observable with two observers\nconst subscription1 = multicasted.subscribe(val => console.log(`Observer 1: ${val}`));\nconst subscription2 = multicasted.subscribe(val => console.log(`Observer 2: ${val}`));\n\n// connect the connectable observable to the source observable\nconst connection = multicasted.connect();\n\n// after 5 seconds, unsubscribe both observers and disconnect the connection\nsetTimeout(() => {\n    subscription1.unsubscribe();\n    subscription2.unsubscribe();\n    connection.unsubscribe();\n}, 5000);\n\n"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Using ConnectableObservable with refCount():")," is to simplify the process of managing the subscription to a ",(0,r.kt)("strong",{parentName:"p"},"ConnectableObservable"),"."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("strong",{parentName:"p"},"refCount")," operator ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"tracks the number of subscribers"))," to a ",(0,r.kt)("strong",{parentName:"p"},"ConnectableObservable")," ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Automatically ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"connects it when the first subscriber subscribes and disconnects it when the last subscriber unsubscribes")),"."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// import { interval, Subject } from 'rxjs';\n// import { multicast, refCount } from 'rxjs/operators';\n\nconst source = interval(1000); // a cold observable that emits a value every second\nconst multicasted = source.pipe(share()); // a hot observable that shares the subscription to the source\n// * Equivalent to share() operator\n// const subject = new Subject();\n// const multicasted = source.pipe(multicast(subject), refCount());\n\n// subscribe to the multicasted observable with two observers\nconst subscription1 = multicasted.subscribe(val => console.log(`Observer 1: ${val}`));\nconst subscription2 = multicasted.subscribe(val => console.log(`Observer 2: ${val}`));\n\n// after 5 seconds, unsubscribe both observers\nsetTimeout(() => {\nsubscription1.unsubscribe();\nsubscription2.unsubscribe();\n}, 5000);\n"))))))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"connectable vs multicast operator")),(0,r.kt)("p",null,"The difference between the ",(0,r.kt)("strong",{parentName:"p"},"connectable")," function and the ",(0,r.kt)("strong",{parentName:"p"},"multicast")," operator is that the ",(0,r.kt)("strong",{parentName:"p"},"connectable")," function returns a ",(0,r.kt)("strong",{parentName:"p"},"ConnectableObservable")," directly, whereas the ",(0,r.kt)("strong",{parentName:"p"},"multicast")," operator returns an operator function that can be used with the ",(0,r.kt)("inlineCode",{parentName:"p"},"pipe")," method to create a ",(0,r.kt)("strong",{parentName:"p"},"ConnectableObservable"),". For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// import { interval } from 'rxjs';\n// import { connectable, multicast } from 'rxjs';\n\nconst source = interval(1000); // a cold observable that emits a value every second\n\n// using connectable function\nconst multicasted1 = connectable(source, () => new Subject()); // a connectable observable that uses a Subject internally to share the subscription\nconst subscription1 = multicasted1.subscribe(val => console.log(`Observer 1: ${val}`));\n\n// using multicast operator\nconst multicasted2 = source.pipe(multicast(() => new Subject())); // another connectable observable that does the same thing\n\n// using pipe method on multicasted2 observable\nconst transformed = multicasted2.pipe(\n  map(val => val * 2), // double the values\n  filter(val => val % 4 === 0) // keep only the values divisible by 4\n);\nconst subscription2 = transformed.subscribe(val => console.log(`Observer 2: ${val}`));\nconst subscription3 = multicasted2.subscribe(val => console.log(`Observer 3: ${val}`));\n\nconst connection1 = multicasted1.connect();\nconst connection2 = multicasted2.connect();\n\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Alternative for publish operator")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"publish")," operator")," is deprecated in RxJS 7 and will be removed in RxJS 8. The publish operator ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"converts a cold observable into a ",(0,r.kt)("inlineCode",{parentName:"em"},"ConnectableObservable"))),". To replace the ",(0,r.kt)("inlineCode",{parentName:"p"},"publish")," operator, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"connectable")," function or the ",(0,r.kt)("inlineCode",{parentName:"p"},"share")," operator instead."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// use connectable\nconst multicasted = connectable(source, () => new Subject());\n// or share operator which is a shortcut for using the publish and refCount operators together\nconst multicasted = source.pipe(share());\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The ",(0,r.kt)("inlineCode",{parentName:"strong"},"publishLast")," operator")," converts a cold observable into a ",(0,r.kt)("inlineCode",{parentName:"p"},"ConnectableObservable")," that emits only the last value emitted by the source observable when it completes."),(0,r.kt)("p",{parentName:"li"}," Example of replacing ",(0,r.kt)("inlineCode",{parentName:"p"},"publishLast")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// a connectable observable that uses an AsyncSubject internally to emit only the last value\nconst multicasted = connectable(source, () => new AsyncSubject());\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The ",(0,r.kt)("inlineCode",{parentName:"strong"},"publishReplay")," operator")," converts a cold observable into a ConnectableObservable that emits the values emitted by the source observable within a specified window or buffer size when it is connected."),(0,r.kt)("p",{parentName:"li"},"  Example of replacing ",(0,r.kt)("inlineCode",{parentName:"p"},"publishReplay")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// a connectable observable that uses a ReplaySubject internally to emit the last two values\nconst multicasted = connectable(source, () => new ReplaySubject(2)); \n\n// or a hot observable that shares the subscription to the source and emits the last two values\nconst multicasted = source.pipe(share({ connector: () => new ReplaySubject(2), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false }));\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The ",(0,r.kt)("inlineCode",{parentName:"strong"},"publishBehavior")," operator")," converts a cold observable into a ConnectableObservable that ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"emits the initial value"))," specified by the operator and then the values emitted by the source observable when it is connected."),(0,r.kt)("p",{parentName:"li"},"  Example of replacing ",(0,r.kt)("inlineCode",{parentName:"p"},"publishBehavior")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// A connectable observable that uses a BehaviorSubject internally to emit 0 and then the values from the source\nconst multicasted = connectable(source, () => new BehaviorSubject(0)); \n\n// Or a hot observable that shares the subscription to the source and emits 0 and then the values from the source\nconst multicasted = source.pipe(share({ connector: () => new BehaviorSubject(0), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false })); \n"))))))}u.isMDXComponent=!0;const p={sidebar_position:3,id:"rxjs-from-zero-to-hero",sidebar_label:"Rxjs From Zero To Hero",title:"Rxjs From Zero To Hero"},b="Rxjs From Zero To Hero",m={unversionedId:"js/angular-interviews/rxjs-from-zero-to-hero",id:"js/angular-interviews/rxjs-from-zero-to-hero",title:"Rxjs From Zero To Hero",description:"\x3c!--",source:"@site/docs/js/angular-interviews/10.rxjs.md",sourceDirName:"js/angular-interviews",slug:"/js/angular-interviews/rxjs-from-zero-to-hero",permalink:"/devviews/interviews/js/angular-interviews/rxjs-from-zero-to-hero",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/js/angular-interviews/10.rxjs.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,id:"rxjs-from-zero-to-hero",sidebar_label:"Rxjs From Zero To Hero",title:"Rxjs From Zero To Hero"},sidebar:"jsInterviewSidebar",previous:{title:"Angular Zero To Hero",permalink:"/devviews/interviews/js/angular-interviews/angular-zero-hero"},next:{title:"App instance and Vuejs component",permalink:"/devviews/interviews/relationship-vuejs-app-instance-vuejs-component"}},h={},d=[{value:"Observable vs Observer",id:"observable-vs-observer",level:3},{value:"Multicasting",id:"multicasting",level:3}],v={toc:d},k="wrapper";function g(e){let{components:t,...n}=e;return(0,r.kt)(k,(0,a.Z)({},v,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"rxjs-from-zero-to-hero"},"Rxjs From Zero To Hero"),(0,r.kt)("h2",{id:""}),(0,r.kt)("h3",{id:"observable-vs-observer"},"Observable vs Observer"),(0,r.kt)(l,{mdxType:"ObservablevsObserver"}),(0,r.kt)("h3",{id:"multicasting"},"Multicasting"),(0,r.kt)(u,{mdxType:"Multicast"}))}g.isMDXComponent=!0}}]);