"use strict";(self.webpackChunkinterviewdev=self.webpackChunkinterviewdev||[]).push([[36],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return g}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=l(n),d=a,g=p["".concat(c,".").concat(d)]||p[d]||m[d]||i;return n?r.createElement(g,o(o({ref:t},u),{},{components:n})):r.createElement(g,o({ref:t},u))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[p]="string"==typeof e?e:a,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9414:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return o},default:function(){return m},frontMatter:function(){return i},metadata:function(){return s},toc:function(){return l}});var r=n(3117),a=(n(7294),n(3905));const i={sidebar_position:1e3,sidebar_label:"Incremental Static Regeneration",title:"What is Incremental Static Regeneration(ISR)?",slug:"/incremental-static-regeneration",tags:["NextJS Interviews"]},o=void 0,s={unversionedId:"js/nextjs/basic/ISR",id:"js/nextjs/basic/ISR",title:"What is Incremental Static Regeneration(ISR)?",description:"\\*\u0ca0_\u0ca0\\* :",source:"@site/docs/js/nextjs/basic/ISR.md",sourceDirName:"js/nextjs/basic",slug:"/incremental-static-regeneration",permalink:"/devviews/interviews/incremental-static-regeneration",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/js/nextjs/basic/ISR.md",tags:[{label:"NextJS Interviews",permalink:"/devviews/interviews/tags/next-js-interviews"}],version:"current",sidebarPosition:1e3,frontMatter:{sidebar_position:1e3,sidebar_label:"Incremental Static Regeneration",title:"What is Incremental Static Regeneration(ISR)?",slug:"/incremental-static-regeneration",tags:["NextJS Interviews"]},sidebar:"jsInterviewSidebar",previous:{title:"Vuejs Interviews",permalink:"/devviews/interviews/vuejs-interview-questions-answers"},next:{title:"API Route",permalink:"/devviews/interviews/api-route-vs-normal-route-nexts"}},c={},l=[],u={toc:l},p="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("admonition",{title:"Question:",type:"quest"},(0,a.kt)("p",{parentName:"admonition"},"*",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"\u0ca0_\u0ca0")),"*"," :\nWhat is Incremental Static Regeneration(ISR) in NextJS?")),(0,a.kt)("details",null,(0,a.kt)("summary",null,(0,a.kt)("h5",null,"ANSWER:")),(0,a.kt)("p",null,"  ","*",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"\u25d4\u032f\u25d4")),"*"," :\nAs you well know NextJS allows you to generate static site. But How if you want to update your site based content data changes? If your site has milion pages, you need to re-build entire site -> It's intimidating, right?!. So, NextJS provides you with a feature called ",(0,a.kt)("strong",{parentName:"p"},"Incremental Static Regeneration (ISR)")," that enables you to use static-generation ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"on a per-page basis")),", ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"without needing to rebuild the entire site")),"."),(0,a.kt)("p",null," ",(0,a.kt)("strong",{parentName:"p"},"Incremental Static Regeneration (ISR)")," can be enable by using ",(0,a.kt)("inlineCode",{parentName:"p"},"revalidate")," property."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"export default function Blog({ post }) {\n  // render posts\n}\n\nexport async function getStaticProps() {\n // contact API to get posts\n // const post = await APIcall\n return {\n   props: { \n     posts: \n   },\n   revalidate: 10, // Every 10 seconds, Try to re-generate the page when a request comes in\n }\n}\n\n"))))}m.isMDXComponent=!0}}]);