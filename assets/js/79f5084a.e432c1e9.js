"use strict";(self.webpackChunkinterviewdev=self.webpackChunkinterviewdev||[]).push([[2701],{3905:function(e,n,t){t.d(n,{Zo:function(){return s},kt:function(){return g}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=a.createContext({}),m=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},s=function(e){var n=m(e.components);return a.createElement(p.Provider,{value:n},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),d=m(t),u=r,g=d["".concat(p,".").concat(u)]||d[u]||c[u]||o;return t?a.createElement(g,i(i({ref:n},s),{},{components:t})):a.createElement(g,i({ref:n},s))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=u;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l[d]="string"==typeof e?e:r,i[1]=l;for(var m=2;m<o;m++)i[m]=t[m];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},4660:function(e,n,t){t.r(n),t.d(n,{assets:function(){return P},contentTitle:function(){return R},default:function(){return V},frontMatter:function(){return j},metadata:function(){return O},toc:function(){return F}});var a=t(3117),r=(t(7294),t(3905));const o={toc:[{value:"Steps to create app with Standalone components",id:"steps-to-create-app-with-standalone-components",level:4},{value:"1. Bootstrapping an application using a standalone component",id:"1-bootstrapping-an-application-using-a-standalone-component",level:4},{value:"2. Routing &amp; Lazy loading many routes",id:"2-routing--lazy-loading-many-routes",level:4}]},i="wrapper";function l(e){let{components:n,...t}=e;return(0,r.kt)(i,(0,a.Z)({},o,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Standalone Component")),(0,r.kt)("p",null,"A standalone component in Angular is a component that is not part of any Angular module. This means that it can be used without being imported into a module. Standalone components are useful for creating reusable components that can be used in multiple applications."),(0,r.kt)("h4",{id:"steps-to-create-app-with-standalone-components"},"Steps to create app with Standalone components"),(0,r.kt)("h4",{id:"1-bootstrapping-an-application-using-a-standalone-component"},"1. Bootstrapping an application using a standalone component"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import {LibraryModule} from 'ngmodule-based-library';\n\nbootstrapApplication(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    importProvidersFrom(\n      LibraryModule.forRoot()\n    ),\n    provideRouter([/* app routes */]),\n    // ...\n  ]\n  ]\n});\n")),(0,r.kt)("h4",{id:"2-routing--lazy-loading-many-routes"},"2. Routing & Lazy loading many routes"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"// Main application:\nexport const ROUTES: Route[] = {\n  // Lazy-load the admin routes.\n  {path: 'admin', loadChildren: () => import('./admin/routes').then(mod => mod.ADMIN_ROUTES)},\n  // ... rest of the routes\n}\n\n// In admin/routes.ts:\nexport const ADMIN_ROUTES: Route[] = [{\n  path: '',\n  pathMatch: 'prefix',\n  providers: [\n    AdminService,\n    {provide: ADMIN_API_KEY, useValue: 12345},\n  ],\n  children: [\n    {path: 'users', component: AdminUsersCmp},\n    {path: 'teams', component: AdminTeamsCmp},\n  ],\n}];\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Types of providers")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@NgModule.providers")," (in applications bootstrapping through an NgModule);"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'@Injectable({provideIn: "..."})'),"(in both the NgModule-based and the \u201cstandalone\u201d applications);"),(0,r.kt)("li",{parentName:"ul"},"providers option in the bootstrapApplication call (in fully \u201cstandalone\u201d applications);")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"bootstrapApplication(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    {provide: PhotosService, useClass: PhotosService},\n    // ...\n  ]\n});\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"providers field in a Route configuration like above.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Environment injectors")," are used to provide services to components and directives outside of the component tree. This can be useful for providing services to services, directives, and components that are not defined in an Angular module."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import { createEnvironmentInjector, ENVIRONMENT_INITIALIZER } from '@angular/core';\n\nconst environmentInjector = createEnvironmentInjector([\n  { provide: 'MyService', useClass: MyService },\n  { provide: ENVIRONMENT_INITIALIZER, useValue: () => {\n    console.log('This function runs when this EnvironmentInjector gets created');\n  }}\n]);\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import { Component, OnInit } from '@angular/core';\nimport { MyService } from './my.service';\n\n@Component({\n  selector: 'my-component',\n  templateUrl: './my-component.component.html',\n  styleUrls: ['./my-component.component.css']\n})\nexport class MyComponent implements OnInit {\n\n  constructor(private injector: Injector) {}\n\n  ngOnInit() {\n    const myService = this.injector.get(MyService);\n  }\n\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Standalone injectors"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"@Component({\n        selector: 'date-modal',\n        template: '<datepicker></datepicker>',\n        standalone: true,\n        imports: [DatePickerModule]\n})\nclass DateModalComponent {\n}\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Resolve circular dependencies")),(0,r.kt)("p",null,"Circular problem happens when class 'A' refers to class 'B' and 'B' refers to 'A'. One of them has to be defined first. To solve this problem, we use ",(0,r.kt)("inlineCode",{parentName:"p"},"forwardRef"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"@Component({\n  standalone: true, \n  imports: [ChildComponent],\n  selector: 'app-parent',\n  template: `<app-child [hideParent]=\"hideParent\"></app-child>`,\n})\nexport class ParentComponent {\n  @Input() hideParent: boolean;\n}\n\n\n@Component({\n  standalone: true,\n  imports: [CommonModule, forwardRef(() => ParentComponent)],\n  selector: 'app-child',\n  template: `<app-parent *ngIf=\"!hideParent\"></app-parent>`,\n})\nexport class ChildComponent {\n  @Input() hideParent: boolean;\n}\n"))))}l.isMDXComponent=!0;const p={toc:[]},m="wrapper";function s(e){let{components:n,...t}=e;return(0,r.kt)(m,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Typed Forms")),(0,r.kt)("p",null,"Typed Forms are a new feature in Angular 14 that ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"}," provide type safety to your Angular forms")),". This can help you avoid errors and make your code easier to read and maintain."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Component } from '@angular/core';\nimport { FormArray, FormBuilder, FormControl, FormGroup } from '@angular/forms';\n\ninterface FormModel {\n  title: FormControl<string | null>;\n  name: FormGroup<{\n    firstName: FormControl<string | null>;\n    lastName: FormControl<string | null>;\n  }>;\n  interest: FormArray<FormControl<string | null>>;\n}\n\n@Component({\n  selector: 'my-app',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css'],\n})\nexport class AppComponent {\n  form = this.fb.group<FormModel>({\n    title: this.fb.control('This is title'),\n    name: this.fb.group({\n      firstName: this.fb.control('Will'),\n      lastName: this.fb.control('Huang'),\n    }),\n    interest: this.fb.array([\n      this.fb.control('HTML'),\n      this.fb.control('Angular'),\n    ]),\n  });\n\n  constructor(private fb: FormBuilder) {}\n}\n\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"FormRecord - Dynamic Form")),(0,r.kt)("p",null,"Some FormGroup usages do not fit the above pattern (",(0,r.kt)("inlineCode",{parentName:"p"},"FormModel"),") because ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"the keys are not known ahead of time")),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"FormRecord")," class is designed for that case. ",(0,r.kt)("inlineCode",{parentName:"p"},"FormRecord")," is a class from the ",(0,r.kt)("inlineCode",{parentName:"p"},"@angular/forms")," module that ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"extends the ",(0,r.kt)("inlineCode",{parentName:"em"},"FormGroup")))," class and allows you to create a form group with dynamic keys and type-safe controls."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"export class AppComponent implements OnInit {\n\n  public myForm: FormRecord;\n  public formKeys = ['Andrew', 'Barry']\n\n  ngOnInit(): void {\n    this.myForm = new FormRecord<FormControl<string|null>>({});\n    this.formKeys.forEach((key, i) => \n      this.myForm.addControl(key, new FormControl(`${(i + 1) * 100} Default-Value St.`))\n    );\n\n  }\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'<div>\n  <form [formGroup]="myForm">\n    <div *ngFor="let key of formKeys">\n      <b>{{key}}: </b><input  [formControlName]="key"><br/>\n    </div>\n  </form>\n</div>\n<div>\n<br/>\n<div *ngFor="let key of formKeys">\n  <div>{{key}}: {{myForm.get(key).value}}</div>\n</div>\n</div>\n'))))}s.isMDXComponent=!0;const d={toc:[]},c="wrapper";function u(e){let{components:n,...t}=e;return(0,r.kt)(c,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Angular Signals")),(0,r.kt)("p",null,"Angular Signals are a new feature in Angular 16 that provides ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"a way to notify interested consumers when a value changes")),". Signals can be used to improve the performance of Angular applications by ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"reducing the number of change detection runs")),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { Component, OnInit } from '@angular/core';\nimport { Signal } from '@angular/common';\n\n@Component({\n  selector: 'my-app',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit {\n\n  constructor(private signal: Signal<string>) {}\n\n  ngOnInit() {\n    this.signal.subscribe((value) => {\n      console.log(value);\n    });\n\n    this.signal.value = 'Hello, world!';\n  }\n\n}\n\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Types of of signals")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Writable signal:")),(0,r.kt)("p",null,"Writable signals are ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"signals that can be changed"))," by consumers. When a writable signal is changed, all of its consumers will be notified of the change."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { Signal } from '@angular/common';\n\nconst mySignal = new Signal<string>();\n\nmySignal.value = 'Hello, world!';\n\nmySignal.subscribe((value) => {\n  console.log(value);\n});\n")),(0,r.kt)("p",null,"In this example, we create a writable signal called ",(0,r.kt)("inlineCode",{parentName:"p"},"mySignal")," and set its initial value to ",(0,r.kt)("inlineCode",{parentName:"p"},"'Hello, world!'"),". We then subscribe to the signal and print the value of the signal to the console when it changes."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Computed signal:")),(0,r.kt)("p",null,"Computed signals are signals that ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"are derived from other signals")),". When one of the signals that a computed signal is derived from changes, the computed signal will be automatically updated."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { Signal } from '@angular/common';\n\nconst mySignal1 = new Signal<string>();\nconst mySignal2 = new Signal<string>();\n\nconst myComputedSignal = computed(() => {\n  return mySignal1.value + mySignal2.value;\n});\n\nmySignal1.value = 'Hello';\nmySignal2.value = 'World!';\n\nconsole.log(myComputedSignal.value); // HelloWorld!\n")),(0,r.kt)("p",null,"In this example, we create two writable signals called ",(0,r.kt)("inlineCode",{parentName:"p"},"mySignal1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"mySignal2"),". We then create a computed signal called ",(0,r.kt)("inlineCode",{parentName:"p"},"myComputedSignal")," that is derived from the values of ",(0,r.kt)("inlineCode",{parentName:"p"},"mySignal1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"mySignal2"),". When the values of ",(0,r.kt)("inlineCode",{parentName:"p"},"mySignal1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"mySignal2")," change, the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"myComputedSignal")," will be automatically updated.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Effect")),"**Example of an effect:**",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Effect, Effects } from '@ngrx/effects';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MyEffect {\n\n  constructor(private http: HttpClient, private effects: Effects) {}\n\n  @Effect({\n    dispatch: ['fetchData']\n  })\n  fetchData() {\n    this.effects.run(() => {\n      this.http.get('https://example.com').subscribe((data) => {\n        console.log(data);\n      });\n    });\n  }\n\n}\n")),(0,r.kt)("p",null,"In this example, we create an effect called ",(0,r.kt)("inlineCode",{parentName:"p"},"MyEffect")," that uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"HttpClient")," service to make an HTTP request to ",(0,r.kt)("inlineCode",{parentName:"p"},"https://example.com"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"fetchData()")," method of ",(0,r.kt)("inlineCode",{parentName:"p"},"MyEffect")," is called when the effect is dispatched."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example of using an effect in a component:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { Component } from '@angular/core';\nimport { MyEffect } from './my-effect';\n\n@Component({\n  selector: 'my-app',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n\n  constructor(private myEffect: MyEffect) {}\n\n  ngOnInit() {\n    this.myEffect.fetchData();\n  }\n\n}\n")),(0,r.kt)("p",null,"In this example, we create a component called ",(0,r.kt)("inlineCode",{parentName:"p"},"AppComponent")," that uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"MyEffect")," effect to make an HTTP request to ",(0,r.kt)("inlineCode",{parentName:"p"},"https://example.com"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"ngOnInit()")," method of ",(0,r.kt)("inlineCode",{parentName:"p"},"AppComponent")," will call the ",(0,r.kt)("inlineCode",{parentName:"p"},"fetchData()")," method of ",(0,r.kt)("inlineCode",{parentName:"p"},"MyEffect")," when the component is initialized.")))}u.isMDXComponent=!0;const g={toc:[]},k="wrapper";function h(e){let{components:n,...t}=e;return(0,r.kt)(k,(0,a.Z)({},g,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Angular Dynamic Component")),(0,r.kt)("p",null,"Angular Dynamic Component is a feature that allows you to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"load components dynamically at runtime")),". It can be useful for creating complex and conditional views, or for loading components from external sources."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import {\n  Component,\n  ViewContainerRef,\n  ComponentFactoryResolver,\n  ViewChild,\n} from '@angular/core';\n\n@Component({\n  selector: 'my-app',\n  template: `\n    <div>\n      {{ name }}\n      <ng-container #ref></ng-container>\n    </div>\n  `\n})\nexport class AppComponent {\n  name = 'Angular';\n\n  @ViewChild('ref', { read: ViewContainerRef, static: true }) ref: ViewContainerRef;\n\n  constructor(\n    private resolver: ComponentFactoryResolver\n  ) {}\n\n  ngOnInit() {\n    import('./created/created.component').then((mod) => {\n      const component = mod.CreatedComponent;\n      const cmpFactory = this.resolver.resolveComponentFactory(component);\n      this.ref.clear();\n      this.ref.createComponent(cmpFactory);\n    });\n  }\n}\n\n"))))}h.isMDXComponent=!0;const N={toc:[]},f="wrapper";function v(e){let{components:n,...o}=e;return(0,r.kt)(f,(0,a.Z)({},N,o,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Angular Custom Element")),(0,r.kt)("p",null,"Custom Element Transform an Angular component into a web component => It allows you to use Angular component as a nomal DOM."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"custom element",src:t(3053).Z,width:"797",height:"514"})),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// Import the necessary modules\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule, Injector } from '@angular/core';\nimport { createCustomElement } from '@angular/elements';\n\n// Define the component to be packaged as a custom element\n@Component({\n  selector: 'hello-world',\n  template: `<h1>Hello {{name}}!</h1>`\n})\nexport class HelloWorldComponent {\n  @Input() name: string;\n}\n\n// Declare the module that contains the component\n@NgModule({\n  declarations: [HelloWorldComponent],\n  imports: [BrowserModule],\n  entryComponents: [HelloWorldComponent]\n})\nexport class AppModule {\n  constructor(private injector: Injector) {}\n\n  // Register the custom element with the browser\n  ngDoBootstrap() {\n    const el = createCustomElement(HelloWorldComponent, {injector: this.injector});\n    customElements.define('hello-world', el); // `customElements.define` is a built-in function\n  }\n}\n\n")),(0,r.kt)("p",null,"Now, you can use the component in HTML as if it's a HTML element"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},"<html>\n<head>\n  <title>Using Angular Custom Element</title>\n</head>\n<body>\n  <h1>Using Angular Custom Element</h1>\n  <hello-world name=\"Angular\"></hello-world>\n  <script>\n    const hW = document.querySelector('hello-world');\n    hW.addEventListener('action', function() {\n      // ...\n    })\n  <\/script>\n</body>\n</html>\n"))))}v.isMDXComponent=!0;const y={toc:[]},C="wrapper";function b(e){let{components:n,...t}=e;return(0,r.kt)(C,(0,a.Z)({},y,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Angular Built-In Directives")),(0,r.kt)("p",null,"Angular has a number of built-in directives that can be used to change the appearance and behavior of HTML elements. These directives are divided into two categories: attribute directives and structural directives."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Attribute directives")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngClass")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngStyle")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngModel")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngForm")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngControl")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngDisabled")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngReadonly")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngChange")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngSubmit")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngInit")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngDoCheck")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngAfterViewInit")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngAfterContentInit")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngAfterContentChecked")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngAfterViewChecked"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Structural directives")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngIf")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngFor")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngSwitch")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngSwitchCase")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngSwitchDefault")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngTemplateOutlet")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngTemplateRef")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngContent")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngOutletContext")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngOutletHost")))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Angular Built-In Attribute Directives")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Directive")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Example")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"ngClass")),(0,r.kt)("td",{parentName:"tr",align:null},"Adds and removes CSS classes from an element."),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<div [ngClass]=\"{'active': isActive}\"></div>"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"ngStyle")),(0,r.kt)("td",{parentName:"tr",align:null},"Sets inline styles on an element."),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<div [ngStyle]=\"{'color': color}\"></div>"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"ngModel")),(0,r.kt)("td",{parentName:"tr",align:null},"Adds two-way data binding to an HTML form element."),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'<input type="text" [(ngModel)]="name"></input>'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"ngForm")),(0,r.kt)("td",{parentName:"tr",align:null},"Creates a form object that can be used to validate and submit form data."),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'<form [ngForm]="form"></form>'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"ngControl")),(0,r.kt)("td",{parentName:"tr",align:null},"Creates a control object that can be used to validate and submit form data."),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'<input type="text" [ngControl]="name"></input>'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"ngDisabled")),(0,r.kt)("td",{parentName:"tr",align:null},"Disables an element."),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'<button [ngDisabled]="isDisabled">Click me</button>'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"ngReadonly")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes an element read-only."),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'<input type="text" [ngReadonly]="isReadonly"></input>'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"ngChange")),(0,r.kt)("td",{parentName:"tr",align:null},"Called when the value of an input element changes."),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'<input type="text" [(ngModel)]="name" (ngChange)="onNameChange($event)"></input>'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"ngSubmit")),(0,r.kt)("td",{parentName:"tr",align:null},"Called when the user submits a form."),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'<form [ngForm]="form" (ngSubmit)="onSubmit($event)"></form>')))))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Angular Built-In Structural Directives")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"ngIf"),": Conditionally renders an element. "),(0,r.kt)("p",{parentName:"li"},"Example: ",(0,r.kt)("inlineCode",{parentName:"p"},'<div *ngIf="isVisible">This element will be rendered if isVisible is true</div>'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"ngFor"),": Repeats an element for each item in an array. Example:\n",(0,r.kt)("inlineCode",{parentName:"p"},'<div *ngFor="let item of items">This element will be repeated for each item in the items array</div>'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"ngSwitch"),": Switches between different views based on a value. Example: "),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<div [ngSwitch]="value">\n  <br>\n  <div *ngSwitchCase="\'1\'">This view will be rendered if value is 1</div>\n  <div *ngSwitchCase="\'2\'">This view will be rendered if value is 2</div>\n  <div *ngSwitchDefault>This view will be rendered if value is anything else</div>\n</div>\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"ngSwitchCase"),": Specifies a view to be rendered by the ngSwitch directive. Example: ",(0,r.kt)("inlineCode",{parentName:"p"},"<div *ngSwitchCase=\"'1'\">This view will be rendered if value is 1</div>"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"ngSwitchDefault"),": Specifies a view to be rendered by the ngSwitch directive if no other cases match. Example: ",(0,r.kt)("inlineCode",{parentName:"p"},"<div *ngSwitchDefault>This view will be rendered if value is anything else</div>"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"ngTemplateOutlet"),": Inserts the content of a template into the current view. Example:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'@Component({\n  selector: \'my-app\',\n  template: `      \n<ng-template #estimateTemplate let-lessonsCounter="estimate">\n    <div> Approximately {{lessonsCounter}} lessons ...</div>\n</ng-template>\n<ng-container \n  *ngTemplateOutlet="estimateTemplate;context:ctx">\n</ng-container>\n`})\nexport class AppComponent {\n\n    totalEstimate = 10;\n    ctx = {estimate: this.totalEstimate};\n  \n}\n')),(0,r.kt)("p",{parentName:"li"},"  or"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<div *ngTemplateOutlet=\"template; context: { item: item }; host: { 'id': 'my-id', 'style': 'color: red' }\"></div>\n")),(0,r.kt)("p",{parentName:"li"},"  This will create a div with the id my-id and the style color: red as the host element.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"ngContent"),": Inserts the content of a child element into the current view. Example: ",(0,r.kt)("inlineCode",{parentName:"p"},'<div *ngFor="let item of items"> <div [ngContent]="item"></div> </div>'))))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Standalone Directives (Directive Composition)")),(0,r.kt)("p",null,"Standalone directives are directives that ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"do not need to be declared in an NgModule"))," and do not depend on any intermediate context of an NgModule. You can use ",(0,r.kt)("inlineCode",{parentName:"p"},"hostDirectives")," to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"compose multiple behaviors on a host element"))," without duplicating them in the template."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"@Component({\n  selector: 'admin-menu',\n  template: `\n    <admin-menu id=\"top-menu\" (closed)=\"logMenuClosed()\">\n  `,\n  hostDirectives: [{\n    directive: MenuBehavior,\n    inputs: ['menuId: id'],\n    outputs: ['menuClosed: closed'],\n  }],\n})\nexport class AdminMenu { }\n")),(0,r.kt)("p",null,"Here's the directive"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { Directive, ElementRef, EventEmitter, HostListener, Input, Output } from '@angular/core';\n\n@Directive({\n  selector: '[menuBehavior]',\n  standalone: true // this is required for hostDirectives\n})\nexport class MenuBehavior {\n  @Input() menuId: string; // this will be aliased as id on the host element\n  @Output() menuClosed = new EventEmitter<void>(); // this will be aliased as closed on the host element\n\n  constructor(private elementRef: ElementRef) {}\n\n  @HostListener('click')\n  onClick() {\n    // toggle the menu visibility\n    this.elementRef.nativeElement.classList.toggle('open');\n  }\n\n  @HostListener('document:click', ['$event'])\n  onDocumentClick(event: Event) {\n    // close the menu if clicked outside\n    if (!this.elementRef.nativeElement.contains(event.target)) {\n      this.elementRef.nativeElement.classList.remove('open');\n      this.menuClosed.emit(); // emit the menuClosed event\n    }\n  }\n}\n\n"))))}b.isMDXComponent=!0;const w={toc:[]},x="wrapper";function S(e){let{components:n,...o}=e;return(0,r.kt)(x,(0,a.Z)({},w,o,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Angular Dependency Injection")),(0,r.kt)("p",null,"Angular uses dependency injection (DI) to provide components and services with their required dependencies. Dependencies are passed as parameters to the class (component, sevice) constructor. The DI framework ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"looks for a provider of the dependency in the injector hierarchy")),", starting from the component\u2019s own injector and going up to the root injector if needed. The DI framework creates and injects the dependencies based on the Inversion of Control (IoC) principle, which separates the consumers and providers of dependencies for better testing and maintenance."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Angular Dependency Injection",src:t(7802).Z,width:"1155",height:"645"}))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"@Self() vs @Optional() vs @SkipSelf() vs @Host()")),(0,r.kt)("p",null,"These are Angular decorators that modify how the dependency injection framework resolves dependencies. Here is a brief explanation and example for each:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@Self()")," tells Angular to ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"look for the dependency only in the local injector of the current component"))," or directive. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@Component({\n  selector: 'my-grandChild',\n  template: `\n    <div class=\"box\">\n      GrandChildComponent => {{ randomNo }}\n    </div>\n  `,\n  providers: [RandomService]\n})\nexport class GrandChildComponent {\n  randomNo: number;\n  constructor(@Self() private randomService: RandomService) {\n    this.randomNo = this.randomService.getRandom();\n  }\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@Optional()")," tells Angular to assign null to the dependency if it is not found. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@Component({\n  selector: 'my-grandChild',\n  template: `\n    <div class=\"box\">\n      GrandChildComponent => {{ randomNo }}\n    </div>\n  `\n})\nexport class GrandChildComponent {\n  randomNo: number;\n  constructor(@Optional() private randomService: RandomService) {\n    this.randomNo = this.randomService ? this.randomService.getRandom() : null;\n  }\n}\n")),(0,r.kt)("p",null,"In this example, if ",(0,r.kt)("inlineCode",{parentName:"p"},"RandomService")," is not provided by any injector, Angular will not throw an error but assign ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"randomService")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@SkipSelf()")," tells Angular to ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"skip the local injector of the current component"))," or directive and look for the dependency in its parent injectors. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@Component({\n  selector: 'my-grandChild',\n  template: `\n    <div class=\"box\">\n      GrandChildComponent => {{ randomNo }}\n    </div>\n  `\n})\nexport class GrandChildComponent {\n  randomNo: number;\n  constructor(@SkipSelf() private randomService: RandomService) {\n    this.randomNo = this.randomService.getRandom();\n  }\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@Host()")," tells Angular to ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"look for the dependency in the local injector of the current component or directive and its host component")),". For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@Component({\n  selector: 'my-grandChild',\n  template: `\n    <div class=\"box\">\n      GrandChildComponent => {{ randomNo }}\n    </div>\n    <testDirective></testDirective>\n  `,\n  providers: [RandomService]\n})\nexport class GrandChildComponent {\n  randomNo: number;\n  constructor(private randomService: RandomService) {\n    this.randomNo = this.randomService.getRandom();\n  }\n}\n\n@Directive({\n  selector: 'testDirective'\n})\nexport class TestDirective {\n  randomNo: number;\n  constructor(@Host() private randomService: RandomService) {\n    this.randomNo = this.randomService.getRandom();\n  }\n}\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"providers vs. viewProviders")),(0,r.kt)("p",null,"providers and viewProviders are properties of the ",(0,r.kt)("inlineCode",{parentName:"p"},"@Component")," decorator that specify where Angular can find the providers of the dependencies for the component. The difference is that ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"providers are available to both view children and content children of the component")),", while ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"viewProviders are only available to view children")),". View children are the elements that are defined in the component's template, while content children are the elements that are projected into the component using ",(0,r.kt)("inlineCode",{parentName:"p"},"<ng-content>"),". For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@Component({\n  selector: 'my-parent',\n  template: `\n    <div class=\"box\">\n      ParentComponent => {{ randomNo }}\n    </div>\n    <my-child></my-child>\n    <ng-content></ng-content>\n  `,\n  providers: [RandomService]\n})\nexport class ParentComponent {\n  randomNo: number;\n  constructor(private randomService: RandomService) {\n    this.randomNo = this.randomService.getRandom();\n  }\n}\n\n@Component({\n  selector: 'my-child',\n  template: `\n    <div class=\"box\">\n      ChildComponent => {{ randomNo }}\n    </div>\n  `\n})\nexport class ChildComponent {\n  randomNo: number;\n  constructor(private randomService: RandomService) {\n    this.randomNo = this.randomService.getRandom();\n  }\n}\n\n@Component({\n  selector: 'my-grandChild',\n  template: `\n    <div class=\"box\">\n      GrandChildComponent => {{ randomNo }}\n    </div>\n  `\n})\nexport class GrandChildComponent {\n  randomNo: number;\n  constructor(private randomService: RandomService) {\n    this.randomNo = this.randomService.getRandom();\n  }\n}\n")),(0,r.kt)("p",null,"In this example, RandomService is provided by ParentComponent using providers. This means that both ChildComponent and GrandChildComponent can inject RandomService as their dependencies. ChildComponent is a view child of ParentComponent, while GrandChildComponent is a content child of ParentComponent (projected using ",(0,r.kt)("inlineCode",{parentName:"p"},"<ng-content>"),")."),(0,r.kt)("p",null,"If we change providers to viewProviders in ParentComponent, then only ChildComponent can inject RandomService, but not GrandChildComponent. This is because viewProviders limits the provider to view children only. This can be useful to prevent projected content from interfering with your services.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"@SkipSelf() and @Host() in viewProviders")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"@SkipSelf() and viewProviders"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"@Component({\n  selector: 'app-child',\n  viewProviders:\n  [{ provide: AnimalService, useValue: { emoji: '\ud83d\udc36' } }]\n})\nexport class ChildComponent {\n\n  // add @SkipSelf()\n  constructor(@SkipSelf() public animal : AnimalService) { }\n\n}\n")),(0,r.kt)("p",null,"The logical tree looks like this with @SkipSelf() in ",(0,r.kt)("inlineCode",{parentName:"p"},"<app-child>"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<app-root @NgModule(AppModule)\n          @Inject(AnimalService=>"\ud83d\udc33")>\n  <#VIEW>\x3c!-- search begins here and up --\x3e\n    <app-child>\n      <#VIEW @Provide(AnimalService="\ud83d\udc36")\n             @Inject(AnimalService, SkipSelf=>"\ud83d\udc33")>\n        \x3c!--Add @SkipSelf --\x3e\n      </#VIEW>\n    </app-child>\n  </#VIEW>\n</app-root>\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"@Host() and viewProviders"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"@Component({\n  selector: 'app-child',\n  \u2026\n  viewProviders:\n  [{ provide: AnimalService, useValue: { emoji: '\ud83d\udc36' } }]\n\n})\nexport class ChildComponent {\n  constructor(@Host() public animal : AnimalService) { }\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<app-root @NgModule(AppModule)\n          @Inject(AnimalService=>"\ud83d\udc33")>\n  <#VIEW>\n    <app-child>\n      <#VIEW @Provide(AnimalService="\ud83d\udc36")\n             @Inject(AnimalService, @Host=>"\ud83d\udc36")> \x3c!-- @Host stops search here: because AnimalService is provided here so Angular does not look further up the injector hierarchy --\x3e\n      </#VIEW>\n    </app-child>\n  </#VIEW>\n</app-root>\n'))))}S.isMDXComponent=!0;const A={toc:[{value:"Example 1",id:"example-1",level:4},{value:"Example 2",id:"example-2",level:4}]},I="wrapper";function T(e){let{components:n,...t}=e;return(0,r.kt)(I,(0,a.Z)({},A,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Angular Animation")),(0,r.kt)("p",null,"Animation is ",(0,r.kt)("inlineCode",{parentName:"p"},"transition")," from a ",(0,r.kt)("inlineCode",{parentName:"p"},"state")," to another ",(0,r.kt)("inlineCode",{parentName:"p"},"state"),"."),(0,r.kt)("h4",{id:"example-1"},"Example 1"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"@Component({\n  template: `<div [@openClose]=\"isOpen ? true : false\" class=\"open-close-container\"></div>`\n  animations: [\n    trigger('openClose', [\n      state('true', style({ height: '*' })),\n      state('false', style({ height: '0px' })),\n      transition('false <=> true', animate(500))\n    ])\n  ]\n})\n")),(0,r.kt)("h4",{id:"example-2"},"Example 2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"@Component({\n  template: `<my-element [@filterAnimation]=\"heroesTotal\"></my-element>`,\n  animations: [\n    trigger('filterAnimation', [\n      // [] means no animation will happen when the element enters the DOM, or when the expression bound to the trigger changes from any value to 0 or -1\n      transition(':enter, * => 0, * => -1', []),\n      transition(':increment', [\n        query(':enter', [\n          style({ opacity: 0, width: 0 }),\n          stagger(50, [\n            animate('300ms ease-out', style({ opacity: 1, width: '*' })),\n          ]),\n        ], { optional: true })\n      ]),\n      transition(':decrement', [\n        query(':leave', [\n          stagger(50, [\n            animate('300ms ease-out', style({ opacity: 0, width: 0 })),\n          ]),\n        ])\n      ]),\n    ]),\n  ]\n})\nexport class HeroListPageComponent implements OnInit {\n  heroesTotal = 1; // or -1\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"trigger():")," This function ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"creates an animation trigger")),". An animation trigger is a name that can be used to refer to a set of animation steps."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"transition():")," defines ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"how an element moves from one state to another")),". There are three transitions:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":enter:")," This transition is used to animate the element when it ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"is created")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":increment:")," This transition is used to animate the element ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"when its width is increased")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":decrement:")," This transition is used to animate the element ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"when its width is decreased")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":leave"),": is to specify that the animation should be triggered when the element leaves the document flow."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"animate():")," This function ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"defines an animation step")),". An animation step defines the initial and final styles of an element and the duration and easing curve of the animation.",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"  transition('* => *', [\n    animate('1s', keyframes ( [\n      style({ opacity: 0.1, offset: 0.1 }), // the opacity of the element will be 0.1 when 10% of the animation time has elapsed\n      style({ opacity: 0.6, offset: 0.2 }),\n      style({ opacity: 1,   offset: 0.5 }),\n      style({ opacity: 0.2, offset: 0.7 })\n    ]))\n  ])\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"query():")," This function ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"queries all elements that match a certain criteria")),". The ",(0,r.kt)("inlineCode",{parentName:"li"},"query()")," function in Angular animation takes the following parameters:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"element:")," The element to query, or a set of elements that contain Angular-specific characteristics, specified with one or more of the following tokens:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":enter"),": Query an element enters the viewport."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":leave"),": Query an element leaves the viewport. Example, ",(0,r.kt)("inlineCode",{parentName:"li"},"query(':enter, :leave', [...])")," when an element enters or leaves the viewport"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":animating")," : Query all currently animating elements."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@triggerName")," : Query elements that contain an animation trigger."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@*"),": Query all elements that contain animation triggers. If you use it on template like this ",(0,r.kt)("inlineCode",{parentName:"li"},'<div [@.disabled]="true">'),", it means disable all children's animations."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":self"),": Include the current element into the animation sequence."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"options:")," An object that can be used to control the behavior of the query. The following options are supported:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"deep:")," If true, the query will recurse into child elements."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"children:")," If true, the query will only return child elements."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"exclude:")," An array of element names that should be excluded from the query.")))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'const childElementsWithoutFoo = query(":self", { deep: true, exclude: ["foo"] });\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"stagger():")," This function allows you to ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"define a timing gap between each animated element")),". In the above code, the stagger() function is used to add a 50 millisecond delay between each animation."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"group():")," Runs multiple animation steps ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"in parallel")),".",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'group([\n  animate("1s", style({ background: "black" })),\n  animate("2s", style({ color: "white" }))\n])\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"sequence():")," This function allows you to ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"play multiple animation steps in sequence")),".",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'sequence([\n  style({ opacity: 0 }),\n  animate("1s", style({ opacity: 1 }))\n])\n'))))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Route transition animations")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"@NgModule({\n  imports: [\n    RouterModule.forRoot([\n      {\n        path: 'home',\n        component: HomeComponent,\n        data: { animation: 'HomePage' }\n      },\n      {\n        path: 'about',\n        component: AboutComponent,\n        data: { animation: 'AboutPage' }\n      },\n    ])\n  ],\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const slideInAnimation =\n  trigger('routeAnimations', [\n    transition('HomePage <=> AboutPage', [\n      style({ position: 'relative' }),\n      query(':enter, :leave', [\n        style({\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%'\n        })\n      ]),\n    ])\n  ]);\n\n@Component({\n  template: `\n    <div [@routeAnimations]=\"getRouteAnimationData()\">\n      <router-outlet></router-outlet>\n    </div>\n  `,\n  animations: [\n    slideInAnimation\n  ]\n})\nclass AppComponent {\n  constructor(private contexts: ChildrenOutletContexts) {}\n\n  getRouteAnimationData() {\n    return this.contexts.getContext('primary')?.route?.snapshot?.data?.['animation'];\n  }\n}\n"))))}T.isMDXComponent=!0;const D={toc:[]},M="wrapper";function E(e){let{components:n,...t}=e;return(0,r.kt)(M,(0,a.Z)({},D,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Ivy Rendering Engine In Angular")),(0,r.kt)("p",null,"Ivy is the new rendering engine for Angular that compiles and converts Angular code (template HTML + TS) into pure HTML and JavaScript that the browser understands. ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Ivy works by using incremental DOM and locality principle"))," to optimize the compilation and rendering process."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Incremental DOM")," means that Ivy ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"only updates the parts of the DOM that have changed, rather than recreating the entire DOM tree")),". This improves performance and memory usage.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Locality principle")," means that Ivy only ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"compiles the components that are needed for rendering")),", rather than compiling all the components in an ",(0,r.kt)("inlineCode",{parentName:"p"},"NgModule"),". This reduces the bundle size and enables faster recompilation."))),(0,r.kt)("p",null,"Ivy also supports ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"tree shaking, template type checking, and improved debugging tools")),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Tree shaking")," means that Ivy removes any unused code or dependencies from the final bundle, reducing its size and improving performance.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Template type checking")," means that Ivy checks for errors and inconsistencies in the templates at compile time, rather than at runtime.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Improved debugging tools")," means that Ivy provides new functions such as ",(0,r.kt)("inlineCode",{parentName:"p"},"ng.probe")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ng.getComponent"),", which allow you to inspect and manipulate the components and their properties in the browser console.")))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Annotations vs Decorators in Angular")),(0,r.kt)("p",null,"Annotations and decorators are both used to add metadata to code in Angular. However, there are some key differences between the two."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Annotations")," are ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"static metadata"))," that is ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"added to code at compile time")),". They are simply strings that are attached to a declaration, such as a class, method, or property. Annotations create an ",(0,r.kt)("inlineCode",{parentName:"p"},"annotations")," array on the class using the ",(0,r.kt)("inlineCode",{parentName:"p"},"Reflect Metadata library"),". Annotations ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"do not change the behavior of the code")),", but they can be used by tools and frameworks to provide information about the code. Annotations (which are commonly used in Angular 1) are still supported in Angular, ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"but they are not as commonly used as decorators & you need to hardcorded to use them")),"."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import {\n    ComponentAnnotation as Component,\n} from '@angular/core';\n\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"export class ComponentAnnotation extends DirectiveMetadata {\n    constructor() {\n        \n    }\n}\n\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Decorators")," are ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"dynamic metadata"))," that is ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"added to code at runtime")),". They are functions ( using the ",(0,r.kt)("inlineCode",{parentName:"p"},"Reflect.defineMetadata")," method) that are called when the decorated code is executed. Decorators can be used to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"change the behavior of the code")),", such as by adding functionality or injecting dependencies. There are different types of decorators:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Class Decorator")," : @Component"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Method Decorator"),": @HostListener"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Property Decorator"),": @Input/@Output"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameter Decorator"),": @Inject"))))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Pure Pipes vs Impure Pipes in angular")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Pure Pipes"),(0,r.kt)("th",{parentName:"tr",align:null},"Impure Pipes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Only executed when the value or parameter(s) changes"),(0,r.kt)("td",{parentName:"tr",align:null},"Executed on every change detection cycle")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Detect changes to primitive values or object references"),(0,r.kt)("td",{parentName:"tr",align:null},"Detect changes within objects or external factors")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Must be pure functions with no side effects"),(0,r.kt)("td",{parentName:"tr",align:null},"Can have side effects or depend on other values")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"More efficient and performant"),(0,r.kt)("td",{parentName:"tr",align:null},"More flexible and powerful")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Default for all pipes"),(0,r.kt)("td",{parentName:"tr",align:null},"Need to set pure property to false in the pipe decorator")))),(0,r.kt)("p",null,"Here is a code snippet of an impure filter pipe:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'filter',\n  pure: false // make it impure\n})\nexport class FilterPipe implements PipeTransform {\n\n  transform(items: any[], filter: string): any[] {\n    if (!items || !filter) {\n      return items;\n    }\n    // filter items array, items which match and return true will be kept, false will be filtered out\n    return items.filter(item => item.name.indexOf(filter) !== -1);\n  }\n}\n\n")),(0,r.kt)("p",null,"The impure pipe will be executed whenever the change detection cycle runs, regardless of whether the ",(0,r.kt)("inlineCode",{parentName:"p"},"items")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"filter")," have changed or not. If you want the pipe to be executed only when the items or filter change, you need to make it pure.")))}E.isMDXComponent=!0;const j={sidebar_position:3,id:"angular-zero-hero",sidebar_label:"Angular Zero To Hero",title:"Angular Zero To Hero"},R="Angular Zero To Hero",O={unversionedId:"js/angular-interviews/angular-zero-hero",id:"js/angular-interviews/angular-zero-hero",title:"Angular Zero To Hero",description:"Rendering In Angular",source:"@site/docs/js/angular-interviews/1.intro.md",sourceDirName:"js/angular-interviews",slug:"/js/angular-interviews/angular-zero-hero",permalink:"/devviews/interviews/js/angular-interviews/angular-zero-hero",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/js/angular-interviews/1.intro.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,id:"angular-zero-hero",sidebar_label:"Angular Zero To Hero",title:"Angular Zero To Hero"},sidebar:"jsInterviewSidebar",previous:{title:"Angular Interviews",permalink:"/devviews/interviews/angular-interview-questions-answers"},next:{title:"Rxjs From Zero To Hero",permalink:"/devviews/interviews/js/angular-interviews/rxjs-from-zero-to-hero"}},P={},F=[{value:"Rendering In Angular",id:"rendering-in-angular",level:3},{value:"DI Angular",id:"di-angular",level:3},{value:"Standalone Component",id:"standalone-component",level:3},{value:"Typed Form",id:"typed-form",level:3},{value:"Signals",id:"signals",level:3},{value:"Dynamic Component",id:"dynamic-component",level:3},{value:"Custom Element",id:"custom-element",level:3},{value:"Built-In Directives",id:"built-in-directives",level:3},{value:"Animation",id:"animation",level:3}],H={toc:F},L="wrapper";function V(e){let{components:n,...t}=e;return(0,r.kt)(L,(0,a.Z)({},H,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"angular-zero-to-hero"},"Angular Zero To Hero"),(0,r.kt)("h3",{id:"rendering-in-angular"},"Rendering In Angular"),(0,r.kt)(E,{mdxType:"Rendering"}),(0,r.kt)("h3",{id:"di-angular"},"DI Angular"),(0,r.kt)(S,{mdxType:"DIAngular"}),(0,r.kt)("h3",{id:"standalone-component"},"Standalone Component"),(0,r.kt)(l,{mdxType:"Standalone"}),(0,r.kt)("h3",{id:"typed-form"},"Typed Form"),(0,r.kt)(s,{mdxType:"TypedForm"}),(0,r.kt)("h3",{id:"signals"},"Signals"),(0,r.kt)(u,{mdxType:"Signals"}),(0,r.kt)("h3",{id:"dynamic-component"},"Dynamic Component"),(0,r.kt)(h,{mdxType:"DynamicComponent"}),(0,r.kt)("h3",{id:"custom-element"},"Custom Element"),(0,r.kt)(v,{mdxType:"CustomElement"}),(0,r.kt)("h3",{id:"built-in-directives"},"Built-In Directives"),(0,r.kt)(b,{mdxType:"BuiltInDirectives"}),(0,r.kt)("h3",{id:"animation"},"Animation"),(0,r.kt)(T,{mdxType:"Animation"}))}V.isMDXComponent=!0},7802:function(e,n,t){n.Z=t.p+"assets/images/DI-Angular-8f2e3d9099de7d29fa08264b47ae3474.png"},3053:function(e,n,t){n.Z=t.p+"assets/images/custom-element-a37bcec4efc16c4cdc22228391c8fb66.png"}}]);