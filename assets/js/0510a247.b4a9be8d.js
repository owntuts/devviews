"use strict";(self.webpackChunkinterviewdev=self.webpackChunkinterviewdev||[]).push([[5787],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return u}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),c=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(o.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=c(n),h=r,u=m["".concat(o,".").concat(h)]||m[h]||p[h]||i;return n?a.createElement(u,l(l({ref:t},d),{},{components:n})):a.createElement(u,l({ref:t},d))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=h;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[m]="string"==typeof e?e:r,l[1]=s;for(var c=2;c<i;c++)l[c]=n[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},20095:function(e,t,n){n.r(t),n.d(t,{assets:function(){return o},contentTitle:function(){return l},default:function(){return p},frontMatter:function(){return i},metadata:function(){return s},toc:function(){return c}});var a=n(83117),r=(n(67294),n(3905));const i={},l=void 0,s={unversionedId:"java/hero/OOP",id:"java/hero/OOP",title:"OOP",description:"OOP",source:"@site/docs/java/hero/OOP.md",sourceDirName:"java/hero",slug:"/java/hero/OOP",permalink:"/devviews/interviews/java/hero/OOP",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/java/hero/OOP.md",tags:[],version:"current",frontMatter:{},sidebar:"javaInterviewSidebar",previous:{title:"Java Type Conversion",permalink:"/devviews/interviews/java/hero/type-conversion"},next:{title:"concurrency",permalink:"/devviews/interviews/java/hero/concurrency"}},o={},c=[],d={toc:c},m="wrapper";function p(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"OOP")),"OOP is a programming paradigm that uses objects to model real-world entities and behaviors",(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Objects")," are instances of classes, which define the state and behavior of the objects. OOP aims to achieve ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"abstraction")),", ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"encapsulation")),", ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"inheritance")),", and ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"polymorphism"))," in programming"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Abstraction")," is hiding the implementation details and showing only the essential features. Abstraction can be achieved by using ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"abstract classes"))," and ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"interfaces")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Encapsulation")," is wrapping the data and methods together and restricting access to them. Encapsulation can be achieved by using access modifiers, such as ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"public")),", ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"private")),", ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"protected")),", and ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"default")),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Inheritance")," is acquiring the features and behaviors of an existing class by another class. Inheritance can be achieved by using the ",(0,r.kt)("inlineCode",{parentName:"li"},"extends")," keyword or the ",(0,r.kt)("inlineCode",{parentName:"li"},"implements")," keyword."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Polymorphism")," is the ability of an object to take different forms depending on the context. Polymorphism can be achieved by using method ",(0,r.kt)("inlineCode",{parentName:"li"},"overriding"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"overloading"),"."))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Interface vs Abstract Class")),(0,r.kt)("p",null,"An interface and an abstract class are both ways to achieve ",(0,r.kt)("strong",{parentName:"p"},"abstraction")," in Java, which means hiding the implementation details and showing only the essential features to the user. However, there are some differences between them, such as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"An interface can only declare ",(0,r.kt)("strong",{parentName:"li"},"abstract methods"),", which are methods that have no body and must be implemented by the classes that implement the interface. An abstract class can declare both ",(0,r.kt)("strong",{parentName:"li"},"abstract methods")," and ",(0,r.kt)("strong",{parentName:"li"},"non-abstract methods"),", which are methods that have a body and can be inherited or overridden by the subclasses that extend the abstract class. Since Java 8, an interface can also have ",(0,r.kt)("strong",{parentName:"li"},"default methods")," and ",(0,r.kt)("strong",{parentName:"li"},"static methods"),", which are methods that have a body and provide a default or utility implementation for the interface. Since Java 9, an interface can also have ",(0,r.kt)("strong",{parentName:"li"},"private methods"),", which are methods that are only accessible within the interface."),(0,r.kt)("li",{parentName:"ul"},"An interface can only declare ",(0,r.kt)("strong",{parentName:"li"},"constant variables"),", which are variables that are public, static, and final by default. An abstract class can declare any kind of variables, such as public, private, protected, default, static, final, non-final, etc."),(0,r.kt)("li",{parentName:"ul"},"A class can implement multiple interfaces, but it can extend only one abstract class. This is because an interface represents a set of behaviors, while an abstract class represents a type of object. A class can have multiple behaviors, but it can only belong to one type hierarchy."),(0,r.kt)("li",{parentName:"ul"},"An interface cannot have a constructor, because it cannot be instantiated. An abstract class can have a constructor, which will be invoked during the subclass object creation.")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Interface"),(0,r.kt)("th",{parentName:"tr",align:null},"Abstract Class"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Can only declare abstract methods (except default, static, and private methods since Java 8 and 9)"),(0,r.kt)("td",{parentName:"tr",align:null},"Can declare both abstract and non-abstract methods")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Can only declare constant variables (public, static, and final)"),(0,r.kt)("td",{parentName:"tr",align:null},"Can declare any kind of variables (public, private, protected, default, static, final, non-final, etc.)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"A class can implement multiple interfaces"),(0,r.kt)("td",{parentName:"tr",align:null},"A class can extend only one abstract class")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Cannot have a constructor"),(0,r.kt)("td",{parentName:"tr",align:null},"Can have a constructor (but cannot initialize)")))),(0,r.kt)("p",null,"Here is an example of an interface and an abstract class in Java:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// An interface\ninterface Flyable {\n  // A constant variable\n  int WINGS = 2;\n  // An abstract method\n  void fly();\n  // A default method\n  default void glide() {\n    System.out.println("Gliding...");\n  }\n  // A static method\n  static void land() {\n    System.out.println("Landing...");\n  }\n}\n\n// An abstract class\nabstract class Animal {\n  // A non-final variable\n  private String name;\n  // A final variable\n  protected final int legs;\n  // A constructor\n  public Animal(String name, int legs) {\n    this.name = name;\n    this.legs = legs;\n  }\n  // A non-abstract method\n  public String getName() {\n    return name;\n  }\n  // An abstract method\n  public abstract void makeSound();\n}\n\n// A class that implements an interface\nclass Bird implements Flyable {\n  // Implementing the abstract method\n  public void fly() {\n    System.out.println("Flying...");\n  }\n}\n\n// A class that extends an abstract class and implements an interface\nclass Eagle extends Animal implements Flyable {\n  // Calling the superclass constructor\n  public Eagle(String name) {\n    super(name, 2);\n  }\n  // Implementing the abstract method from Animal\n  public void makeSound() {\n    System.out.println("Screaming...");\n  }\n  // Overriding the default method from Flyable\n  public void glide() {\n    System.out.println("Gliding high...");\n  }\n}\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Access modifiers & Non-access modifiers in java")),(0,r.kt)("p",null,"In Java, there are two types of modifiers: access modifiers and non-access modifiers."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Access modifiers")," ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"control the visibility and accessibility"))," of classes, methods, and fields. There are four access modifiers in Java:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"public"),": The class, method, or field is accessible from any other class or any package."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"private"),": The class, method, or field is accessible only within the same class."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"protected"),": The class, method, or field is accessible within the same package or from subclasses in different packages."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"default")," (no keyword): The class, method, or field is accessible within the same package.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Non-access modifiers")," ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"modify the behavior and properties"))," of classes, methods, and fields. There are several non-access modifiers in Java, such as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"static"),": The class, method, or field belongs to the class and not to any object of the class. It can be accessed without creating an object of the class."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"final"),": The class, method, or field cannot be changed or overridden. It can be initialized only once."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"abstract"),": The class or method is incomplete and cannot be instantiated. It can only be extended or implemented by subclasses or subinterfaces."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"synchronized"),": The method or block can be accessed by only one thread at a time."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"volatile"),": The field is not cached by threads and its value is always read from the main memory."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"transient"),": The field is not serialized when the object is saved to a file or sent over a network."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"native"),": The method is implemented in a platform-dependent language such as C or C++.")),(0,r.kt)("p",null,"Here are some examples of using these modifiers in Java:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// A public class that can be accessed from any package\npublic class Animal {\n  // A private field that can be accessed only within this class\n  private String name;\n  // A protected field that can be accessed within this package or from subclasses in different packages\n  protected int age;\n  // A default field that can be accessed within this package\n  String type;\n  // A public static final field that can be accessed from any class or package and cannot be changed\n  public static final int MAX_AGE = 100;\n  \n  // A public constructor that can be used to create an object of this class from any package\n  public Animal(String name, int age, String type) {\n    this.name = name;\n    this.age = age;\n    this.type = type;\n  }\n  \n  // A private method that can be called only within this class\n  private void setName(String name) {\n    this.name = name;\n  }\n  \n  // A protected method that can be called within this package or from subclasses in different packages\n  protected void setAge(int age) {\n    this.age = age;\n  }\n  \n  // A default method that can be called within this package\n  void setType(String type) {\n    this.type = type;\n  }\n  \n  // A public method that can be called from any class or package\n  public String getName() {\n    return name;\n  }\n  \n  // A public static method that can be called without creating an object of this class\n  public static boolean isOld(int age) {\n    return age > MAX_AGE;\n  }\n  \n  // An abstract method that has no implementation and must be overridden by subclasses\n  public abstract void makeSound();\n}\n\n// A final class that cannot be extended by any other class\nfinal class Dog extends Animal {\n  \n  // A public constructor that calls the super constructor\n  public Dog(String name, int age) {\n    super(name, age, "Dog");\n  }\n  \n  // An overridden method that provides the implementation for the abstract method in the superclass\n  @Override\n  public void makeSound() {\n    System.out.println("Woof!");\n  }\n}\n\n// An interface that defines some constants and abstract methods\ninterface Flyable {\n  \n  // A public static final field that is implicitly declared by the interface\n  int MAX_SPEED = 200;\n  \n  // An abstract method that has no implementation and must be implemented by classes that implement this interface\n  void fly();\n}\n\n// A class that implements an interface and inherits from another class\nclass Bird extends Animal implements Flyable {\n  \n  // A private volatile field that is not cached by threads and always read from the main memory\n  private volatile boolean flying;\n  \n  // A public constructor that calls the super constructor\n  public Bird(String name, int age) {\n    super(name, age, "Bird");\n    flying = false;\n  }\n  \n  // A synchronized method that can be accessed by only one thread at a time\n  public synchronized void setFlying(boolean flying) {\n    this.flying = flying;\n  }\n  \n  // An implemented method that provides the implementation for the interface method\n  @Override\n  public void fly() {\n    if (flying) {\n      System.out.println("I am flying at " + MAX_SPEED + " km/h");\n    } else {\n      System.out.println("I am not flying");\n    }\n  }\n  \n  // An overridden method that provides the implementation for the abstract method in the superclass\n  @Override\n  public void makeSound() {\n    System.out.println("Tweet!");\n  }\n}\n')),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Modifier"),(0,r.kt)("th",{parentName:"tr",align:null},"Access"),(0,r.kt)("th",{parentName:"tr",align:null},"Mutability"),(0,r.kt)("th",{parentName:"tr",align:null},"Inheritance"),(0,r.kt)("th",{parentName:"tr",align:null},"Overriding"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"public"),(0,r.kt)("td",{parentName:"tr",align:null},"Anywhere"),(0,r.kt)("td",{parentName:"tr",align:null},"Depends on other modifiers"),(0,r.kt)("td",{parentName:"tr",align:null},"Allowed for classes and methods"),(0,r.kt)("td",{parentName:"tr",align:null},"Allowed for methods")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"private"),(0,r.kt)("td",{parentName:"tr",align:null},"Same class only"),(0,r.kt)("td",{parentName:"tr",align:null},"Depends on other modifiers"),(0,r.kt)("td",{parentName:"tr",align:null},"Not allowed for classes and methods"),(0,r.kt)("td",{parentName:"tr",align:null},"Not allowed for methods")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"protected"),(0,r.kt)("td",{parentName:"tr",align:null},"Same package or subclasses in different packages"),(0,r.kt)("td",{parentName:"tr",align:null},"Depends on other modifiers"),(0,r.kt)("td",{parentName:"tr",align:null},"Allowed for classes and methods"),(0,r.kt)("td",{parentName:"tr",align:null},"Allowed for methods")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"default"),(0,r.kt)("td",{parentName:"tr",align:null},"Same package only"),(0,r.kt)("td",{parentName:"tr",align:null},"Depends on other modifiers"),(0,r.kt)("td",{parentName:"tr",align:null},"Allowed for classes and methods"),(0,r.kt)("td",{parentName:"tr",align:null},"Allowed for methods")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"static"),(0,r.kt)("td",{parentName:"tr",align:null},"Depends on other access modifiers"),(0,r.kt)("td",{parentName:"tr",align:null},"Depends on other modifiers"),(0,r.kt)("td",{parentName:"tr",align:null},"Not allowed for classes, allowed for methods and fields"),(0,r.kt)("td",{parentName:"tr",align:null},"Not allowed for methods and fields")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"final"),(0,r.kt)("td",{parentName:"tr",align:null},"Depends on other access modifiers"),(0,r.kt)("td",{parentName:"tr",align:null},"Not mutable"),(0,r.kt)("td",{parentName:"tr",align:null},"Not allowed for classes and methods, allowed for fields"),(0,r.kt)("td",{parentName:"tr",align:null},"Not allowed for methods and fields")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"non-final"),(0,r.kt)("td",{parentName:"tr",align:null},"Depends on other access modifiers"),(0,r.kt)("td",{parentName:"tr",align:null},"Mutable"),(0,r.kt)("td",{parentName:"tr",align:null},"Allowed for classes, methods, and fields"),(0,r.kt)("td",{parentName:"tr",align:null},"Allowed for methods and fields")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// A public class\npublic class A {\n  // A public static final field\n  public static final int VALUE = 10;\n  // A private non-static non-final field\n  private int number;\n  // A protected static non-final method\n  protected static void print() {\n    System.out.println("Printing...");\n  }\n  // A default non-static final method\n  final void display() {\n    System.out.println("Displaying...");\n  }\n}\n\n// A non-final class that inherits from A\nclass B extends A {\n  // A public non-static non-final method that overrides print()\n  public void print() {\n    System.out.println("Printing from B...");\n  }\n  // A private static final method\n  private static final void show() {\n    System.out.println("Showing...");\n  }\n}\n\n// A final class that inherits from B\nfinal class C extends B {\n  // A protected non-static non-final field\n  protected int value;\n  // A default static non-final method\n  static void display() {\n    System.out.println("Displaying from C...");\n  }\n}\n'))))}p.isMDXComponent=!0}}]);