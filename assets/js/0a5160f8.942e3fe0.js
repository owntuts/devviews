"use strict";(self.webpackChunkinterviewdev=self.webpackChunkinterviewdev||[]).push([[7383],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return f}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),m=d(a),c=r,f=m["".concat(l,".").concat(c)]||m[c]||u[c]||s;return a?n.createElement(f,i(i({ref:t},p),{},{components:a})):n.createElement(f,i({ref:t},p))}));function f(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,i=new Array(s);i[0]=c;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[m]="string"==typeof e?e:r,i[1]=o;for(var d=2;d<s;d++)i[d]=a[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},4312:function(e,t,a){a.d(t,{ZP:function(){return o}});var n=a(3117),r=(a(7294),a(3905));const s={toc:[]},i="wrapper";function o(e){let{components:t,...a}=e;return(0,r.kt)(i,(0,n.Z)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("div",{className:"interview"},a.level&&(0,r.kt)("span",{className:"level"},a.level),a.children))}o.isMDXComponent=!0},768:function(e,t,a){a.r(t),a.d(t,{assets:function(){return f},contentTitle:function(){return u},default:function(){return h},frontMatter:function(){return m},metadata:function(){return c},toc:function(){return b}});var n=a(3117),r=(a(7294),a(3905));a(4312);const s={toc:[]},i="wrapper";function o(e){let{components:t,...a}=e;return(0,r.kt)(i,(0,n.Z)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Database Types")),(0,r.kt)("p",null,"There are many types of databases available, some of which include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Relational databases (RDBMS)")," - These databases store data in tables with predefined relationships between them. Examples include MySQL, Oracle, and PostgreSQL.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"NoSQL databases")," - These databases do not use the traditional table structure and are designed to handle unstructured data. Examples include MongoDB, Cassandra, and Couchbase.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Object-oriented databases")," - These databases are designed to handle complex data types and relationships using object-oriented programming concepts. Examples include db4o and ObjectDB.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Key-value (KV) databases")," - These databases store data in key-value pairs and are primarily used for quick lookups. Examples include Redis, Riak, and Memcached.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Graph databases")," - These databases store data in nodes and edges, making them useful for complex and connected data. Examples include Neo4j, AllegroGraph, and OrientDB.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Columnar databases")," - These databases store data in columns rather than rows, which can be more efficient for certain types of data analysis. Examples include Apache Cassandra, HBase, and Vertica.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Cloud databases")," - These databases are delivered through cloud computing platforms and are designed to handle massive amounts of data storage and processing. Examples include Amazon Web Services (AWS) DynamoDB, Google Bigtable, and Microsoft Azure SQL Database.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Time-series databases")," - These databases are designed to handle large volumes of time-stamped data, making them ideal for IoT devices and sensor data. Examples include InfluxDB, TimescaleDB, and OpenTSDB."))),(0,r.kt)("p",null,"These are just a few examples of the many types of databases available. Each has its own strengths and weaknesses, and the choice of database type typically depends on the specific needs and requirements of the application or project at hand.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"SQL vs NoSQL")),(0,r.kt)("p",null,"SQL and NoSQL are two broad categories of databases that differ in many aspects. Here are some of the main differences between SQL versus NoSQL databases:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Aspect"),(0,r.kt)("th",{parentName:"tr",align:null},"SQL"),(0,r.kt)("th",{parentName:"tr",align:null},"NoSQL"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Structure"),(0,r.kt)("td",{parentName:"tr",align:null},"Table based (have a fixed schema - predefined columns and types)"),(0,r.kt)("td",{parentName:"tr",align:null},"Document, key-value, graph, or column based")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Scalability"),(0,r.kt)("td",{parentName:"tr",align:null},"Vertical"),(0,r.kt)("td",{parentName:"tr",align:null},"Horizontal")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Relationships"),(0,r.kt)("td",{parentName:"tr",align:null},"Foreign keys"),(0,r.kt)("td",{parentName:"tr",align:null},"Embedded or referenced data")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Language"),(0,r.kt)("td",{parentName:"tr",align:null},"SQL"),(0,r.kt)("td",{parentName:"tr",align:null},"Various query languages or APIs")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Use Cases"),(0,r.kt)("td",{parentName:"tr",align:null},"Complex queries, transactions, consistency, reliability"),(0,r.kt)("td",{parentName:"tr",align:null},"Fast performance, scalability, flexibility, unstructured or semi-structured data")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Use Cases Ex"),(0,r.kt)("td",{parentName:"tr",align:null},"used for online transaction processing, data warehousing, business intelligence, and analytics"),(0,r.kt)("td",{parentName:"tr",align:null},"used for web applications, social media platforms, real-time processing, and big data analyticsa")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"NoSQL (Not only SQL)")," databases do not rely on SQL as the main query language (Some NoSQL databases support a subset or a variation of SQL)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Scale vertically"),", meaning that they can handle more load by adding more resources to a single server."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Scale horizontally"),", meaning that they can handle more load by adding more servers to a cluster."))))}o.isMDXComponent=!0;const l={toc:[]},d="wrapper";function p(e){let{components:t,...a}=e;return(0,r.kt)(d,(0,n.Z)({},l,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Trade-off Theorems")),(0,r.kt)("p",null,"Here are some common trade-off theorems in database design:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The CAP Theorem"),": This theorem states that it is impossible for a distributed computer system to simultaneously provide all three guarantees of consistency, availabilty , and partition tolerance. Database designers must therefore make trade-offs between these three attributes.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The ACID Properties Theorem"),": This theorem states that transactions in a database must satisfy four properties: Atomicity, Consistency, Isolation, and Durability. While these properties ensure data integrity, they can come at the cost of performance and scalability.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The Normalization vs"),". Performance Trade-Off: Normalization is used in database design to eliminate data redundancy and improve data consistency. However, normalized databases can result in complex queries and lower performance. Database designers must therefore make trade-offs between normalization and performance.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The Denormalization Trade-Off"),": Denormalization involves adding redundant data to a database to improve performance. However, this can result in data inconsistencies and higher storage requirements. Database designers must therefore trade-off between denormalization and data consistency.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The Indexing Trade-Off"),": Indexing improves query performance, but it comes at the cost of increased storage and slower write times. Database designers must therefore make trade-offs between query speed and write performance.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The Sharding Trade-Off"),": Sharding is used to distribute data across multiple nodes to improve scalability, but it comes at the cost of increased complexity and higher latency due to network communication. Database designers must therefore trade-off between scalability and complexity.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The Security vs. Performance Trade-Off"),": The addition of security measures such as encryption can negatively impact database performance. However, insufficient security measures can result in data breaches and compromise data integrity. Database designers must therefore make trade-offs between security and performance."))),(0,r.kt)("p",null,"These are just a few examples of trade-off theorems in database design. Understanding these trade-offs is important in making informed decisions about database design and in optimizing database performance and scalability without compromising data integrity.")))}p.isMDXComponent=!0;const m={sidebar_position:3,id:"database",sidebar_label:"Database",title:"Database"},u="Database",c={unversionedId:"system-design/database",id:"system-design/database",title:"Database",description:"Database Types",source:"@site/docs/system-design/20.database.md",sourceDirName:"system-design",slug:"/system-design/database",permalink:"/devviews/interviews/system-design/database",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/system-design/20.database.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,id:"database",sidebar_label:"Database",title:"Database"},sidebar:"designSystemInterviewSidebar",previous:{title:"Design Patterns",permalink:"/devviews/interviews/system-design/design-patterns"},next:{title:"System Design Principles",permalink:"/devviews/interviews/system-design/system-design-principles"}},f={},b=[{value:"Database Types",id:"database-types",level:3},{value:"Trade-off Theorems",id:"trade-off-theorems",level:3}],g={toc:b},y="wrapper";function h(e){let{components:t,...a}=e;return(0,r.kt)(y,(0,n.Z)({},g,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"database"},"Database"),(0,r.kt)("h3",{id:"database-types"},"Database Types"),(0,r.kt)(o,{mdxType:"DatabaseTypes"}),(0,r.kt)("h3",{id:"trade-off-theorems"},"Trade-off Theorems"),(0,r.kt)(p,{mdxType:"TradeoffTheorems"}))}h.isMDXComponent=!0}}]);