"use strict";(self.webpackChunkinterviewdev=self.webpackChunkinterviewdev||[]).push([[9845],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},k=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(n),k=r,d=m["".concat(s,".").concat(k)]||m[k]||u[k]||o;return n?a.createElement(d,i(i({ref:t},c),{},{components:n})):a.createElement(d,i({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=k;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}k.displayName="MDXCreateElement"},54312:function(e,t,n){n.d(t,{ZP:function(){return l}});var a=n(83117),r=(n(67294),n(3905));const o={toc:[]},i="wrapper";function l(e){let{components:t,...n}=e;return(0,r.kt)(i,(0,a.Z)({},o,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("div",{className:"interview"},n.level&&(0,r.kt)("span",{className:"level"},n.level),n.children))}l.isMDXComponent=!0},7830:function(e,t,n){n.r(t),n.d(t,{assets:function(){return L},contentTitle:function(){return R},default:function(){return Z},frontMatter:function(){return I},metadata:function(){return A},toc:function(){return _}});var a=n(83117),r=(n(67294),n(3905));n(54312);const o={toc:[]},i="wrapper";function l(e){let{components:t,...l}=e;return(0,r.kt)(i,(0,a.Z)({},o,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Container vs Virtual Machine")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"container vs virtialmachine",src:n(98424).Z,width:"821",height:"432"})),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Containers")," provide a lighter weight, faster way to run applications as they share the host kernel, whereas virtual machines have their own kernel and hardware resources. Containers have lower overhead and are easier to deploy compared to virtual machines, but they also have lower security due to shared resources. Containers are limited in terms of application compatibility whereas virtual machines can run any operating system."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null},"Container"),(0,r.kt)("th",{parentName:"tr",align:null},"Virtual Machine"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Scope"),(0,r.kt)("td",{parentName:"tr",align:null},"OS-level"),(0,r.kt)("td",{parentName:"tr",align:null},"Hardware")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Isolation"),(0,r.kt)("td",{parentName:"tr",align:null},"Process"),(0,r.kt)("td",{parentName:"tr",align:null},"Full")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Size"),(0,r.kt)("td",{parentName:"tr",align:null},"Smaller"),(0,r.kt)("td",{parentName:"tr",align:null},"Larger")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Speed"),(0,r.kt)("td",{parentName:"tr",align:null},"Faster"),(0,r.kt)("td",{parentName:"tr",align:null},"Slower")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Overhead"),(0,r.kt)("td",{parentName:"tr",align:null},"Lower"),(0,r.kt)("td",{parentName:"tr",align:null},"High")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Deploy"),(0,r.kt)("td",{parentName:"tr",align:null},"Easier"),(0,r.kt)("td",{parentName:"tr",align:null},"Harder")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Security"),(0,r.kt)("td",{parentName:"tr",align:null},"Lower"),(0,r.kt)("td",{parentName:"tr",align:null},"Higher")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Compatibility"),(0,r.kt)("td",{parentName:"tr",align:null},"Limited"),(0,r.kt)("td",{parentName:"tr",align:null},"High")))),(0,r.kt)("p",null,"Containers are isolated environments that contain everything needed to run an application, such as code, libraries, dependencies, and configuration files. Containers are lightweight and portable, which makes them ideal for deploying applications across different environments.")))}l.isMDXComponent=!0;const s={toc:[]},p="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"docker-compose declaration")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Compose file version"))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"version"),": Specifies the version of the Compose file syntax being used. It determines which Compose features are available to the file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'version: "3.9"\n')),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Services"))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"services"),": Defines the services that make up your application. Each service is a container that runs the image defined by the build or image field."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'services:\n  web:\n    build: .\n    ports:\n      - "5000:5000"\n  redis:\n    image: "redis:alpine"\n')),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Service Configuration"))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"build"),": Specifies the path to the Dockerfile for building a Docker image."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"image"),": Specifies the name of an existing image to use instead of building an image from a Dockerfile."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"container_name"),": Specifies a custom name for the container."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"command"),": Overrides the default command specified by the image."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"environment"),": Defines environment variables to set inside the container."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ports"),": Exposes a port or a range of ports on the host."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"volumes"),": Mounts a directory or file from the host inside the container."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"networks"),": Connects the service to a pre-existing network."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"depends_on"),": Specifies the dependent services in the order they should be started.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'services:\n  web:\n    build: .\n    container_name: my_container\n    command: python app.py\n    environment:\n      - ENV_VAR=value\n    ports:\n      - "5000:5000"\n    volumes:\n      - .:/code\n    networks:\n      - my_network\n    depends_on:\n      - db\n  db:\n    image: postgres\n')),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Networks"))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"networks"),": Defines the networks to be created."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"networks:\n  my_network:\n")),(0,r.kt)("ol",{start:5},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Network Configuration"))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"driver"),": Specifies the network driver to use."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ipam"),": Configures the IP Address Management driver for the network."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"subnet"),": Specifies the subnet for the network."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"gateway"),": Specifies the gateway for the network.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"networks:\n  my_network:\n    driver: bridge # A bridge network is the default network driver for Docker, and it allows your containers to communicate with each other and with the host machin\n    ipam:\n      driver: default #  The default IPAM driver assigns IP addresses to your containers automatically from a predefined pool\n      config:\n        - subnet: 172.28.0.0/16\n          gateway: 172.28.5.254\n")),(0,r.kt)("ol",{start:6},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Volumes"))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"volumes"),": Defines the volumes to be created."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"volumes:\n  my_volume:\n")),(0,r.kt)("ol",{start:7},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Volume Configuration"))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"driver"),": Specifies the volume driver to use. (Volumes can also use different drivers and options to store data on remote hosts, cloud providers, or encrypt the contents of volumes.)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"driver_opts"),": Specifies the options for the volume driver."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"external"),": Specifies whether the volume should be created on the host or in a plugin managed volume."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"name"),": Specifies the name of an existing volume to use.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'volumes:\n  my_volume:\n    driver: local # The local driver stores volumes on the host machine where the containers run\n    driver_opts:\n      type: "nfs4" # the type of the volume, which is nfs4. This means that your volume will use the NFSv4 protocol to access a shared file system on a remote server\n      o: "addr=192.168.1.100,nfsvers=4,rw" #  your volume will connect to the server with IP address 192.168.1.100, use NFS version 4, and mount the volume as read-write\n      device: ":/myshare" # your volume will access the directory /myshare on the remote server\n    external: true # volume is external, which means that it has been created outside of Compose using docker volume create or another tool\n')),(0,r.kt)("ol",{start:8},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Secrets"))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"secrets"),": Defines the secrets to be created."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"services:\n  app:\n    image: example-app:latest\n    secrets: # specify the secrets that the app service should receive\n      - db_password # mount the db_password secret below to /run/secrets/db_password\n      - source: api_key # use the api_key secret blow as the source\n        target: app_api_key # mount the api_key secret to /run/secrets/app_api_key\n\nsecrets: # define the secrets that are used in the services\n  db_password: # name of the secret\n    file: ./db_password.txt # file path where the secret value is stored on the host machine\n  api_key: # name of the secret\n    external: true # indicate that the secret is created outside of Compose using docker secret create or another tool\n")),(0,r.kt)("ol",{start:9},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Configurations"))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"configs"),": Defines the configurations to be created."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"file"),": Specifies the path to the file to use as the configuration.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'services:\n  web:\n    image: nginx\n    ports:\n      - "80:80"\n    configs: # specify the configs that the web service should receive\n      - source: nginx_config # use the nginx_config config as the source\n        target: /etc/nginx/nginx.conf # mount the config to /etc/nginx/nginx.conf within the container\n\n  app:\n    image: node\n    configs: # specify the configs that the app service should receive\n      - source: app_config # use the app_config config as the source\n        target: /app/config.json # mount the config to /app/config.json within the container\n\nconfigs:\n  nginx_config: # name of the config\n    file: ./nginx.conf # file path where the config value is stored on the host machine\n  app_config: # name of the config\n    external: true # indicate that the config is already created outside of Compose using `docker config create` or another tool\n')),(0,r.kt)("ol",{start:10},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"services_order"))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"services_order"),": Specifies the order in which services should be started.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"services_order: [web, db]\n"))))}c.isMDXComponent=!0;const m={toc:[{value:"Commands for building images:",id:"commands-for-building-images",level:4},{value:"Commands for configuring images:",id:"commands-for-configuring-images",level:4},{value:"Miscellaneous commands",id:"miscellaneous-commands",level:4},{value:"The order of execution",id:"the-order-of-execution",level:4}]},u="wrapper";function k(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Dockerfile-commands")),(0,r.kt)("h4",{id:"commands-for-building-images"},"Commands for building images:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"FROM"),": Specifies the base image for the subsequent instructions."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RUN"),": Runs a command inside the container to install packages, configure services or applications, etc."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ARG"),": Defines an argument to be used in ",(0,r.kt)("inlineCode",{parentName:"li"},"Dockerfile"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"WORKDIR"),": Sets the working directory for future instructions."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"COPY")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"ADD"),": Copies a file or directory from the host machine to the container.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'# Use the official node image as the base image\nFROM node:14\n\n# Define an argument called NODE_ENV with a default value of production\nARG NODE_ENV=production\n\n# Set the environment variable NODE_ENV to the value of the argument NODE_ENV\nENV NODE_ENV $NODE_ENV\n\n# Set the working directory to /app\nWORKDIR /app\n\n# Copy the package.json and package-lock.json files from the host to the working directory\nCOPY package*.json ./\n\n# Run the npm install command to install dependencies\nRUN npm install\n\n# Copy the rest of the files from the host to the working directory\nCOPY . .\n\n# Expose port 3000 for the app\nEXPOSE 3000\n\n# Run the npm start command to start the app\nCMD [ "npm", "start" ]\n')),(0,r.kt)("h4",{id:"commands-for-configuring-images"},"Commands for configuring images:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"EXPOSE"),": Declares what port(s) should be exposed by the container.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dockerfile"},"# To expose port 80 of the container\nEXPOSE 80\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ENV"),": Set environment variable inside the container.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dockerfile"},"# To set the working directory as an environment variable\nENV workdirectory /usr/node\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"LABEL"),": Provides metadata to an image.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dockerfile"},'# To add some labels to the image\nLABEL "author"="FOSS TechNIx"\nLABEL "Date"="2020-09-29"\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"USER"),": Specifies the user or UID to use when running the image.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dockerfile"},"# To run the image as user ubuntu\nUSER ubuntu\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ENTRYPOINT"),": Specifies the command to be run when the container starts.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dockerfile"},'# To run a python script as the entrypoint\nENTRYPOINT ["python", "app.py"]\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"CMD"),": Specifies the arguments to be passed to the entrypoint command.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dockerfile"},'# To pass some arguments to the python script\nCMD ["--port", "8080"]\n')),(0,r.kt)("h4",{id:"miscellaneous-commands"},"Miscellaneous commands"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"LABEL"),": Provides metadata to an image.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'# To add some labels to the image\nLABEL "author"="FOSS TechNIx"\nLABEL "Date"="2020-09-29"\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ONBUILD"),": Specifies a command to execute when the image is used as a base image.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"# To run a command when another image is built on top of this image\nONBUILD RUN npm install\n")),(0,r.kt)("h4",{id:"the-order-of-execution"},"The order of execution"),(0,r.kt)("p",null,"Here's a list of Dockerfile commands in the order they are typically executed:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"FROM")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ARG")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RUN")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"COPY")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"ADD")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"WORKDIR")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RUN")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"EXPOSE")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ENV")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"LABEL")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"USER")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ENTRYPOINT")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"CMD")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ONBUILD")))))}k.isMDXComponent=!0;const d={toc:[]},h="wrapper";function g(e){let{components:t,...n}=e;return(0,r.kt)(h,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"RUN vs CMD vs ENTRYPOINT")),(0,r.kt)("p",null,"Here is a brief summary of the difference between RUN, CMD and ENTRYPOINT commands in a dockerfile:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RUN"),": Executes a command and saves the result as a new layer in the image. It is usually used to install packages or run build steps (",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"within Docker Image Building Stages"))," - when Image is being created from Dockerfile). For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dockerfile"},"# To install curl in the image\nRUN apt-get update && apt-get install -y curl\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"CMD"),": Specifies the default command to ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"run when a container is created"))," from the image. It can be overridden by passing a different command to the docker run command. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dockerfile"},'# To run a python script as the default command\nCMD ["python", "app.py"]\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ENTRYPOINT"),": Specifies the executable that will ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"run when the container is started"))," (when bash shell of container is provided). It allows the ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"container to be run as if it was a binary")),". It can be combined with CMD to provide default arguments that can be overridden. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dockerfile"},'# To run a python script as the entrypoint\nENTRYPOINT ["python"]\n# To provide a default argument to the entrypoint\nCMD ["app.py"]\n'))))}g.isMDXComponent=!0;const N={toc:[]},f="wrapper";function w(e){let{components:t,...o}=e;return(0,r.kt)(f,(0,a.Z)({},N,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Docker Architecture")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Docker Architecture",src:n(18723).Z,width:"902",height:"399"})),(0,r.kt)("p",null,"Docker uses a client-server architecture. The Docker client talks to the Docker daemon, which does the heavy lifting of building, running, and distributing your Docker containers. The Docker client and daemon can run on the same system, or you can connect a Docker client to a remote Docker daemon. The Docker client and daemon communicate using a REST API\xb9."),(0,r.kt)("p",null,"The Docker daemon manages the following components:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Images"),": Images are ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"read-only templates"))," that define how to create a container. You can create your own images or use images from public or private repositories. Images are composed of layers that can be shared and reused by other images."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Containers"),": Containers ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"are instances of images"))," that run in isolation on the host machine. You can start, stop, move, or delete containers using the Docker client or API. Containers can be connected to each other and to external networks using networks and volumes."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Networks"),": Networks allow containers to communicate with each other and with other hosts. Docker provides different network drivers to support different use cases, such as bridge, host, overlay, macvlan, etc. You can also create your own custom network plugins using the Docker plugin API."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Volumes"),": Volumes are persistent data storage units that can be attached to one or more containers. Volumes allow you to persist data across container restarts and share data between containers. Docker provides different volume drivers to support different storage backends, such as local, NFS, cloudstor, etc. You can also create your own custom volume plugins using the Docker plugin API."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"The Docker registry or hub")," is a service that ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"stores and distributes Docker images")),". You can use the public Docker Hub to access official images from Docker and other community images. You can also use private registries to store and manage your own images."))))}w.isMDXComponent=!0;const y={toc:[]},v="wrapper";function b(e){let{components:t,...o}=e;return(0,r.kt)(v,(0,a.Z)({},y,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Build Pipeline")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Docker Architecture",src:n(6746).Z,width:"835",height:"274"}))))}b.isMDXComponent=!0;const C={toc:[]},D="wrapper";function T(e){let{components:t,...o}=e;return(0,r.kt)(D,(0,a.Z)({},C,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Docker Build Stages")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Docker Build Stages",src:n(84118).Z,width:"810",height:"178"})),(0,r.kt)("p",null,"Building stages in Docker are a way to create images that use multiple base images and only keep the artifacts that are needed for the final image. Building stages can help reduce the size and complexity of your images by separating the build process into different steps."),(0,r.kt)("p",null,"A building stage is defined by a ",(0,r.kt)("inlineCode",{parentName:"p"},"FROM")," instruction in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Dockerfile"),". Each ",(0,r.kt)("inlineCode",{parentName:"p"},"FROM")," instruction starts a new stage of the build and can use a different base image. You can copy files or run commands in each stage, and then selectively copy artifacts from one stage to another. You can also name your stages using the ",(0,r.kt)("inlineCode",{parentName:"p"},"AS")," keyword after the ",(0,r.kt)("inlineCode",{parentName:"p"},"FROM")," instruction."),(0,r.kt)("p",null,"For example, here is a ",(0,r.kt)("inlineCode",{parentName:"p"},"Dockerfile")," that uses two building stages to create an image with a Typescript app:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dockerfile"},"# Build stage 1 -> for dev\nFROM node:10.15.2\nWORKDIR /usr/src/app\nCOPY package*.json ./\nCOPY tsconfig.json ./\nRUN npm install\nCOPY ./src ./src\nRUN npm run build\n\n# Build stage 2 -> for prop.\nFROM node:10.15.2\nWORKDIR /usr/src/app\nCOPY package*.json ./\nRUN npm install --only=production\nCOPY --from=0 /usr/src/app/build ./build # Copy the app binary from the first stage\nEXPOSE 80\nCMD npm start\n\n")),(0,r.kt)("p",null,"or another example with Go app:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dockerfile"},'# syntax=docker/dockerfile:1\n# First stage: build the app\nFROM golang:1.16 AS builder # named the stage\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY *.go ./\nRUN CGO_ENABLED=0 go build -o app\n\n# Second stage: copy the app and run it\nFROM alpine:latest\nWORKDIR /app\nCOPY --from=builder /app/app . # Copy the app binary from the `builder` stage\nEXPOSE 8080\nCMD [ "./app" ]\n')),(0,r.kt)("p",null,"To build the image from this ",(0,r.kt)("inlineCode",{parentName:"p"},"Dockerfile"),", you can use the same ",(0,r.kt)("inlineCode",{parentName:"p"},"docker build")," command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"$ docker build -t go-app:builder --target builder .\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"-t")," option specifies the ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"name and tag"))," of the image, which in this case is ",(0,r.kt)("inlineCode",{parentName:"li"},"go-app:builder")," "),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"--target")," option specifies the name of the build stage to stop at, which in this case is ",(0,r.kt)("inlineCode",{parentName:"li"},"builder")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},".")," in the command above means that you want to use the current directory as the build context for the docker build command"))))}T.isMDXComponent=!0;const x={toc:[]},O="wrapper";function S(e){let{components:t,...o}=e;return(0,r.kt)(O,(0,a.Z)({},x,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Docker Networks")),(0,r.kt)("p",null,"Docker networks are a way of ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"managing the communication between containers and other networks")),". Docker networks allow you to isolate your containers, control the traffic flow, and customize the network settings. You can use different types of network drivers to create and configure your networks, such as ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"bridge, overlay, macvlan, host")),", and none. Here is a brief summary of each type:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Bridge networks"),": used ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"within a single host")),". They create a software-based bridge between your host and the container. Containers connected to the network can ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"communicate with each other, but they are isolated from those outside the network")),". Each container in the network ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"is assigned its own IP address")),". Bridge networks are the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"default type"))," when you create a network without specifying any driver.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Overlay networks"),": used for ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"multi-host communication")),". They are distributed networks that span multiple Docker hosts. The network allows all the containers running on any of the hosts to communicate with each other ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"without requiring OS-level routing"))," support. Overlay networks are the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"default type for Docker Swarm clusters")),", but you can also use them when you are running two separate instances of Docker Engine with containers that must directly contact each other.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Macvlan networks"),": used to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"connect Docker containers directly to host network interfaces")),". They ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"allow containers to appear as physical devices on your network")),", with their ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"own MAC addresses and IP addresses")),". Macvlan networks are useful when you want to integrate containerized services with an existing physical network.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Host networks"),": used to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"share your host's network"))," stack without any isolation. Containers that use the host network mode ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"do not get their own IP addresses")),", and port binds are published directly to your host's network interface. This means a container process that listens on port ",(0,r.kt)("inlineCode",{parentName:"p"},"80")," will bind to ",(0,r.kt)("inlineCode",{parentName:"p"},"<your_host_ip>:80"),". Host networks offer the best performance and the least network overhead, but they also expose your containers to potential security risks.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"None networks"),": used to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"disable networking for a container")),". Containers that use the none network mode do not have any access to external networks or other containers. They only have a loopback interface and can only communicate with themselves. None networks are useful when you want to run a container in an isolated environment for testing or debugging purposes.")))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Usecases of Docker Networks")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Bridge networks"),": A typical use case for bridge networks is when you want to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"run multiple containers that form a single application")),", such as a web server and a database server, and you want them to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"communicate with each other on the same host")),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Overlay networks"),": A typical use case for overlay networks is when you want to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"scale your application across multiple hosts or regions")),", and you need a consistent and secure way of networking your containers.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Macvlan networks"),": A typical use case for macvlan networks is when you have ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"legacy applications that rely on specific IP addresses or MAC addresses")),", and you want to migrate them to Docker without changing their configuration.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Host networks"),": A typical use case for host networks is ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"when you want to run a container that needs to listen on a specific port on the host")),", such as a web server that needs to listen on port 80.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"None networks"),": None networks are useful when you want to run a container in an isolated environment for testing or debugging purposes.")))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Bridge networks Architecture")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"bridge-networks",src:n(93043).Z,width:"551",height:"514"})),(0,r.kt)("p",null,"There\u2019s two types of networks: private network (docker network), phycical net work (host net work)."),(0,r.kt)("p",null,'To make docker containers can communicate with each other, you need to map private network to host net work. But the Question is "How to mapping them together"? The Answer is: ',(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Using a bridge driver (software of docker)"))," to map a single bridge can be used to connect ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"multiple containers to the physical network"))," (many - 1)."),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"docker network create my-bridge\ndocker run -it --network my-bridge --name webserver nginx\ndocker run -it --network my-bridge --name database mysql\n")),(0,r.kt)("p",null,"This will create a bridge network called ",(0,r.kt)("inlineCode",{parentName:"p"},"my-bridge")," and ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"connect both the ",(0,r.kt)("inlineCode",{parentName:"em"},"webserver")," and ",(0,r.kt)("inlineCode",{parentName:"em"},"database")," containers to it")),". The webserver container will be able to communicate with the database container, and vice versa.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Macvlan networks Architecture")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Macvlan",src:n(2310).Z,width:"545",height:"550"})),(0,r.kt)("p",null,"Similar to Bridge networks Architecture but Macvlan ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"is mapping directly (1-1) from private network to phycical network")),". A container is like real host machine."),(0,r.kt)("p",null,"Latency in macvlan networks is low since packets are routed directly from Docker host ",(0,r.kt)("strong",{parentName:"p"},"network interface controller (NIC)")," to the containers (they create ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"a direct link between the container and the host's NIC")),". This means that packets do not have to go through the software bridge, which can add latency)."),(0,r.kt)("p",null,"Macvlan (",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"routing real eth to virtual eth")),") has to be configured per host (This means that you cannot create a macvlan network that spans multiple hosts), and has support for physical NIC, sub-interface. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"$ docker network create -d macvlan \\\xa0\n\xa0--subnet=192.168.40.0/24\xa0\\\xa0\n\xa0--gateway=192.168.40.1\xa0\\\xa0\xa0\n-o parent=eth0 my-macvlan-net\n\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Overlay networks Architecture")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Overlay",src:n(55887).Z,width:"804",height:"539"})),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Bridge networks and macvlan networks are local networks")),", which means that they only work for containers that are running on the same Docker host (within a node). "),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Overlay networks, on the other hand, are cluster networks")),", which means that they can be used to connect containers that are running ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"on different Docker hosts")),"."),(0,r.kt)("p",null,"Overlay is virtual network, it\u2019s mapped to real host network (many \u2013 many) by VXLAN tunnel (",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"a single VXLAN tunnel can be used to connect multiple containers to multiple hosts")),"). This means that all of the containers that are connected to the tunnel will be able to communicate with each other, regardless of which host they are running on."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"VXLAN tunnels are a type of ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"tunneling protocol"))," that allows you to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"create a virtual Layer 2 network over a Layer 3 network")),". This means that you can ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"create a network of containers that appear to be on the same physical network")),", even if they are actually running on different hosts.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"VXLAN tunnels are implemented using ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"VXLAN Tunnel Endpoints (VTEPs)")),". VTEPs are devices that terminate VXLAN tunnels. Each Docker host that participates in an overlay network must have a VTEP.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"VXLAN traffic is regular ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"IP/UDP packets")),". The VXLAN header is encapsulated in the UDP packet, and the UDP packet is then sent over the underlying IP network. This means that VXLAN traffic can be routed and forwarded by standard IP routers."))),(0,r.kt)("p",null,"When a container sends a packet on an overlay network, the packet is encapsulated in a VXLAN header and sent to the VTEP on the host where the container is running. The VTEP then tunnels the packet to the VTEP on the host where the destination container is running. The VTEP on the destination host then decapsulates the packet and delivers it to the destination container."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"docker network create my-overlay\ndocker run -it --network my-overlay --name webserver nginx\ndocker run -it --network my-overlay --name database mysql\n")),(0,r.kt)("p",null,"This will create an overlay network called ",(0,r.kt)("inlineCode",{parentName:"p"},"my-overlay")," and connect both the ",(0,r.kt)("inlineCode",{parentName:"p"},"webserver")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"database")," containers to it. The ",(0,r.kt)("inlineCode",{parentName:"p"},"webserver")," container will be able to communicate with the ",(0,r.kt)("inlineCode",{parentName:"p"},"database")," container, even though they are running on different hosts.")))}S.isMDXComponent=!0;const E={toc:[{value:"How Docker Swarm works in three machines:",id:"how-docker-swarm-works-in-three-machines",level:4}]},M="wrapper";function P(e){let{components:t,...o}=e;return(0,r.kt)(M,(0,a.Z)({},E,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,(0,r.kt)("h5",null,"How Docker Swarm Works")),(0,r.kt)("p",null,"Docker Swarm is a tool that allows you to create and manage a cluster of Docker nodes, also known as a swarm. A swarm consists of one or more manager nodes, which are responsible for orchestrating the deployment and operation of services across the cluster, and zero or more worker nodes, which are the machines that run the containers."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Swarm_ArchitectureDiagram",src:n(6316).Z,width:"2020",height:"1188"}),"\n",(0,r.kt)("img",{alt:"Docker-EngineClient",src:n(85205).Z,width:"2048",height:"1403"})),(0,r.kt)("h4",{id:"how-docker-swarm-works-in-three-machines"},"How Docker Swarm works in three machines:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Initialize a swarm on the first machine."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"docker swarm init\n")),(0,r.kt)("p",null,"This will initialize a swarm and elect a leader. The leader is the node that will be responsible for managing the swarm."),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Join the swarm on the second machine."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"# The token is generated when the swarm is initialized at step 1\ndocker swarm join --token SWMTKN-1-233xxxxxxx-456789012345\n")),(0,r.kt)("p",null,"This will join the second machine to the swarm. The second machine will be assigned a role of worker. Workers are responsible for running containers."),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Join the swarm on the third machine."))),(0,r.kt)("p",null,"You can run the command below in any of the three machines"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"docker swarm join --token SWMTKN-1-233xxxxxxx-456789012345\n")),(0,r.kt)("p",null,"This will join the third machine to the swarm. The third machine will also be assigned a role of worker."),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Deploy a service."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"docker service create --name my-service nginx\n")),(0,r.kt)("p",null,"This will deploy a service called ",(0,r.kt)("inlineCode",{parentName:"p"},"my-service"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"my-service")," service will run a single nginx container on each of the three machines."),(0,r.kt)("p",null,"If you already have a service called my-service defined, then you can run the ",(0,r.kt)("inlineCode",{parentName:"p"},"docker service scale")," command below."),(0,r.kt)("ol",{start:5},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Scale the service."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"docker service scale my-service=3\n")),(0,r.kt)("p",null,"This will scale the ",(0,r.kt)("inlineCode",{parentName:"p"},"my-service")," service to 3 replicas. This means that there will be 3 nginx containers running on the three machines."),(0,r.kt)("ol",{start:6},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Verify that the service is running."))),(0,r.kt)("p",null,"You can verify that the service is running by running the ",(0,r.kt)("inlineCode",{parentName:"p"},"docker service ps my-service")," command. This will show you the status of the containers that are running for the ",(0,r.kt)("inlineCode",{parentName:"p"},"my-service")," service."),(0,r.kt)("p",null,"Here is an example of the output of the ",(0,r.kt)("inlineCode",{parentName:"p"},"docker service ps my-service")," command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"NAME           REPLICAS   IMAGE                                    PORTS\nmy-service      3/3        nginx:latest                              *:80->80/tcp\n")),(0,r.kt)("p",null,"This output shows that there are 3 replicas of the ",(0,r.kt)("inlineCode",{parentName:"p"},"my-service")," service running. Each replica is running a nginx container. The nginx containers are listening on port 80."),(0,r.kt)("p",null,"Docker Swarm is a powerful tool that can be used to manage Docker containers on multiple hosts. It is a good choice for applications that need to be highly available or that need to be scaled.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("h5",null,"Docker Swarm vs Kubernetes")),(0,r.kt)("p",null,"Here is a table that summarizes some of the main differences between the two tools for container orchestration:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Feature"),(0,r.kt)("th",{parentName:"tr",align:null},"Docker Swarm"),(0,r.kt)("th",{parentName:"tr",align:null},"Kubernetes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Ease of use"),(0,r.kt)("td",{parentName:"tr",align:null},"Simple and easy to use, native integration with Docker, same CLI as Docker"),(0,r.kt)("td",{parentName:"tr",align:null},"Complex and difficult to use, requires more configuration and setup, has its own CLI and API")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Scalability"),(0,r.kt)("td",{parentName:"tr",align:null},"Less scalable and resilient, can handle smaller and simpler workloads, only supports horizontal scaling"),(0,r.kt)("td",{parentName:"tr",align:null},"More scalable and resilient, can handle larger and more complex workloads, supports both horizontal and vertical scaling")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Features"),(0,r.kt)("td",{parentName:"tr",align:null},"Fewer features and functionalities, supports basic use cases and scenarios, smaller and less active community"),(0,r.kt)("td",{parentName:"tr",align:null},"More features and functionalities, supports a wider range of use cases and scenarios, larger and more active community")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Compatibility"),(0,r.kt)("td",{parentName:"tr",align:null},"More compatible with Docker, works seamlessly with other Docker tools and services, less compatible with other platforms or vendors"),(0,r.kt)("td",{parentName:"tr",align:null},"Less compatible with Docker, may require additional tools or plugins to integrate with Docker or other platforms, more compatible with other platforms or vendors"))))))}P.isMDXComponent=!0;const I={sidebar_position:3,id:"docker-from-zero-hero",sidebar_label:"Docker Interviews",title:"Docker Zero To Hero",tags:["Docker Interviews"]},R="Docker Zero To Hero",A={unversionedId:"docker/docker-from-zero-hero",id:"docker/docker-from-zero-hero",title:"Docker Zero To Hero",description:"Container vs VirtualMachine",source:"@site/docs/docker/1.intro.md",sourceDirName:"docker",slug:"/docker/docker-from-zero-hero",permalink:"/devviews/interviews/docker/docker-from-zero-hero",draft:!1,editUrl:"https://github.com/owntuts/devviews/edit/main/docs/docker/1.intro.md",tags:[{label:"Docker Interviews",permalink:"/devviews/interviews/tags/docker-interviews"}],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,id:"docker-from-zero-hero",sidebar_label:"Docker Interviews",title:"Docker Zero To Hero",tags:["Docker Interviews"]},sidebar:"dockerInterviewSidebar"},L={},_=[{value:"Container vs VirtualMachine",id:"container-vs-virtualmachine",level:3},{value:"Docker Architecture",id:"docker-architecture",level:3},{value:"Docker Build Pipeline",id:"docker-build-pipeline",level:3},{value:"Docker Building Stages",id:"docker-building-stages",level:3},{value:"RUN vs CMD vs ENTRYPOINT",id:"run-vs-cmd-vs-entrypoint",level:3},{value:"Docker Compose Declaration",id:"docker-compose-declaration",level:3},{value:"Dockerfile Commands",id:"dockerfile-commands",level:3},{value:"Docker Networks",id:"docker-networks",level:3},{value:"Docker Swarm",id:"docker-swarm",level:3}],V={toc:_},X="wrapper";function Z(e){let{components:t,...n}=e;return(0,r.kt)(X,(0,a.Z)({},V,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"docker-zero-to-hero"},"Docker Zero To Hero"),(0,r.kt)("h3",{id:"container-vs-virtualmachine"},"Container vs VirtualMachine"),(0,r.kt)(l,{mdxType:"ContainerVsVirtualMachine"}),(0,r.kt)("h3",{id:"docker-architecture"},"Docker Architecture"),(0,r.kt)(w,{mdxType:"Architecture"}),(0,r.kt)("h3",{id:"docker-build-pipeline"},"Docker Build Pipeline"),(0,r.kt)(b,{mdxType:"BuildPipeline"}),(0,r.kt)("h3",{id:"docker-building-stages"},"Docker Building Stages"),(0,r.kt)(T,{mdxType:"BuildingStages"}),(0,r.kt)("h3",{id:"run-vs-cmd-vs-entrypoint"},"RUN vs CMD vs ENTRYPOINT"),(0,r.kt)(g,{mdxType:"RUNCMDENTRYPOINT"}),(0,r.kt)("h3",{id:"docker-compose-declaration"},"Docker Compose Declaration"),(0,r.kt)(c,{mdxType:"DockerCompose"}),(0,r.kt)("h3",{id:"dockerfile-commands"},"Dockerfile Commands"),(0,r.kt)(k,{mdxType:"DockerfileCommands"}),(0,r.kt)("h3",{id:"docker-networks"},"Docker Networks"),(0,r.kt)(S,{mdxType:"DockerNetworks"}),(0,r.kt)("h3",{id:"docker-swarm"},"Docker Swarm"),(0,r.kt)(P,{mdxType:"DockerSwarm"}))}Z.isMDXComponent=!0},85205:function(e,t,n){t.Z=n.p+"assets/images/Docker-EngineClient-2048x1403-ea7fc8c015355ee17e894c1e2a52bb96.png"},2310:function(e,t,n){t.Z=n.p+"assets/images/Macvlan-2585ca3450878e9c9eafbbb1c1a295b2.png"},55887:function(e,t,n){t.Z=n.p+"assets/images/Overlay-4772fabc032492a6bd0507227238453b.png"},6316:function(e,t,n){t.Z=n.p+"assets/images/Swarm_ArchitectureDiagram-e07cd26dc6e5e1bce7936f8e725857af.png"},18723:function(e,t,n){t.Z=n.p+"assets/images/architecture-a858870ea76d80cb2395ed46ca53d5d0.png"},93043:function(e,t,n){t.Z=n.p+"assets/images/bridge-networks-7acab496ded2b873448bf59d6f282a2c.png"},6746:function(e,t,n){t.Z=n.p+"assets/images/build-pipeline-bc22b1ea8ef6111a27b735eda0d42972.png"},84118:function(e,t,n){t.Z=n.p+"assets/images/build-stages-f1d4d89ae22ad52e90558af41852f87e.png"},98424:function(e,t,n){t.Z=n.p+"assets/images/containervsvirtialmachine-b2cd86af349cbdddc1df9b2c940445e8.png"}}]);